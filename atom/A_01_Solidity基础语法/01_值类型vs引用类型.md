# å€¼ç±»å‹ vs å¼•ç”¨ç±»å‹

## 1. ã€30å­—æ ¸å¿ƒã€‘

**Solidityæ•°æ®ç±»å‹åˆ†ä¸ºå€¼ç±»å‹ï¼ˆèµ‹å€¼æ—¶å¤åˆ¶æ•°æ®ï¼‰å’Œå¼•ç”¨ç±»å‹ï¼ˆèµ‹å€¼æ—¶å¤åˆ¶å¼•ç”¨ï¼‰ï¼Œç†è§£ä¸¤è€…åŒºåˆ«æ˜¯é¿å…åˆçº¦Bugå’Œä¼˜åŒ–Gasçš„å…³é”®ã€‚**

---

## 2. ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### å€¼ç±»å‹vså¼•ç”¨ç±»å‹çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**å€¼ç±»å‹ï¼ˆValue Typesï¼‰** = èµ‹å€¼æ—¶å¤åˆ¶æ•°æ®æœ¬èº«
**å¼•ç”¨ç±»å‹ï¼ˆReference Typesï¼‰** = èµ‹å€¼æ—¶å¤åˆ¶æ•°æ®çš„å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰

ä»…æ­¤è€Œå·²ï¼æ²¡æœ‰æ›´åŸºç¡€çš„äº†ã€‚

#### 2. ä¸ºä»€ä¹ˆéœ€è¦åŒºåˆ†è¿™ä¸¤ç§ç±»å‹ï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šåœ¨åŒºå—é“¾ä¸Šå­˜å‚¨æ•°æ®éå¸¸æ˜‚è´µï¼Œå¦‚ä½•é«˜æ•ˆç®¡ç†ä¸åŒå¤§å°çš„æ•°æ®ï¼Ÿ**

- **å°æ•°æ®**ï¼ˆå¦‚æ•°å­—ã€åœ°å€ï¼‰ï¼šç›´æ¥å¤åˆ¶æˆæœ¬ä½ï¼Œä½¿ç”¨å€¼ç±»å‹
- **å¤§æ•°æ®**ï¼ˆå¦‚æ•°ç»„ã€ç»“æ„ä½“ï¼‰ï¼šç›´æ¥å¤åˆ¶æˆæœ¬é«˜ï¼Œä½¿ç”¨å¼•ç”¨ç±»å‹æŒ‰éœ€å¤åˆ¶

#### 3. ä¸¤ç§ç±»å‹çš„ä¸‰å±‚ä»·å€¼

##### ä»·å€¼1ï¼šå†…å­˜æ•ˆç‡

**å€¼ç±»å‹**ï¼šæ•°æ®ç›´æ¥å­˜å‚¨åœ¨æ ˆï¼ˆStackï¼‰ä¸Šï¼Œè®¿é—®å¿«é€Ÿ
**å¼•ç”¨ç±»å‹**ï¼šæ•°æ®å­˜å‚¨åœ¨å †ï¼ˆHeapï¼‰ä¸Šï¼Œé€šè¿‡æŒ‡é’ˆè®¿é—®

```solidity
// å€¼ç±»å‹ï¼šç›´æ¥å­˜å‚¨åœ¨æ ˆä¸Š
uint256 a = 100;  // å ç”¨32å­—èŠ‚ï¼Œç›´æ¥å­˜å‚¨

// å¼•ç”¨ç±»å‹ï¼šé€šè¿‡æŒ‡é’ˆè®¿é—®å †ä¸Šçš„æ•°æ®
uint256[] arr;    // å˜é‡å­˜å‚¨æŒ‡å‘æ•°ç»„æ•°æ®çš„æŒ‡é’ˆ
```

##### ä»·å€¼2ï¼šGasä¼˜åŒ–

**å€¼ç±»å‹**ï¼šå¤åˆ¶æˆæœ¬å›ºå®šä¸”è¾ƒä½
**å¼•ç”¨ç±»å‹**ï¼šå¤åˆ¶æˆæœ¬ä¸æ•°æ®å¤§å°æˆæ­£æ¯”ï¼Œéœ€è¦æŒ‡å®šæ•°æ®ä½ç½®ï¼ˆstorage/memory/calldataï¼‰

```solidity
// å€¼ç±»å‹èµ‹å€¼ï¼šå›ºå®šGasï¼ˆçº¦3 Gasï¼‰
uint256 b = a;

// å¼•ç”¨ç±»å‹èµ‹å€¼ï¼šGaså–å†³äºæ•°ç»„å¤§å°
uint256[] memory arr2 = arr;  // éœ€è¦å¤åˆ¶æ•´ä¸ªæ•°ç»„ï¼
```

##### ä»·å€¼3ï¼šå¯é¢„æµ‹çš„è¡Œä¸º

ç†è§£å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹ï¼Œå¯ä»¥é¢„æµ‹ï¼š
- ä¿®æ”¹å˜é‡æ˜¯å¦å½±å“åŸå§‹æ•°æ®
- å‡½æ•°å‚æ•°ä¼ é€’çš„è¡Œä¸º
- Storageå’ŒMemoryä¹‹é—´çš„æ•°æ®æµåŠ¨

#### 4. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼Solidityç±»å‹ç³»ç»Ÿ

**æ¨ç†é“¾ï¼š**

```
1. å‰æï¼šåŒºå—é“¾å­˜å‚¨æ¯ä¸ªå­—èŠ‚éƒ½è¦èŠ±Gas
   â†“
2. æ¨å¯¼ï¼šå°æ•°æ®ï¼ˆâ‰¤32å­—èŠ‚ï¼‰å¯ä»¥é«˜æ•ˆå¤åˆ¶ â†’ è®¾è®¡ä¸ºå€¼ç±»å‹
   â†“
3. æ¨å¯¼ï¼šå¤§æ•°æ®ï¼ˆæ•°ç»„ã€æ˜ å°„ç­‰ï¼‰å¤åˆ¶æˆæœ¬é«˜ â†’ è®¾è®¡ä¸ºå¼•ç”¨ç±»å‹
   â†“
4. æ¨å¯¼ï¼šå¼•ç”¨ç±»å‹éœ€è¦æŒ‡å®šå­˜å‚¨ä½ç½® â†’ å¼•å…¥storage/memory/calldata
   â†“
5. æ¨å¯¼ï¼šä¸åŒä½ç½®ä¹‹é—´çš„èµ‹å€¼è¡Œä¸ºä¸åŒ â†’ éœ€è¦ç†è§£å¤åˆ¶vså¼•ç”¨è¯­ä¹‰
   â†“
6. æœ€ç»ˆï¼šSolidityçš„ç±»å‹ç³»ç»Ÿ = å€¼ç±»å‹ + å¼•ç”¨ç±»å‹ + æ•°æ®ä½ç½®
```

#### 5. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**å€¼ç±»å‹é€‚åˆå°å‹å›ºå®šæ•°æ®çš„é«˜æ•ˆå¤åˆ¶ï¼Œå¼•ç”¨ç±»å‹é€‚åˆå¤§å‹åŠ¨æ€æ•°æ®çš„çµæ´»ç®¡ç†ï¼ŒåŒºåˆ†ä¸¤è€…æ˜¯Solidityé«˜æ•ˆç¼–ç¨‹çš„åŸºç¡€ã€‚**

---

## 3. ã€3ä¸ªæ ¸å¿ƒæ¦‚å¿µã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼šå€¼ç±»å‹ï¼ˆValue Typesï¼‰ğŸ“¦

**ä¸€å¥è¯å®šä¹‰ï¼š** å€¼ç±»å‹å˜é‡ç›´æ¥å­˜å‚¨æ•°æ®ï¼Œèµ‹å€¼æ—¶åˆ›å»ºç‹¬ç«‹å‰¯æœ¬ï¼Œä¿®æ”¹å‰¯æœ¬ä¸å½±å“åŸå€¼ã€‚

#### Solidityä¸­çš„å€¼ç±»å‹ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ValueTypes {
    // ===== 1. æ•´æ•°ç±»å‹ =====
    uint256 public unsignedInt = 100;     // æ— ç¬¦å·æ•´æ•°ï¼ˆ0 åˆ° 2^256-1ï¼‰
    int256 public signedInt = -50;        // æœ‰ç¬¦å·æ•´æ•°ï¼ˆ-2^255 åˆ° 2^255-1ï¼‰
    uint8 public smallInt = 255;          // 8ä½æ— ç¬¦å·ï¼ˆ0-255ï¼‰
    
    // ===== 2. å¸ƒå°”ç±»å‹ =====
    bool public isActive = true;          // true æˆ– false
    
    // ===== 3. åœ°å€ç±»å‹ =====
    address public wallet = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;
    address payable public payableWallet; // å¯æ¥æ”¶ETHçš„åœ°å€
    
    // ===== 4. å®šé•¿å­—èŠ‚æ•°ç»„ =====
    bytes1 public singleByte = 0x42;      // 1å­—èŠ‚
    bytes32 public hash = keccak256("hello"); // 32å­—èŠ‚ï¼ˆå¸¸ç”¨äºå“ˆå¸Œï¼‰
    
    // ===== 5. æšä¸¾ç±»å‹ =====
    enum Status { Pending, Active, Completed }
    Status public currentStatus = Status.Pending;
    
    // ===== å€¼ç±»å‹èµ‹å€¼æ¼”ç¤º =====
    function demonstrateValueCopy() public pure returns (uint256, uint256) {
        uint256 a = 100;
        uint256 b = a;  // å¤åˆ¶å€¼ï¼Œbæ˜¯açš„ç‹¬ç«‹å‰¯æœ¬
        b = 200;        // ä¿®æ”¹bä¸å½±å“a
        return (a, b);  // è¿”å› (100, 200)
    }
}
```

**è¯¦ç»†è§£é‡Šï¼š**

| å€¼ç±»å‹ | å¤§å° | è¯´æ˜ |
|-------|------|------|
| `bool` | 1å­—èŠ‚ | true/false |
| `uint8` - `uint256` | 1-32å­—èŠ‚ | æ— ç¬¦å·æ•´æ•°ï¼Œæ­¥é•¿8ä½ |
| `int8` - `int256` | 1-32å­—èŠ‚ | æœ‰ç¬¦å·æ•´æ•°ï¼Œæ­¥é•¿8ä½ |
| `address` | 20å­—èŠ‚ | ä»¥å¤ªåŠåœ°å€ |
| `bytes1` - `bytes32` | 1-32å­—èŠ‚ | å®šé•¿å­—èŠ‚æ•°ç»„ |
| `enum` | å–å†³äºé€‰é¡¹æ•° | æšä¸¾ç±»å‹ |

**åœ¨æ™ºèƒ½åˆçº¦å¼€å‘ä¸­çš„åº”ç”¨ï¼š**

```solidity
// å…¸å‹åº”ç”¨ï¼šERC20ä»£å¸çš„ä½™é¢å’Œè½¬è´¦
mapping(address => uint256) public balances;  // åœ°å€ â†’ ä½™é¢

function transfer(address to, uint256 amount) public {
    // å€¼ç±»å‹å‚æ•°ï¼štoå’Œamountéƒ½æ˜¯ç‹¬ç«‹å‰¯æœ¬
    balances[msg.sender] -= amount;
    balances[to] += amount;
}
```

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šå¼•ç”¨ç±»å‹ï¼ˆReference Typesï¼‰ğŸ”—

**ä¸€å¥è¯å®šä¹‰ï¼š** å¼•ç”¨ç±»å‹å˜é‡å­˜å‚¨æ•°æ®çš„å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰ï¼Œèµ‹å€¼æ—¶é»˜è®¤å¤åˆ¶å¼•ç”¨ï¼Œéœ€è¦æŒ‡å®šæ•°æ®ä½ç½®ï¼ˆstorage/memory/calldataï¼‰ã€‚

#### Solidityä¸­çš„å¼•ç”¨ç±»å‹ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ReferenceTypes {
    // ===== 1. åŠ¨æ€æ•°ç»„ =====
    uint256[] public dynamicArray;           // åŠ¨æ€å¤§å°æ•°ç»„
    uint256[5] public fixedArray;            // å›ºå®šå¤§å°æ•°ç»„ï¼ˆä¹Ÿæ˜¯å¼•ç”¨ç±»å‹ï¼ï¼‰
    
    // ===== 2. æ˜ å°„ï¼ˆMappingï¼‰=====
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances; // åµŒå¥—æ˜ å°„
    
    // ===== 3. ç»“æ„ä½“ï¼ˆStructï¼‰=====
    struct User {
        string name;
        uint256 age;
        address wallet;
    }
    User public user;
    User[] public users;
    
    // ===== 4. å­—ç¬¦ä¸²å’ŒåŠ¨æ€å­—èŠ‚ =====
    string public name = "Alice";
    bytes public data = hex"001122";
    
    // ===== å¼•ç”¨ç±»å‹èµ‹å€¼æ¼”ç¤ºï¼ˆstorageå¼•ç”¨ï¼‰=====
    function demonstrateStorageReference() public {
        dynamicArray.push(100);
        dynamicArray.push(200);
        
        // storageå¼•ç”¨ï¼šarræŒ‡å‘åŒä¸€ä¸ªå­˜å‚¨ä½ç½®
        uint256[] storage arr = dynamicArray;
        arr[0] = 999;  // ä¿®æ”¹arrä¹Ÿä¼šä¿®æ”¹dynamicArrayï¼
        
        // æ­¤æ—¶ dynamicArray[0] == 999
    }
    
    // ===== å¼•ç”¨ç±»å‹èµ‹å€¼æ¼”ç¤ºï¼ˆmemoryå¤åˆ¶ï¼‰=====
    function demonstrateMemoryCopy() public view returns (uint256) {
        // memoryå¤åˆ¶ï¼šåˆ›å»ºç‹¬ç«‹å‰¯æœ¬
        uint256[] memory arr = dynamicArray;
        arr[0] = 888;  // ä¿®æ”¹arrä¸å½±å“dynamicArray
        
        return dynamicArray[0];  // ä»ç„¶æ˜¯999ï¼ˆå¦‚æœä¹‹å‰è°ƒç”¨è¿‡ä¸Šé¢çš„å‡½æ•°ï¼‰
    }
}
```

**è¯¦ç»†è§£é‡Šï¼š**

| å¼•ç”¨ç±»å‹ | è¯´æ˜ | å¿…é¡»æŒ‡å®šä½ç½® |
|---------|------|-------------|
| `T[]` | åŠ¨æ€æ•°ç»„ | âœ… |
| `T[n]` | å›ºå®šæ•°ç»„ | âœ… |
| `mapping` | æ˜ å°„ | åªèƒ½æ˜¯storage |
| `struct` | ç»“æ„ä½“ | âœ… |
| `string` | å­—ç¬¦ä¸² | âœ… |
| `bytes` | åŠ¨æ€å­—èŠ‚ | âœ… |

**å…³é”®åŒºåˆ«ï¼šStorageå¼•ç”¨ vs Memoryå¤åˆ¶**

```solidity
// Storageå¼•ç”¨ï¼šä¿®æ”¹ä¼šå½±å“åŸæ•°æ®
uint256[] storage arr = stateArray;  // arræ˜¯stateArrayçš„åˆ«å
arr[0] = 100;  // stateArray[0]ä¹Ÿå˜æˆ100

// Memoryå¤åˆ¶ï¼šä¿®æ”¹ä¸å½±å“åŸæ•°æ®
uint256[] memory arr = stateArray;   // arræ˜¯stateArrayçš„å‰¯æœ¬
arr[0] = 100;  // stateArray[0]ä¸å˜
```

**åœ¨æ™ºèƒ½åˆçº¦å¼€å‘ä¸­çš„åº”ç”¨ï¼š**

```solidity
// å…¸å‹åº”ç”¨ï¼šNFTåˆçº¦ä¸­çš„Tokenå…ƒæ•°æ®
struct TokenMetadata {
    string name;
    string description;
    string imageURI;
}

mapping(uint256 => TokenMetadata) public tokenMetadata;

function setMetadata(uint256 tokenId, string memory _name) public {
    // ä½¿ç”¨storageå¼•ç”¨ç›´æ¥ä¿®æ”¹çŠ¶æ€
    TokenMetadata storage meta = tokenMetadata[tokenId];
    meta.name = _name;  // ç›´æ¥ä¿®æ”¹storageä¸­çš„æ•°æ®
}
```

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼šæ•°æ®ä½ç½®ï¼ˆData Locationï¼‰ğŸ“

**ä¸€å¥è¯å®šä¹‰ï¼š** å¼•ç”¨ç±»å‹å¿…é¡»æŒ‡å®šæ•°æ®ä½ç½®ï¼ˆstorage/memory/calldataï¼‰ï¼Œä¸åŒä½ç½®å†³å®šæ•°æ®çš„ç”Ÿå‘½å‘¨æœŸã€Gasæˆæœ¬å’Œå¯ä¿®æ”¹æ€§ã€‚

#### ä¸‰ç§æ•°æ®ä½ç½®å¯¹æ¯”ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DataLocations {
    // ===== Storageï¼šæ°¸ä¹…å­˜å‚¨ =====
    uint256[] public storageArray;  // çŠ¶æ€å˜é‡é»˜è®¤æ˜¯storage
    
    // ===== Memoryï¼šä¸´æ—¶å†…å­˜ =====
    function useMemory() public pure returns (uint256[] memory) {
        uint256[] memory memArray = new uint256[](3);
        memArray[0] = 100;
        return memArray;  // å‡½æ•°ç»“æŸåmemArrayè¢«é”€æ¯
    }
    
    // ===== Calldataï¼šåªè¯»å‚æ•° =====
    function useCalldata(uint256[] calldata inputArray) external pure returns (uint256) {
        // inputArrayæ˜¯åªè¯»çš„ï¼Œä¸èƒ½ä¿®æ”¹
        // inputArray[0] = 100;  // âŒ ç¼–è¯‘é”™è¯¯ï¼
        return inputArray[0];
    }
    
    // ===== ä½ç½®ä¹‹é—´çš„è½¬æ¢ =====
    function locationConversions(uint256[] calldata input) external {
        // calldata â†’ storageï¼šå¤åˆ¶æ•°æ®
        storageArray = input;
        
        // storage â†’ memoryï¼šå¤åˆ¶æ•°æ®
        uint256[] memory memCopy = storageArray;
        
        // calldata â†’ memoryï¼šå¤åˆ¶æ•°æ®
        uint256[] memory memFromCalldata = input;
    }
}
```

**ä¸‰ç§ä½ç½®è¯¦ç»†å¯¹æ¯”ï¼š**

| ç‰¹æ€§ | storage | memory | calldata |
|-----|---------|--------|----------|
| **ç”Ÿå‘½å‘¨æœŸ** | æ°¸ä¹…ï¼ˆå†™å…¥åŒºå—é“¾ï¼‰ | å‡½æ•°æ‰§è¡ŒæœŸé—´ | å‡½æ•°æ‰§è¡ŒæœŸé—´ |
| **Gasæˆæœ¬** | æœ€é«˜ï¼ˆ20000å†™/5000æ”¹ï¼‰ | ä¸­ç­‰ï¼ˆ3 Gas/å­—ï¼‰ | æœ€ä½ï¼ˆåªè¯»ï¼‰ |
| **å¯ä¿®æ”¹æ€§** | âœ… å¯ä¿®æ”¹ | âœ… å¯ä¿®æ”¹ | âŒ åªè¯» |
| **é»˜è®¤ä½¿ç”¨** | çŠ¶æ€å˜é‡ | å‡½æ•°å†…å±€éƒ¨å˜é‡ | externalå‡½æ•°å‚æ•° |

**Gasä¼˜åŒ–æŠ€å·§ï¼š**

```solidity
// âŒ ä½æ•ˆï¼šå¤šæ¬¡è¯»å–storage
function inefficient() public view returns (uint256) {
    uint256 sum = 0;
    for (uint i = 0; i < storageArray.length; i++) {
        sum += storageArray[i];  // æ¯æ¬¡å¾ªç¯éƒ½è¯»storageï¼ˆæ˜‚è´µï¼ï¼‰
    }
    return sum;
}

// âœ… é«˜æ•ˆï¼šå…ˆå¤åˆ¶åˆ°memory
function efficient() public view returns (uint256) {
    uint256[] memory arr = storageArray;  // ä¸€æ¬¡æ€§å¤åˆ¶åˆ°memory
    uint256 sum = 0;
    for (uint i = 0; i < arr.length; i++) {
        sum += arr[i];  // è¯»memoryï¼ˆä¾¿å®œï¼ï¼‰
    }
    return sum;
}

// âœ… æ›´é«˜æ•ˆï¼šä½¿ç”¨calldataï¼ˆå¤–éƒ¨è°ƒç”¨ï¼‰
function mostEfficient(uint256[] calldata arr) external pure returns (uint256) {
    uint256 sum = 0;
    for (uint i = 0; i < arr.length; i++) {
        sum += arr[i];  // calldataæœ€ä¾¿å®œ
    }
    return sum;
}
```

---

## 4. ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹å†…å®¹ï¼Œå°±èƒ½æ­£ç¡®å¤„ç†Solidityä¸­çš„æ•°æ®ç±»å‹ï¼š

### 4.1 è®°ä½å€¼ç±»å‹åˆ—è¡¨

```solidity
// å€¼ç±»å‹ï¼šèµ‹å€¼æ—¶å¤åˆ¶æ•°æ®
uint256 / int256    // æ•´æ•°
bool                // å¸ƒå°”
address             // åœ°å€
bytes1 - bytes32    // å®šé•¿å­—èŠ‚
enum                // æšä¸¾
```

### 4.2 è®°ä½å¼•ç”¨ç±»å‹åˆ—è¡¨

```solidity
// å¼•ç”¨ç±»å‹ï¼šéœ€è¦æŒ‡å®šæ•°æ®ä½ç½®
uint256[] / T[]     // åŠ¨æ€æ•°ç»„
uint256[10] / T[n]  // å›ºå®šæ•°ç»„
mapping(K => V)     // æ˜ å°„ï¼ˆåªèƒ½storageï¼‰
struct              // ç»“æ„ä½“
string              // å­—ç¬¦ä¸²
bytes               // åŠ¨æ€å­—èŠ‚
```

### 4.3 é€‰æ‹©æ­£ç¡®çš„æ•°æ®ä½ç½®

```solidity
// è§„åˆ™1ï¼šçŠ¶æ€å˜é‡ â†’ storageï¼ˆé»˜è®¤ï¼Œä¸ç”¨å†™ï¼‰
uint256[] public myArray;

// è§„åˆ™2ï¼šå‡½æ•°å‚æ•°ï¼ˆexternalï¼‰â†’ calldataï¼ˆåªè¯»ï¼Œæœ€çœGasï¼‰
function foo(uint256[] calldata arr) external {}

// è§„åˆ™3ï¼šå‡½æ•°å‚æ•°ï¼ˆpublic/internalï¼‰â†’ memory
function bar(uint256[] memory arr) public {}

// è§„åˆ™4ï¼šå‡½æ•°å†…éƒ¨ä¸´æ—¶å˜é‡ â†’ memory
function baz() public {
    uint256[] memory temp = new uint256[](10);
}

// è§„åˆ™5ï¼šéœ€è¦ä¿®æ”¹çŠ¶æ€å˜é‡ â†’ storageå¼•ç”¨
function modify() public {
    uint256[] storage arr = myArray;  // å¼•ç”¨ï¼Œä¿®æ”¹ä¼šå½±å“myArray
}
```

### 4.4 ç†è§£èµ‹å€¼è¡Œä¸º

```solidity
// storage â†’ storageï¼šå¼•ç”¨ï¼ˆåŒä¸€ä¸ªæ•°æ®ï¼‰
uint256[] storage a = stateArray;
uint256[] storage b = a;  // bå’ŒaæŒ‡å‘åŒä¸€ä¸ªæ•°æ®

// storage â†’ memoryï¼šå¤åˆ¶ï¼ˆç‹¬ç«‹å‰¯æœ¬ï¼‰
uint256[] memory c = stateArray;  // cæ˜¯å‰¯æœ¬

// memory â†’ memoryï¼šå¼•ç”¨ï¼ˆåŒä¸€ä¸ªæ•°æ®ï¼‰
uint256[] memory d = c;  // då’ŒcæŒ‡å‘åŒä¸€ä¸ªæ•°æ®

// memory â†’ storageï¼šå¤åˆ¶ï¼ˆå†™å…¥åŒºå—é“¾ï¼‰
stateArray = c;  // å¤åˆ¶cåˆ°stateArray
```

### 4.5 å¸¸è§é™·é˜±

```solidity
// âŒ é™·é˜±1ï¼šä»¥ä¸ºmemoryèµ‹å€¼æ˜¯å¤åˆ¶
function trap1() public pure {
    uint256[] memory a = new uint256[](2);
    uint256[] memory b = a;  // bå’Œaæ˜¯åŒä¸€ä¸ªæ•°ç»„ï¼
    b[0] = 100;
    // a[0]ä¹Ÿæ˜¯100ï¼
}

// âŒ é™·é˜±2ï¼šå¿˜è®°storageå¼•ç”¨ä¼šä¿®æ”¹çŠ¶æ€
function trap2() public {
    uint256[] storage arr = stateArray;
    arr[0] = 999;  // stateArray[0]ä¹Ÿå˜æˆ999äº†ï¼
}

// âœ… æ­£ç¡®ï¼šæ˜ç¡®æ„å›¾
function correct() public {
    // å¦‚æœè¦ä¿®æ”¹çŠ¶æ€ï¼Œç”¨storageå¼•ç”¨
    uint256[] storage arr = stateArray;
    arr[0] = 999;
    
    // å¦‚æœåªæ˜¯è¯»å–/ä¸´æ—¶å¤„ç†ï¼Œç”¨memoryå¤åˆ¶
    uint256[] memory copy = stateArray;
    copy[0] = 888;  // ä¸å½±å“stateArray
}
```

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- âœ… æ­£ç¡®å£°æ˜å˜é‡ç±»å‹å’Œæ•°æ®ä½ç½®
- âœ… é¿å…æ„å¤–ä¿®æ”¹çŠ¶æ€å˜é‡
- âœ… ä¼˜åŒ–Gasæ¶ˆè€—
- âœ… ç†è§£å‡½æ•°å‚æ•°çš„ä¼ é€’æ–¹å¼
- âœ… ä¸ºæ·±å…¥å­¦ä¹ storageå¸ƒå±€æ‰“ä¸‹åŸºç¡€

---

## 5. ã€1ä¸ªç±»æ¯”ã€‘

### ç±»æ¯”1ï¼šå€¼ç±»å‹ vs å¼•ç”¨ç±»å‹ ğŸ¨

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šå¤å°æ–‡ä»¶ vs å…±äº«æ–‡ä»¶å¤¹

**å€¼ç±»å‹ = å¤å°æ–‡ä»¶**

æƒ³è±¡ä½ æœ‰ä¸€ä»½é‡è¦çš„åˆåŒæ–‡ä»¶ï¼š
- ä½ æŠŠåˆåŒ**å¤å°ä¸€ä»½**ç»™æœ‹å‹
- æœ‹å‹åœ¨å¤å°ä»¶ä¸Šæ¶‚æ”¹ï¼Œ**ä¸ä¼šå½±å“ä½ çš„åŸä»¶**
- æ¯ä¸ªäººéƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„å‰¯æœ¬

```
åŸä»¶ï¼ˆä½ çš„ï¼‰: åˆåŒé‡‘é¢ 100ä¸‡
     â†“ å¤å°
å‰¯æœ¬ï¼ˆæœ‹å‹çš„ï¼‰: åˆåŒé‡‘é¢ 100ä¸‡
     â†“ æœ‹å‹ä¿®æ”¹å‰¯æœ¬
å‰¯æœ¬ï¼ˆæœ‹å‹çš„ï¼‰: åˆåŒé‡‘é¢ 200ä¸‡  â† åªæœ‰å‰¯æœ¬å˜äº†
åŸä»¶ï¼ˆä½ çš„ï¼‰: åˆåŒé‡‘é¢ 100ä¸‡    â† åŸä»¶ä¸å˜ï¼
```

**å¼•ç”¨ç±»å‹ = å…±äº«æ–‡ä»¶å¤¹**

æƒ³è±¡ä½ åœ¨Google Driveåˆ›å»ºäº†ä¸€ä¸ªå…±äº«æ–‡ä»¶å¤¹ï¼š
- ä½ æŠŠæ–‡ä»¶å¤¹é“¾æ¥å‘ç»™æœ‹å‹
- æœ‹å‹åœ¨æ–‡ä»¶å¤¹é‡Œä¿®æ”¹æ–‡ä»¶ï¼Œ**ä½ ä¹Ÿèƒ½çœ‹åˆ°ä¿®æ”¹**
- æ‰€æœ‰äººæ“ä½œçš„æ˜¯åŒä¸€ä¸ªæ–‡ä»¶å¤¹

```
å…±äº«æ–‡ä»¶å¤¹ï¼ˆä½ å’Œæœ‹å‹éƒ½èƒ½è®¿é—®ï¼‰
â”œâ”€â”€ åˆåŒ.doc (é‡‘é¢: 100ä¸‡)
â”‚
æœ‹å‹ä¿®æ”¹ â†’ åˆåŒ.doc (é‡‘é¢: 200ä¸‡)
â”‚
ä½ çœ‹åˆ°çš„ä¹Ÿæ˜¯ 200ä¸‡ï¼ï¼ˆå› ä¸ºæ˜¯åŒä¸€ä¸ªæ–‡ä»¶ï¼‰
```

**ä¸¾ä¾‹ï¼š**
- **å€¼ç±»å‹**ï¼šä½ æŠŠ100å…ƒç°é‡‘ç»™æœ‹å‹ï¼Œæœ‹å‹æ€ä¹ˆèŠ±ä¸å½±å“ä½ å‰©ä¸‹çš„é’±
- **å¼•ç”¨ç±»å‹**ï¼šä½ æŠŠé“¶è¡Œå¡ç»™æœ‹å‹ï¼ˆå…±äº«è´¦æˆ·ï¼‰ï¼Œæœ‹å‹èŠ±çš„é’±ä¼šå‡å°‘ä½ çš„ä½™é¢

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šåŸºæœ¬ç±»å‹ vs å¯¹è±¡ç±»å‹

å¦‚æœä½ å†™è¿‡JavaScriptï¼Œè¿™ä¸ªæ¦‚å¿µå®Œå…¨ä¸€æ ·ï¼š

```javascript
// ===== JavaScriptä¸­çš„å€¼ç±»å‹ï¼ˆåŸºæœ¬ç±»å‹ï¼‰=====
let a = 100;
let b = a;      // å¤åˆ¶å€¼
b = 200;
console.log(a); // 100ï¼ˆaä¸å—å½±å“ï¼‰

// ===== JavaScriptä¸­çš„å¼•ç”¨ç±»å‹ï¼ˆå¯¹è±¡ï¼‰=====
let arr1 = [1, 2, 3];
let arr2 = arr1;  // å¤åˆ¶å¼•ç”¨ï¼ˆä¸æ˜¯å¤åˆ¶æ•°ç»„ï¼ï¼‰
arr2[0] = 999;
console.log(arr1[0]); // 999ï¼ˆarr1ä¹Ÿè¢«ä¿®æ”¹äº†ï¼ï¼‰
```

**Solidityå®Œå…¨ç›¸åŒï¼š**

```solidity
// ===== Solidityä¸­çš„å€¼ç±»å‹ =====
function valueExample() public pure returns (uint256, uint256) {
    uint256 a = 100;
    uint256 b = a;  // å¤åˆ¶å€¼
    b = 200;
    return (a, b);  // (100, 200) - aä¸å—å½±å“
}

// ===== Solidityä¸­çš„å¼•ç”¨ç±»å‹ï¼ˆmemoryå†…ï¼‰=====
function referenceExample() public pure returns (uint256) {
    uint256[] memory arr1 = new uint256[](3);
    arr1[0] = 1;
    
    uint256[] memory arr2 = arr1;  // å¤åˆ¶å¼•ç”¨ï¼
    arr2[0] = 999;
    
    return arr1[0];  // 999 - arr1ä¹Ÿè¢«ä¿®æ”¹äº†ï¼
}
```

**å…³é”®åŒºåˆ«ï¼šSolidityå¤šäº†æ•°æ®ä½ç½®ï¼ˆstorage/memory/calldataï¼‰**

```javascript
// JavaScriptæ²¡æœ‰æ•°æ®ä½ç½®çš„æ¦‚å¿µ
const arr = [1, 2, 3];  // å°±è¿™æ ·ç”¨

// Solidityå¿…é¡»æŒ‡å®šæ•°æ®ä½ç½®
uint256[] storage arr1;  // æ°¸ä¹…å­˜å‚¨
uint256[] memory arr2;   // ä¸´æ—¶å†…å­˜
uint256[] calldata arr3; // åªè¯»å‚æ•°
```

**å‰ç«¯ç±»æ¯”è¡¨ï¼š**

| Solidity | JavaScript | è¯´æ˜ |
|----------|------------|------|
| `uint256` | `number` | å€¼ç±»å‹ï¼Œèµ‹å€¼å¤åˆ¶ |
| `bool` | `boolean` | å€¼ç±»å‹ï¼Œèµ‹å€¼å¤åˆ¶ |
| `address` | `string`(åœ°å€å­—ç¬¦ä¸²) | å€¼ç±»å‹ï¼Œèµ‹å€¼å¤åˆ¶ |
| `uint256[]` | `Array` | å¼•ç”¨ç±»å‹ï¼Œèµ‹å€¼å¤åˆ¶å¼•ç”¨ |
| `mapping` | `Map` / `Object` | å¼•ç”¨ç±»å‹ï¼Œåªèƒ½åœ¨storage |
| `struct` | `Object` | å¼•ç”¨ç±»å‹ï¼Œèµ‹å€¼å¤åˆ¶å¼•ç”¨ |
| `string` | `String` | Solidityä¸­æ˜¯å¼•ç”¨ç±»å‹ï¼ |

**æ³¨æ„ï¼šJavaScriptçš„Stringæ˜¯ä¸å¯å˜çš„åŸºæœ¬ç±»å‹ï¼Œä½†Solidityçš„stringæ˜¯å¼•ç”¨ç±»å‹ï¼**

---

### ç±»æ¯”2ï¼šæ•°æ®ä½ç½® ğŸ“

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šç¡¬ç›˜ vs å†…å­˜ vs åªè¯»å…‰ç›˜

| æ•°æ®ä½ç½® | ç”Ÿæ´»ç±»æ¯” | ç‰¹ç‚¹ |
|---------|---------|------|
| **storage** | ç¡¬ç›˜ | æ°¸ä¹…ä¿å­˜ï¼Œè¯»å†™æ…¢ï¼Œç©ºé—´è´µ |
| **memory** | å†…å­˜(RAM) | ä¸´æ—¶ä½¿ç”¨ï¼Œè¯»å†™å¿«ï¼Œå…³æœºå°±æ²¡ |
| **calldata** | åªè¯»å…‰ç›˜ | åªèƒ½è¯»å–ï¼Œä¸èƒ½ä¿®æ”¹ï¼Œæˆæœ¬æœ€ä½ |

**ä¸¾ä¾‹ï¼š**
```
ä½ è¦å¤„ç†ä¸€ä»½1000é¡µçš„æ–‡æ¡£ï¼š

æ–¹æ¡ˆAï¼ˆstorageï¼‰ï¼šæ‰“å°å‡ºæ¥å­˜æ¡£æ¡ˆå®¤
- æ°¸ä¹…ä¿å­˜ âœ…
- æ‰“å°è´¹å¾ˆè´µ âŒ
- æ¯æ¬¡æŸ¥é˜…è¦å»æ¡£æ¡ˆå®¤ âŒ

æ–¹æ¡ˆBï¼ˆmemoryï¼‰ï¼šåœ¨ç”µè„‘ä¸Šæ‰“å¼€ç¼–è¾‘
- å¯ä»¥éšæ„ä¿®æ”¹ âœ…
- é€Ÿåº¦å¿« âœ…
- å…³æœºå°±æ²¡äº† âŒ

æ–¹æ¡ˆCï¼ˆcalldataï¼‰ï¼šåˆ«äººå‘ç»™ä½ çš„PDF
- æˆæœ¬æœ€ä½ âœ…
- ä¸èƒ½ä¿®æ”¹ âŒ
- é˜…åå³ç„š âŒ
```

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šlocalStorage vs å˜é‡ vs URLå‚æ•°

```javascript
// storage = localStorageï¼ˆæ°¸ä¹…å­˜å‚¨ï¼‰
localStorage.setItem('user', JSON.stringify(userData));
// å…³é—­æµè§ˆå™¨åæ•°æ®è¿˜åœ¨ï¼Œä½†è¯»å†™æ…¢

// memory = æ™®é€šå˜é‡ï¼ˆä¸´æ—¶ï¼‰
let tempData = processInput(input);
// å‡½æ•°æ‰§è¡Œå®Œå°±æ²¡äº†ï¼Œä½†æ“ä½œå¿«

// calldata = URLå‚æ•°ï¼ˆåªè¯»ï¼‰
const params = new URLSearchParams(window.location.search);
const id = params.get('id');  // åªèƒ½è¯»ï¼Œä¸èƒ½æ”¹URL
```

**å¯¹åº”Solidityï¼š**

```solidity
contract DataLocationAnalogy {
    // storage = æŒä¹…åŒ–åˆ°åŒºå—é“¾ï¼ˆåƒlocalStorageï¼‰
    uint256[] public persistentData;
    
    function processData(
        uint256[] calldata input  // calldata = åªè¯»è¾“å…¥ï¼ˆåƒURLå‚æ•°ï¼‰
    ) external {
        // memory = ä¸´æ—¶å˜é‡ï¼ˆåƒJSæ™®é€šå˜é‡ï¼‰
        uint256[] memory temp = new uint256[](input.length);
        
        for (uint i = 0; i < input.length; i++) {
            temp[i] = input[i] * 2;
        }
        
        // å†™å…¥storageï¼ˆæŒä¹…åŒ–ï¼‰
        persistentData = temp;
    }
}
```

---

### ç±»æ¯”æ€»ç»“è¡¨

| Solidityæ¦‚å¿µ | ç”Ÿæ´»åœºæ™¯ç±»æ¯” | å‰ç«¯é¢†åŸŸç±»æ¯” | æ ¸å¿ƒç›¸ä¼¼æ€§ |
|-------------|-------------|-------------|-----------|
| **å€¼ç±»å‹** | å¤å°æ–‡ä»¶ | JSåŸºæœ¬ç±»å‹(number/boolean) | èµ‹å€¼=å¤åˆ¶æ•°æ® |
| **å¼•ç”¨ç±»å‹** | å…±äº«æ–‡ä»¶å¤¹ | JSå¯¹è±¡/æ•°ç»„ | èµ‹å€¼=å¤åˆ¶å¼•ç”¨ |
| **storage** | ç¡¬ç›˜/æ¡£æ¡ˆå®¤ | localStorage | æ°¸ä¹…å­˜å‚¨ï¼Œæˆæœ¬é«˜ |
| **memory** | å†…å­˜/è‰ç¨¿çº¸ | æ™®é€šå˜é‡ | ä¸´æ—¶ä½¿ç”¨ï¼Œé€Ÿåº¦å¿« |
| **calldata** | åªè¯»å…‰ç›˜ | URLå‚æ•° | åªè¯»ï¼Œæˆæœ¬æœ€ä½ |
| **storageå¼•ç”¨** | å¤šäººç¼–è¾‘åŒä¸€æ–‡æ¡£ | å¯¹è±¡å¼•ç”¨ | ä¿®æ”¹å½±å“åŸæ•°æ® |
| **memoryå¤åˆ¶** | å¤å°ä¸€ä»½æ–‡æ¡£ | Object.assign/å±•å¼€è¿ç®—ç¬¦ | ä¿®æ”¹ä¸å½±å“åŸæ•°æ® |

---

## 6. ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼šSolidityçš„stringæ˜¯å€¼ç±»å‹ï¼ˆåƒJavaScriptä¸€æ ·ï¼‰âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

- åœ¨JavaScriptä¸­ï¼Œ`string`æ˜¯åŸºæœ¬ç±»å‹ï¼ˆä¸å¯å˜ï¼‰
- åœ¨Solidityä¸­ï¼Œ`string`æ˜¯**å¼•ç”¨ç±»å‹**ï¼éœ€è¦æŒ‡å®šæ•°æ®ä½ç½®

```solidity
// âŒ é”™è¯¯ï¼šä»¥ä¸ºstringåƒJSä¸€æ ·æ˜¯å€¼ç±»å‹
function wrong() public {
    string name = "Alice";  // ç¼–è¯‘é”™è¯¯ï¼ç¼ºå°‘æ•°æ®ä½ç½®
}

// âœ… æ­£ç¡®ï¼šstringæ˜¯å¼•ç”¨ç±»å‹ï¼Œéœ€è¦æŒ‡å®šä½ç½®
function correct() public pure {
    string memory name = "Alice";  // memoryä½ç½®
}

// âœ… çŠ¶æ€å˜é‡é»˜è®¤storage
string public name = "Alice";  // OKï¼Œé»˜è®¤storage
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å› ä¸ºåœ¨JavaScript/Pythonç­‰è¯­è¨€ä¸­ï¼Œå­—ç¬¦ä¸²æ˜¯ä¸å¯å˜çš„åŸºæœ¬ç±»å‹ã€‚ä½†Solidityçš„è®¾è®¡æ›´æ¥è¿‘C/C++ï¼ŒæŠŠå¯å˜é•¿åº¦æ•°æ®éƒ½å½“ä½œå¼•ç”¨ç±»å‹å¤„ç†ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```solidity
// Solidityä¸­stringæ˜¯åŠ¨æ€é•¿åº¦çš„å­—èŠ‚æ•°ç»„
// ç­‰ä»·äº bytesï¼ˆåŠ¨æ€å­—èŠ‚æ•°ç»„ï¼‰
string memory s = "Hello";
bytes memory b = bytes(s);  // å¯ä»¥äº’ç›¸è½¬æ¢

// å› ä¸ºé•¿åº¦ä¸å›ºå®šï¼Œæ‰€ä»¥æ˜¯å¼•ç”¨ç±»å‹
// éœ€è¦åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†é…å†…å­˜
```

---

### è¯¯åŒº2ï¼šmemoryæ•°ç»„èµ‹å€¼ä¼šåˆ›å»ºå‰¯æœ¬ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

åœ¨memoryå†…éƒ¨ï¼Œæ•°ç»„èµ‹å€¼æ˜¯**å¤åˆ¶å¼•ç”¨**ï¼Œä¸æ˜¯å¤åˆ¶æ•°æ®ï¼

```solidity
// âŒ é”™è¯¯è®¤çŸ¥ï¼šä»¥ä¸ºmemoryèµ‹å€¼ä¼šå¤åˆ¶æ•°ç»„
function wrong() public pure {
    uint256[] memory arr1 = new uint256[](3);
    arr1[0] = 100;
    
    uint256[] memory arr2 = arr1;  // è¿™ä¸æ˜¯å¤åˆ¶ï¼æ˜¯å¼•ç”¨ï¼
    arr2[0] = 999;
    
    // arr1[0]ç°åœ¨ä¹Ÿæ˜¯999ï¼
}

// âœ… æ­£ç¡®ï¼šæ˜ç¡®çŸ¥é“è¿™æ˜¯å¼•ç”¨
function correct() public pure returns (uint256, uint256) {
    uint256[] memory arr1 = new uint256[](3);
    arr1[0] = 100;
    
    uint256[] memory arr2 = arr1;  // arr2å’Œarr1æ˜¯åŒä¸€ä¸ªæ•°ç»„
    arr2[0] = 999;
    
    return (arr1[0], arr2[0]);  // éƒ½æ˜¯999
}
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å› ä¸º"storage â†’ memory"ç¡®å®æ˜¯å¤åˆ¶æ•°æ®ï¼Œäººä»¬ä»¥ä¸º"memory â†’ memory"ä¹Ÿæ˜¯å¤åˆ¶ã€‚ä½†å®é™…ä¸Šï¼š

- **è·¨ä½ç½®èµ‹å€¼**ï¼ˆstorage â†” memoryï¼‰ï¼šå¤åˆ¶æ•°æ®
- **åŒä½ç½®èµ‹å€¼**ï¼ˆmemory â†’ memory, storage â†’ storageï¼‰ï¼šå¤åˆ¶å¼•ç”¨

**æ­£ç¡®ç†è§£ï¼š**

```solidity
// èµ‹å€¼è§„åˆ™æ€»ç»“
function assignmentRules() public {
    uint256[] storage s1 = stateArray;
    uint256[] storage s2 = s1;        // storage â†’ storageï¼šå¼•ç”¨
    
    uint256[] memory m1 = stateArray; // storage â†’ memoryï¼šå¤åˆ¶
    uint256[] memory m2 = m1;         // memory â†’ memoryï¼šå¼•ç”¨ï¼
    
    stateArray = m1;                  // memory â†’ storageï¼šå¤åˆ¶
}
```

---

### è¯¯åŒº3ï¼šå›ºå®šå¤§å°æ•°ç»„æ˜¯å€¼ç±»å‹ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

å¾ˆå¤šäººè®¤ä¸º`uint256[10]`æ˜¯å›ºå®šå¤§å°çš„ï¼Œåº”è¯¥æ˜¯å€¼ç±»å‹ã€‚ä½†åœ¨Solidityä¸­ï¼Œ**æ‰€æœ‰æ•°ç»„éƒ½æ˜¯å¼•ç”¨ç±»å‹**ï¼

```solidity
// âŒ é”™è¯¯è®¤çŸ¥ï¼šä»¥ä¸ºå›ºå®šæ•°ç»„æ˜¯å€¼ç±»å‹
function wrong() public pure {
    uint256[3] memory arr1 = [uint256(1), 2, 3];
    uint256[3] memory arr2 = arr1;  // è¿™æ˜¯å¼•ç”¨ï¼ä¸æ˜¯å¤åˆ¶ï¼
    arr2[0] = 999;
    // arr1[0]ä¹Ÿæ˜¯999ï¼
}

// âœ… æ­£ç¡®ç†è§£ï¼šå›ºå®šæ•°ç»„ä¹Ÿæ˜¯å¼•ç”¨ç±»å‹
function correct() public pure returns (uint256) {
    uint256[3] memory arr1 = [uint256(1), 2, 3];
    uint256[3] memory arr2 = arr1;  // å¼•ç”¨åŒä¸€ä¸ªæ•°ç»„
    arr2[0] = 999;
    return arr1[0];  // è¿”å›999
}
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å› ä¸ºåœ¨Cè¯­è¨€ä¸­ï¼Œæ•°ç»„ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’æ—¶é€€åŒ–ä¸ºæŒ‡é’ˆï¼Œä½†æ•°ç»„èµ‹å€¼æ˜¯é€å…ƒç´ å¤åˆ¶ã€‚Solidityçš„è®¾è®¡ä¸åŒï¼Œæ‰€æœ‰æ•°ç»„ï¼ˆæ— è®ºå›ºå®šè¿˜æ˜¯åŠ¨æ€ï¼‰éƒ½æ˜¯å¼•ç”¨ç±»å‹ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```solidity
// å€¼ç±»å‹çš„å®Œæ•´åˆ—è¡¨ï¼ˆè®°ä½è¿™äº›å°±å¤Ÿäº†ï¼‰
// bool, uint/int, address, bytes1-bytes32, enum
// å…¶ä»–éƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼

// å›ºå®šæ•°ç»„è™½ç„¶å¤§å°å›ºå®šï¼Œä½†ä»æ˜¯å¼•ç”¨ç±»å‹
uint256[3] memory a;
uint256[3] memory b = a;  // bæ˜¯açš„å¼•ç”¨

// å¦‚æœéœ€è¦çœŸæ­£å¤åˆ¶å›ºå®šæ•°ç»„ï¼Œè¦æ‰‹åŠ¨å¤åˆ¶
function copyFixedArray(uint256[3] memory src) public pure returns (uint256[3] memory) {
    uint256[3] memory dest;
    for (uint i = 0; i < 3; i++) {
        dest[i] = src[i];
    }
    return dest;
}
```

---

## 7. ã€å®æˆ˜ä»£ç ã€‘

### åŸºç¡€å®ç°ï¼šå€¼ç±»å‹ä¸å¼•ç”¨ç±»å‹æ¼”ç¤º

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ValueVsReference
 * @notice æ¼”ç¤ºSolidityä¸­å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹çš„åŒºåˆ«
 */
contract ValueVsReference {
    // ===== çŠ¶æ€å˜é‡ï¼ˆstorageï¼‰=====
    uint256 public valueTypeState = 100;
    uint256[] public referenceTypeState;
    
    struct User {
        string name;
        uint256 balance;
    }
    User public user;
    
    // ===== 1. å€¼ç±»å‹æ¼”ç¤º =====
    function valueTypeDemo() public pure returns (
        uint256 original,
        uint256 copy,
        string memory explanation
    ) {
        uint256 a = 100;
        uint256 b = a;  // å¤åˆ¶å€¼
        b = 200;        // ä¿®æ”¹bä¸å½±å“a
        
        return (a, b, "Value types: b=a copies the value, modifying b doesn't affect a");
        // è¿”å›: (100, 200, "...")
    }
    
    // ===== 2. å¼•ç”¨ç±»å‹æ¼”ç¤ºï¼ˆmemoryå†…å¼•ç”¨ï¼‰=====
    function referenceTypeMemory() public pure returns (
        uint256 arr1First,
        uint256 arr2First,
        string memory explanation
    ) {
        uint256[] memory arr1 = new uint256[](3);
        arr1[0] = 100;
        
        uint256[] memory arr2 = arr1;  // å¤åˆ¶å¼•ç”¨ï¼ˆä¸æ˜¯å¤åˆ¶æ•°ç»„ï¼ï¼‰
        arr2[0] = 999;                 // ä¿®æ”¹arr2ä¹Ÿä¼šä¿®æ”¹arr1
        
        return (arr1[0], arr2[0], "Reference types in memory: arr2=arr1 copies the reference");
        // è¿”å›: (999, 999, "...")
    }
    
    // ===== 3. storageå¼•ç”¨æ¼”ç¤º =====
    function storageReferenceDemo() public returns (
        uint256 stateBefore,
        uint256 stateAfter
    ) {
        // å…ˆåˆå§‹åŒ–çŠ¶æ€
        if (referenceTypeState.length == 0) {
            referenceTypeState.push(100);
        }
        stateBefore = referenceTypeState[0];
        
        // storageå¼•ç”¨ï¼šç›´æ¥æŒ‡å‘çŠ¶æ€å˜é‡
        uint256[] storage arr = referenceTypeState;
        arr[0] = 999;  // ä¿®æ”¹arrå°±æ˜¯ä¿®æ”¹referenceTypeStateï¼
        
        stateAfter = referenceTypeState[0];
        return (stateBefore, stateAfter);
        // è¿”å›: (100, 999)
    }
    
    // ===== 4. storage â†’ memory å¤åˆ¶æ¼”ç¤º =====
    function storageTomemoryDemo() public returns (
        uint256 stateValue,
        uint256 memoryValue
    ) {
        // ç¡®ä¿çŠ¶æ€æœ‰æ•°æ®
        if (referenceTypeState.length == 0) {
            referenceTypeState.push(500);
        }
        
        // storage â†’ memoryï¼šå¤åˆ¶æ•°æ®
        uint256[] memory arr = referenceTypeState;
        arr[0] = 888;  // ä¿®æ”¹memoryå‰¯æœ¬ï¼Œä¸å½±å“storage
        
        return (referenceTypeState[0], arr[0]);
        // è¿”å›: (500æˆ–999, 888)
    }
    
    // ===== 5. Structå¼•ç”¨æ¼”ç¤º =====
    function structReferenceDemo() public returns (
        string memory nameBefore,
        string memory nameAfter
    ) {
        // åˆå§‹åŒ–
        user = User("Alice", 1000);
        nameBefore = user.name;
        
        // storageå¼•ç”¨ï¼šç›´æ¥ä¿®æ”¹çŠ¶æ€
        User storage u = user;
        u.name = "Bob";
        
        nameAfter = user.name;
        return (nameBefore, nameAfter);
        // è¿”å›: ("Alice", "Bob")
    }
    
    // ===== 6. å‡½æ•°å‚æ•°çš„æ•°æ®ä½ç½® =====
    
    // calldataï¼šåªè¯»ï¼Œæœ€çœGas
    function processCalldata(uint256[] calldata arr) external pure returns (uint256) {
        // arr[0] = 100;  // âŒ ç¼–è¯‘é”™è¯¯ï¼šcalldataæ˜¯åªè¯»çš„
        return arr[0];
    }
    
    // memoryï¼šå¯ä¿®æ”¹çš„å‰¯æœ¬
    function processMemory(uint256[] memory arr) public pure returns (uint256) {
        arr[0] = 999;  // âœ… å¯ä»¥ä¿®æ”¹ï¼Œä½†ä¸å½±å“è°ƒç”¨è€…çš„æ•°ç»„
        return arr[0];
    }
    
    // ===== 7. Gaså¯¹æ¯”å®éªŒ =====
    uint256[] public largeArray;
    
    function initLargeArray(uint256 size) public {
        delete largeArray;
        for (uint256 i = 0; i < size; i++) {
            largeArray.push(i);
        }
    }
    
    // ä½æ•ˆï¼šç›´æ¥æ“ä½œstorage
    function sumInefficient() public view returns (uint256) {
        uint256 sum = 0;
        for (uint256 i = 0; i < largeArray.length; i++) {
            sum += largeArray[i];  // æ¯æ¬¡éƒ½è¯»storageï¼ˆæ˜‚è´µï¼ï¼‰
        }
        return sum;
    }
    
    // é«˜æ•ˆï¼šå…ˆå¤åˆ¶åˆ°memory
    function sumEfficient() public view returns (uint256) {
        uint256[] memory arr = largeArray;  // ä¸€æ¬¡æ€§å¤åˆ¶
        uint256 sum = 0;
        for (uint256 i = 0; i < arr.length; i++) {
            sum += arr[i];  // è¯»memoryï¼ˆä¾¿å®œï¼ï¼‰
        }
        return sum;
    }
}
```

**åœ¨Remixä¸­æµ‹è¯•ï¼š**

1. éƒ¨ç½²åˆçº¦
2. è°ƒç”¨ `valueTypeDemo()` - è§‚å¯Ÿå€¼ç±»å‹å¤åˆ¶è¡Œä¸º
3. è°ƒç”¨ `referenceTypeMemory()` - è§‚å¯Ÿmemoryå†…å¼•ç”¨è¡Œä¸º
4. è°ƒç”¨ `storageReferenceDemo()` - è§‚å¯Ÿstorageå¼•ç”¨è¡Œä¸º
5. è°ƒç”¨ `initLargeArray(100)` ç„¶åå¯¹æ¯” `sumInefficient()` å’Œ `sumEfficient()` çš„Gasæ¶ˆè€—

---

### è¿›é˜¶ï¼šå®é™…DAppä¸­çš„åº”ç”¨ï¼ˆERC20ä»£å¸åˆçº¦ç‰‡æ®µï¼‰

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SimpleToken
 * @notice æ¼”ç¤ºå€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹åœ¨çœŸå®ä»£å¸åˆçº¦ä¸­çš„åº”ç”¨
 */
contract SimpleToken {
    // ===== å€¼ç±»å‹çŠ¶æ€å˜é‡ =====
    string public name = "Simple Token";
    string public symbol = "STK";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    
    // ===== å¼•ç”¨ç±»å‹çŠ¶æ€å˜é‡ =====
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    // ===== äº‹ä»¶ =====
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** decimals;
        balanceOf[msg.sender] = totalSupply;
    }
    
    /**
     * @notice è½¬è´¦å‡½æ•° - æ¼”ç¤ºå€¼ç±»å‹å‚æ•°
     * @param to æ¥æ”¶åœ°å€ï¼ˆå€¼ç±»å‹ï¼šaddressï¼‰
     * @param amount è½¬è´¦é‡‘é¢ï¼ˆå€¼ç±»å‹ï¼šuint256ï¼‰
     */
    function transfer(address to, uint256 amount) public returns (bool) {
        // å€¼ç±»å‹å‚æ•°ï¼štoå’Œamountæ˜¯è°ƒç”¨è€…ä¼ å…¥å€¼çš„å‰¯æœ¬
        // ä¿®æ”¹å®ƒä»¬ä¸ä¼šå½±å“è°ƒç”¨è€…
        
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        
        // mappingçš„å€¼æ˜¯uint256ï¼ˆå€¼ç±»å‹ï¼‰ï¼Œç›´æ¥æ“ä½œ
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    /**
     * @notice æ‰¹é‡è½¬è´¦ - æ¼”ç¤ºå¼•ç”¨ç±»å‹å‚æ•°
     * @param recipients æ¥æ”¶åœ°å€æ•°ç»„ï¼ˆå¼•ç”¨ç±»å‹ï¼‰
     * @param amounts é‡‘é¢æ•°ç»„ï¼ˆå¼•ç”¨ç±»å‹ï¼‰
     */
    function batchTransfer(
        address[] calldata recipients,  // calldataï¼šåªè¯»ï¼Œæœ€çœGas
        uint256[] calldata amounts
    ) external returns (bool) {
        require(recipients.length == amounts.length, "Array length mismatch");
        
        // ä½¿ç”¨calldataç›´æ¥è¯»å–ï¼Œä¸éœ€è¦å¤åˆ¶åˆ°memory
        for (uint256 i = 0; i < recipients.length; i++) {
            transfer(recipients[i], amounts[i]);
        }
        
        return true;
    }
    
    /**
     * @notice è·å–å¤šä¸ªåœ°å€çš„ä½™é¢ - æ¼”ç¤ºè¿”å›å¼•ç”¨ç±»å‹
     * @param accounts æŸ¥è¯¢åœ°å€æ•°ç»„
     * @return balances ä½™é¢æ•°ç»„ï¼ˆmemoryï¼‰
     */
    function getBalances(
        address[] calldata accounts
    ) external view returns (uint256[] memory balances) {
        // åˆ›å»ºmemoryæ•°ç»„æ¥å­˜å‚¨ç»“æœ
        balances = new uint256[](accounts.length);
        
        for (uint256 i = 0; i < accounts.length; i++) {
            balances[i] = balanceOf[accounts[i]];
        }
        
        return balances;
    }
}
```

---

### JavaScript/ethers.js äº¤äº’ç¤ºä¾‹

```javascript
const { ethers } = require('ethers');

// åˆçº¦ABIï¼ˆç®€åŒ–ç‰ˆï¼‰
const abi = [
    "function transfer(address to, uint256 amount) returns (bool)",
    "function batchTransfer(address[] recipients, uint256[] amounts) returns (bool)",
    "function getBalances(address[] accounts) view returns (uint256[])",
    "function balanceOf(address) view returns (uint256)"
];

async function demonstrateTypes() {
    // è¿æ¥æä¾›è€…
    const provider = new ethers.JsonRpcProvider('http://localhost:8545');
    const signer = await provider.getSigner();
    
    // åˆçº¦å®ä¾‹
    const tokenAddress = "0x..."; // éƒ¨ç½²åçš„åœ°å€
    const token = new ethers.Contract(tokenAddress, abi, signer);
    
    // ===== 1. å€¼ç±»å‹å‚æ•°ï¼šå•ä¸ªè½¬è´¦ =====
    console.log("=== å€¼ç±»å‹å‚æ•°æ¼”ç¤º ===");
    const tx1 = await token.transfer(
        "0xRecipient...",           // addressï¼ˆå€¼ç±»å‹ï¼‰
        ethers.parseEther("100")    // uint256ï¼ˆå€¼ç±»å‹ï¼‰
    );
    await tx1.wait();
    console.log("å•ç¬”è½¬è´¦å®Œæˆ");
    
    // ===== 2. å¼•ç”¨ç±»å‹å‚æ•°ï¼šæ‰¹é‡è½¬è´¦ =====
    console.log("\n=== å¼•ç”¨ç±»å‹å‚æ•°æ¼”ç¤º ===");
    const recipients = [
        "0xAddr1...",
        "0xAddr2...",
        "0xAddr3..."
    ];
    const amounts = [
        ethers.parseEther("10"),
        ethers.parseEther("20"),
        ethers.parseEther("30")
    ];
    
    // æ•°ç»„ä¼šè¢«ç¼–ç ä¸ºcalldataä¼ é€’ç»™åˆçº¦
    const tx2 = await token.batchTransfer(recipients, amounts);
    await tx2.wait();
    console.log("æ‰¹é‡è½¬è´¦å®Œæˆ");
    
    // ===== 3. å¼•ç”¨ç±»å‹è¿”å›å€¼ =====
    console.log("\n=== å¼•ç”¨ç±»å‹è¿”å›å€¼æ¼”ç¤º ===");
    const balances = await token.getBalances(recipients);
    
    // balancesæ˜¯ä¸€ä¸ªæ•°ç»„
    recipients.forEach((addr, i) => {
        console.log(`${addr}: ${ethers.formatEther(balances[i])} tokens`);
    });
}

demonstrateTypes().catch(console.error);
```

**è¿è¡Œè¾“å‡ºç¤ºä¾‹ï¼š**

```
=== å€¼ç±»å‹å‚æ•°æ¼”ç¤º ===
å•ç¬”è½¬è´¦å®Œæˆ

=== å¼•ç”¨ç±»å‹å‚æ•°æ¼”ç¤º ===
æ‰¹é‡è½¬è´¦å®Œæˆ

=== å¼•ç”¨ç±»å‹è¿”å›å€¼æ¼”ç¤º ===
0xAddr1...: 10.0 tokens
0xAddr2...: 20.0 tokens
0xAddr3...: 30.0 tokens
```

---

## 8. ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜1ï¼š"Solidityä¸­å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"å€¼ç±»å‹èµ‹å€¼æ—¶å¤åˆ¶æ•°æ®ï¼Œå¼•ç”¨ç±»å‹èµ‹å€¼æ—¶å¤åˆ¶å¼•ç”¨ã€‚å€¼ç±»å‹åŒ…æ‹¬uintã€boolã€addressï¼Œå¼•ç”¨ç±»å‹åŒ…æ‹¬æ•°ç»„ã€mappingã€structã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹çš„åŒºåˆ«å¯ä»¥ä»ä¸‰ä¸ªç»´åº¦ç†è§£ï¼š**
>
> **1. èµ‹å€¼è¯­ä¹‰**ï¼š
> - å€¼ç±»å‹ï¼ˆuintã€boolã€addressã€bytes1-32ã€enumï¼‰èµ‹å€¼æ—¶å¤åˆ¶æ•°æ®æœ¬èº«ï¼Œä¿®æ”¹å‰¯æœ¬ä¸å½±å“åŸå€¼
> - å¼•ç”¨ç±»å‹ï¼ˆæ•°ç»„ã€mappingã€structã€stringã€bytesï¼‰èµ‹å€¼æ—¶å¤åˆ¶å¼•ç”¨ï¼Œä½†å…·ä½“è¡Œä¸ºå–å†³äºæ•°æ®ä½ç½®
>
> **2. æ•°æ®ä½ç½®çš„å½±å“**ï¼š
> - å¼•ç”¨ç±»å‹å¿…é¡»æŒ‡å®šæ•°æ®ä½ç½®ï¼ˆstorage/memory/calldataï¼‰
> - **è·¨ä½ç½®èµ‹å€¼**ï¼ˆstorage â†” memoryï¼‰ä¼šå¤åˆ¶æ•°æ®
> - **åŒä½ç½®èµ‹å€¼**ï¼ˆmemory â†’ memoryï¼‰åªå¤åˆ¶å¼•ç”¨
> - è¿™æ˜¯å¾ˆå¤šBugçš„æ¥æºï¼Œæ¯”å¦‚è¯¯ä»¥ä¸ºmemoryèµ‹å€¼ä¼šå¤åˆ¶æ•°ç»„
>
> **3. Gasæˆæœ¬è€ƒé‡**ï¼š
> - å€¼ç±»å‹å¤åˆ¶æˆæœ¬å›ºå®šï¼ˆçº¦3 Gasï¼‰
> - å¼•ç”¨ç±»å‹å¤åˆ¶æˆæœ¬ä¸æ•°æ®å¤§å°æˆæ­£æ¯”
> - æœ€ä½³å®è·µï¼šå‡½æ•°å‚æ•°ç”¨calldataï¼ˆåªè¯»æœ€çœï¼‰ï¼Œä¸´æ—¶å˜é‡ç”¨memoryï¼Œéœ€è¦æŒä¹…åŒ–ç”¨storage
>
> **å®é™…ä¾‹å­**ï¼š
> ```solidity
> uint256[] memory arr1 = new uint256[](3);
> uint256[] memory arr2 = arr1;  // è¿™æ˜¯å¼•ç”¨ï¼
> arr2[0] = 999;                 // arr1[0]ä¹Ÿå˜æˆ999
> ```
>
> **åœ¨å®é™…å¼€å‘ä¸­**ï¼šæˆ‘ä¼šç‰¹åˆ«æ³¨æ„å¾ªç¯ä¸­æ“ä½œstorageçš„åœºæ™¯ï¼Œé€šå¸¸å…ˆå¤åˆ¶åˆ°memoryå¤„ç†ï¼Œå†ä¸€æ¬¡æ€§å†™å›storageï¼Œå¯ä»¥æ˜¾è‘—èŠ‚çœGasã€‚

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… åˆ†ç»´åº¦è§£é‡Šï¼ˆèµ‹å€¼è¯­ä¹‰ã€æ•°æ®ä½ç½®ã€Gasæˆæœ¬ï¼‰
2. âœ… æŒ‡å‡ºäº†å¸¸è§Bugæ¥æºï¼ˆmemory â†’ memoryæ˜¯å¼•ç”¨ï¼‰
3. âœ… æä¾›äº†å…·ä½“ä»£ç ç¤ºä¾‹
4. âœ… è”ç³»åˆ°Gasä¼˜åŒ–å®è·µ

---

### é—®é¢˜2ï¼š"ä»€ä¹ˆæ—¶å€™ç”¨storageã€memoryã€calldataï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"storageæ˜¯æ°¸ä¹…å­˜å‚¨ï¼Œmemoryæ˜¯ä¸´æ—¶çš„ï¼Œcalldataæ˜¯åªè¯»çš„å‡½æ•°å‚æ•°ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **é€‰æ‹©æ•°æ®ä½ç½®çš„æ ¸å¿ƒåŸåˆ™æ˜¯ï¼šæœ€å°åŒ–Gasæ¶ˆè€— + æ»¡è¶³åŠŸèƒ½éœ€æ±‚ã€‚**
>
> **1. calldata**ï¼ˆé¦–é€‰ï¼Œå½“å‚æ•°åªè¯»æ—¶ï¼‰ï¼š
> - ç”¨äºexternalå‡½æ•°çš„å¼•ç”¨ç±»å‹å‚æ•°
> - åªè¯»ï¼Œä¸èƒ½ä¿®æ”¹
> - Gasæˆæœ¬æœ€ä½ï¼Œå› ä¸ºæ•°æ®ç›´æ¥ä»äº¤æ˜“æ•°æ®è¯»å–ï¼Œä¸éœ€è¦å¤åˆ¶
> - ä¾‹ï¼š`function foo(uint256[] calldata arr) external`
>
> **2. memory**ï¼ˆä¸´æ—¶å¤„ç†ï¼‰ï¼š
> - ç”¨äºå‡½æ•°å†…éƒ¨çš„ä¸´æ—¶å˜é‡
> - å¯è¯»å†™ï¼Œä½†å‡½æ•°ç»“æŸåé”€æ¯
> - é€‚åˆéœ€è¦ä¿®æ”¹å‚æ•°çš„åœºæ™¯ï¼ˆpublic/internalå‡½æ•°ï¼‰
> - ä¾‹ï¼š`function bar(uint256[] memory arr) public`
>
> **3. storage**ï¼ˆæŒä¹…åŒ–æˆ–å¼•ç”¨çŠ¶æ€ï¼‰ï¼š
> - çŠ¶æ€å˜é‡é»˜è®¤æ˜¯storage
> - å‡½æ•°å†…ç”¨storageå…³é”®å­—åˆ›å»ºå¯¹çŠ¶æ€å˜é‡çš„å¼•ç”¨
> - ä¿®æ”¹storageå¼•ç”¨ä¼šç›´æ¥ä¿®æ”¹çŠ¶æ€å˜é‡
> - ä¾‹ï¼š`uint256[] storage arr = stateArray;`
>
> **å®é™…ä¼˜åŒ–æ¡ˆä¾‹**ï¼š
> ```solidity
> // âŒ ä½æ•ˆï¼šæ¯æ¬¡å¾ªç¯éƒ½è¯»storage
> for (uint i = 0; i < stateArray.length; i++) {
>     sum += stateArray[i];  // SLOADæ“ä½œï¼Œæ¯æ¬¡~100 Gas
> }
>
> // âœ… é«˜æ•ˆï¼šå…ˆå¤åˆ¶åˆ°memory
> uint256[] memory arr = stateArray;
> for (uint i = 0; i < arr.length; i++) {
>     sum += arr[i];  // è¯»memoryï¼Œæ¯æ¬¡~3 Gas
> }
> ```
>
> **å†³ç­–æ ‘**ï¼š
> 1. å‚æ•°åªè¯»ï¼Ÿâ†’ calldata
> 2. éœ€è¦ä¿®æ”¹å‚æ•°ä½†ä¸æŒä¹…åŒ–ï¼Ÿâ†’ memory
> 3. éœ€è¦ä¿®æ”¹çŠ¶æ€å˜é‡ï¼Ÿâ†’ storageå¼•ç”¨

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… ç»™å‡ºäº†æ¸…æ™°çš„é€‰æ‹©åŸåˆ™
2. âœ… æ¯ç§ä½ç½®éƒ½æœ‰å…·ä½“ä½¿ç”¨åœºæ™¯
3. âœ… æä¾›äº†Gasä¼˜åŒ–çš„å®é™…ä»£ç å¯¹æ¯”
4. âœ… ç»™å‡ºäº†å†³ç­–æ ‘å¸®åŠ©å¿«é€Ÿé€‰æ‹©

---

## 9. ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼šç›´è§‰ç†è§£ - ä»€ä¹ˆæ˜¯å€¼ç±»å‹ï¼Ÿ ğŸ¯

**ä¸€å¥è¯ï¼š** å€¼ç±»å‹å˜é‡ç›´æ¥å­˜å‚¨æ•°æ®ï¼Œèµ‹å€¼æ—¶å¤åˆ¶æ•°æ®æœ¬èº«ï¼Œä¿®æ”¹å‰¯æœ¬ä¸å½±å“åŸå€¼ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
uint256 a = 100;
uint256 b = a;  // å¤åˆ¶å€¼
b = 200;
// aè¿˜æ˜¯100ï¼Œbæ˜¯200
```

**åº”ç”¨ï¼š** uintã€boolã€addressã€bytes1-32ã€enuméƒ½æ˜¯å€¼ç±»å‹ï¼Œé€‚åˆå­˜å‚¨å›ºå®šå¤§å°çš„ç®€å•æ•°æ®ã€‚

---

### å¡ç‰‡2ï¼šç›´è§‰ç†è§£ - ä»€ä¹ˆæ˜¯å¼•ç”¨ç±»å‹ï¼Ÿ ğŸ“

**ä¸€å¥è¯ï¼š** å¼•ç”¨ç±»å‹å˜é‡å­˜å‚¨æ•°æ®çš„å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰ï¼Œèµ‹å€¼è¡Œä¸ºå–å†³äºæ•°æ®ä½ç½®ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
uint256[] memory arr1 = new uint256[](3);
uint256[] memory arr2 = arr1;  // å¤åˆ¶å¼•ç”¨ï¼
arr2[0] = 999;
// arr1[0]ä¹Ÿæ˜¯999ï¼
```

**åº”ç”¨ï¼š** æ•°ç»„ã€mappingã€structã€stringã€byteséƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œéœ€è¦æŒ‡å®šæ•°æ®ä½ç½®ã€‚

---

### å¡ç‰‡3ï¼šå…³é”®æ¦‚å¿µ - storageä½ç½® ğŸ’¾

**ä¸€å¥è¯ï¼š** storageæ˜¯æ°¸ä¹…å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šçš„æ•°æ®ï¼ŒGasæˆæœ¬æœ€é«˜ï¼ŒçŠ¶æ€å˜é‡é»˜è®¤ä½¿ç”¨storageã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
uint256[] public stateArray;  // é»˜è®¤storage

function modify() public {
    uint256[] storage arr = stateArray;  // storageå¼•ç”¨
    arr[0] = 100;  // ç›´æ¥ä¿®æ”¹åŒºå—é“¾æ•°æ®ï¼
}
```

**åº”ç”¨ï¼š** éœ€è¦æ°¸ä¹…ä¿å­˜çš„æ•°æ®ç”¨storageï¼Œä½†è¦æ³¨æ„Gasæˆæœ¬ï¼ˆSSTOREçº¦20000 Gasï¼‰ã€‚

---

### å¡ç‰‡4ï¼šå…³é”®æ¦‚å¿µ - memoryä½ç½® ğŸ§ 

**ä¸€å¥è¯ï¼š** memoryæ˜¯å‡½æ•°æ‰§è¡ŒæœŸé—´çš„ä¸´æ—¶å†…å­˜ï¼ŒGasæˆæœ¬ä¸­ç­‰ï¼Œå‡½æ•°ç»“æŸåé”€æ¯ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
function process() public pure {
    uint256[] memory arr = new uint256[](10);
    arr[0] = 100;
    // å‡½æ•°ç»“æŸåarrè¢«é”€æ¯
}
```

**åº”ç”¨ï¼š** ä¸´æ—¶è®¡ç®—ã€å‡½æ•°è¿”å›å€¼ç”¨memoryï¼Œé¿å…ä¸å¿…è¦çš„storageå†™å…¥ã€‚

---

### å¡ç‰‡5ï¼šå…³é”®æ¦‚å¿µ - calldataä½ç½® ğŸ“¨

**ä¸€å¥è¯ï¼š** calldataæ˜¯åªè¯»çš„å‡½æ•°å‚æ•°ä½ç½®ï¼ŒGasæˆæœ¬æœ€ä½ï¼Œåªèƒ½ç”¨äºexternalå‡½æ•°å‚æ•°ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
function process(uint256[] calldata arr) external pure {
    // arr[0] = 100;  // âŒ ç¼–è¯‘é”™è¯¯ï¼šcalldataåªè¯»
    return arr[0];    // âœ… åªèƒ½è¯»å–
}
```

**åº”ç”¨ï¼š** externalå‡½æ•°çš„æ•°ç»„/å­—ç¬¦ä¸²å‚æ•°é¦–é€‰calldataï¼Œæœ€çœGasã€‚

---

### å¡ç‰‡6ï¼šèµ‹å€¼è§„åˆ™ - è·¨ä½ç½®èµ‹å€¼ ğŸ”„

**ä¸€å¥è¯ï¼š** storageå’Œmemoryä¹‹é—´èµ‹å€¼ä¼šå¤åˆ¶æ•°æ®ï¼Œè€Œä¸æ˜¯å¤åˆ¶å¼•ç”¨ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
uint256[] public stateArray = [1, 2, 3];

function copyDemo() public view {
    uint256[] memory arr = stateArray;  // storage â†’ memoryï¼šå¤åˆ¶ï¼
    arr[0] = 999;
    // stateArray[0]è¿˜æ˜¯1ï¼ˆä¸å—å½±å“ï¼‰
}
```

**åº”ç”¨ï¼š** éœ€è¦åœ¨memoryä¸­å¤„ç†storageæ•°æ®æ—¶ï¼Œä¼šè‡ªåŠ¨åˆ›å»ºå‰¯æœ¬ã€‚

---

### å¡ç‰‡7ï¼šèµ‹å€¼è§„åˆ™ - åŒä½ç½®èµ‹å€¼ ğŸ”—

**ä¸€å¥è¯ï¼š** åŒä¸€ä½ç½®ï¼ˆmemoryâ†’memoryæˆ–storageâ†’storageï¼‰ä¹‹é—´çš„èµ‹å€¼æ˜¯å¤åˆ¶å¼•ç”¨ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
function referenceDemo() public pure {
    uint256[] memory arr1 = new uint256[](3);
    uint256[] memory arr2 = arr1;  // memory â†’ memoryï¼šå¼•ç”¨ï¼
    arr2[0] = 999;
    // arr1[0]ä¹Ÿæ˜¯999
}
```

**åº”ç”¨ï¼š** è¿™æ˜¯å¸¸è§Bugæ¥æºï¼Œè¦ç‰¹åˆ«æ³¨æ„memoryæ•°ç»„èµ‹å€¼æ˜¯å¼•ç”¨è€Œéå¤åˆ¶ã€‚

---

### å¡ç‰‡8ï¼šGasä¼˜åŒ– - å¾ªç¯ä¸­çš„storageè®¿é—® â›½

**ä¸€å¥è¯ï¼š** å¾ªç¯ä¸­ç›´æ¥è®¿é—®storageéå¸¸æ˜‚è´µï¼Œåº”è¯¥å…ˆå¤åˆ¶åˆ°memoryå†å¤„ç†ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// âŒ æ¯æ¬¡å¾ªç¯è¯»storageï¼ˆ~100 Gas/æ¬¡ï¼‰
for (uint i = 0; i < stateArray.length; i++) {
    sum += stateArray[i];
}

// âœ… å…ˆå¤åˆ¶åˆ°memoryï¼ˆ~3 Gas/æ¬¡ï¼‰
uint256[] memory arr = stateArray;
for (uint i = 0; i < arr.length; i++) {
    sum += arr[i];
}
```

**åº”ç”¨ï¼š** å¤§æ•°ç»„å¤„ç†æ—¶ï¼Œè¿™ä¸ªä¼˜åŒ–å¯ä»¥èŠ‚çœæ•°å€Gasã€‚

---

### å¡ç‰‡9ï¼šå¸¸è§é™·é˜± - stringæ˜¯å¼•ç”¨ç±»å‹ âš ï¸

**ä¸€å¥è¯ï¼š** ä¸JavaScriptä¸åŒï¼ŒSolidityçš„stringæ˜¯å¼•ç”¨ç±»å‹ï¼Œéœ€è¦æŒ‡å®šæ•°æ®ä½ç½®ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// âŒ é”™è¯¯
function wrong() public {
    string name = "Alice";  // ç¼–è¯‘é”™è¯¯ï¼
}

// âœ… æ­£ç¡®
function correct() public pure {
    string memory name = "Alice";
}
```

**åº”ç”¨ï¼š** å‡½æ•°å‚æ•°å’Œè¿”å›å€¼ä¸­çš„stringéƒ½éœ€è¦æ˜¾å¼æŒ‡å®šmemoryæˆ–calldataã€‚

---

### å¡ç‰‡10ï¼šæ€»ç»“ä¸å»¶ä¼¸ ğŸ“

**ä¸€å¥è¯ï¼š** å€¼ç±»å‹é€‚åˆå°æ•°æ®é«˜æ•ˆå¤åˆ¶ï¼Œå¼•ç”¨ç±»å‹é€‚åˆå¤§æ•°æ®çµæ´»ç®¡ç†ï¼Œæ­£ç¡®é€‰æ‹©æ•°æ®ä½ç½®æ˜¯Gasä¼˜åŒ–çš„å…³é”®ã€‚

**æ ¸å¿ƒè¦ç‚¹ï¼š**
1. å€¼ç±»å‹ï¼šuintã€boolã€addressã€bytes1-32ã€enum
2. å¼•ç”¨ç±»å‹ï¼šæ•°ç»„ã€mappingã€structã€stringã€bytes
3. æ•°æ®ä½ç½®ï¼šstorageï¼ˆæ°¸ä¹…ï¼‰> memoryï¼ˆä¸´æ—¶ï¼‰> calldataï¼ˆåªè¯»ï¼‰
4. è·¨ä½ç½®èµ‹å€¼å¤åˆ¶æ•°æ®ï¼ŒåŒä½ç½®èµ‹å€¼å¤åˆ¶å¼•ç”¨

**ä¸‹ä¸€æ­¥å­¦ä¹ ï¼š**
- storageå¸ƒå±€ï¼šç†è§£å˜é‡åœ¨storageä¸­çš„æ’åˆ—æ–¹å¼
- æ‰“åŒ…ä¼˜åŒ–ï¼šå¦‚ä½•åˆ©ç”¨storage slotèŠ‚çœGas
- ä»£ç†åˆçº¦ï¼šstorageå¸ƒå±€åœ¨å‡çº§åˆçº¦ä¸­çš„é‡è¦æ€§

---

## 10. ã€ä¸€å¥è¯æ€»ç»“ã€‘

**Solidityä¸­å€¼ç±»å‹ï¼ˆuint/bool/address/bytes1-32/enumï¼‰èµ‹å€¼æ—¶å¤åˆ¶æ•°æ®ï¼Œå¼•ç”¨ç±»å‹ï¼ˆæ•°ç»„/mapping/struct/string/bytesï¼‰éœ€è¦æŒ‡å®šæ•°æ®ä½ç½®ï¼ˆstorageæ°¸ä¹…/memoryä¸´æ—¶/calldataåªè¯»ï¼‰ï¼Œç†è§£ä¸¤è€…çš„èµ‹å€¼è¯­ä¹‰å’ŒGasæˆæœ¬å·®å¼‚æ˜¯ç¼–å†™å®‰å…¨é«˜æ•ˆæ™ºèƒ½åˆçº¦çš„åŸºç¡€ã€‚**

---

## ğŸ“š é™„å½•

### å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆæœ¬çŸ¥è¯†ç‚¹å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] åˆ—å‡ºæ‰€æœ‰å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹
- [ ] è§£é‡Šstorageã€memoryã€calldataçš„åŒºåˆ«
- [ ] é¢„æµ‹èµ‹å€¼æ“ä½œæ˜¯å¤åˆ¶æ•°æ®è¿˜æ˜¯å¤åˆ¶å¼•ç”¨
- [ ] æ­£ç¡®é€‰æ‹©å‡½æ•°å‚æ•°çš„æ•°æ®ä½ç½®
- [ ] è¯†åˆ«å¾ªç¯ä¸­çš„storageè®¿é—®ä¼˜åŒ–æœºä¼š
- [ ] è§£é‡Šä¸ºä»€ä¹ˆSolidityçš„stringæ˜¯å¼•ç”¨ç±»å‹
- [ ] ç¼–å†™ä½¿ç”¨structå’Œæ•°ç»„çš„åˆçº¦
- [ ] é¿å…memoryæ•°ç»„èµ‹å€¼å¼•ç”¨çš„é™·é˜±

### å¿«é€Ÿå‚è€ƒå¡

**å€¼ç±»å‹åˆ—è¡¨ï¼š**
```
bool, uint8-uint256, int8-int256, address, bytes1-bytes32, enum
```

**å¼•ç”¨ç±»å‹åˆ—è¡¨ï¼š**
```
T[], T[n], mapping(K=>V), struct, string, bytes
```

**æ•°æ®ä½ç½®é€‰æ‹©ï¼š**
```
çŠ¶æ€å˜é‡ â†’ storageï¼ˆé»˜è®¤ï¼‰
externalå‚æ•° â†’ calldataï¼ˆé¦–é€‰ï¼‰
public/internalå‚æ•° â†’ memory
å‡½æ•°å†…ä¸´æ—¶å˜é‡ â†’ memory
éœ€è¦ä¿®æ”¹çŠ¶æ€ â†’ storageå¼•ç”¨
```

**èµ‹å€¼è§„åˆ™ï¼š**
```
storage â†’ storage = å¼•ç”¨
storage â†’ memory = å¤åˆ¶
memory â†’ memory = å¼•ç”¨
memory â†’ storage = å¤åˆ¶
calldata â†’ memory = å¤åˆ¶
```

### ä¸‹ä¸€æ­¥å­¦ä¹ 

æ¨èæŒ‰ä»¥ä¸‹é¡ºåºç»§ç»­å­¦ä¹ ï¼š

1. **storageå¸ƒå±€** - ç†è§£å˜é‡åœ¨åŒºå—é“¾ä¸Šçš„å­˜å‚¨æ–¹å¼
2. **å‡½æ•°å¯è§æ€§** - public/external/internal/privateçš„åŒºåˆ«
3. **modifier** - å‡½æ•°ä¿®é¥°å™¨å’Œæƒé™æ§åˆ¶

---

**ç‰ˆæœ¬ï¼š** v1.0
**åˆ›å»ºæ—¥æœŸï¼š** 2025-12-07
**é€‚ç”¨äººç¾¤ï¼š** å‰ç«¯å·¥ç¨‹å¸ˆè½¬Web3å¼€å‘
