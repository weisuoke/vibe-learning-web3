# å¦‚ä½•åœ¨æµ‹è¯•ä¸­è·å–ä¸åŒçš„ç­¾åè€… (Signer)?

## 1. ã€30å­—æ ¸å¿ƒã€‘

**`ethers.getSigners()` è¿”å› Hardhat é¢„ç½®çš„æµ‹è¯•è´¦æˆ·æ•°ç»„ï¼Œä½¿ç”¨ `contract.connect(signer)` åˆ‡æ¢è°ƒç”¨è€…èº«ä»½ï¼Œå®ç°å¤šç”¨æˆ·åœºæ™¯æµ‹è¯•ã€‚**

---

## 2. ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### Signer çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**Signer = èƒ½å¤Ÿç­¾åäº¤æ˜“çš„ä»¥å¤ªåŠè´¦æˆ·**

ä»…æ­¤è€Œå·²ï¼æ²¡æœ‰æ›´åŸºç¡€çš„äº†ã€‚

#### 2. ä¸ºä»€ä¹ˆéœ€è¦ä¸åŒçš„ Signerï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šå¦‚ä½•æµ‹è¯•å¤šç”¨æˆ·äº¤äº’åœºæ™¯ï¼Ÿ**

æ™ºèƒ½åˆçº¦çš„çœŸå®ä½¿ç”¨åœºæ™¯ï¼š
- **è§’è‰²æƒé™**ï¼šç®¡ç†å‘˜ã€æ™®é€šç”¨æˆ·ã€å®¡æ ¸å‘˜æœ‰ä¸åŒæƒé™
- **èµ„äº§è½¬ç§»**ï¼šA è½¬è´¦ç»™ Bï¼Œéœ€è¦ä¸¤ä¸ªè´¦æˆ·
- **å¤šæ–¹äº¤äº’**ï¼šä¹°å®¶ã€å–å®¶ã€å¹³å°ä¸‰æ–¹å‚ä¸
- **æƒé™æ§åˆ¶**ï¼šåªæœ‰ owner èƒ½è°ƒç”¨æŸäº›å‡½æ•°

å¦‚æœåªæœ‰ä¸€ä¸ªè´¦æˆ·ï¼Œæ— æ³•æµ‹è¯•è¿™äº›åœºæ™¯ã€‚

#### 3. Signer çš„ä¸‰å±‚ä»·å€¼

##### ä»·å€¼1ï¼šèº«ä»½æ¨¡æ‹Ÿï¼ˆè§’è‰²æµ‹è¯•ï¼‰

**é—®é¢˜**ï¼šå¦‚ä½•æµ‹è¯•"åªæœ‰ç®¡ç†å‘˜èƒ½é“¸é€ ä»£å¸"ï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼šç”¨ä¸åŒ signer åˆ†åˆ«æµ‹è¯•ç®¡ç†å‘˜å’Œæ™®é€šç”¨æˆ·çš„è¡Œä¸ºã€‚

**ç¤ºä¾‹**ï¼š
```javascript
const [owner, user1] = await ethers.getSigners();

// owner è°ƒç”¨åº”è¯¥æˆåŠŸ
await token.mint(1000);  // âœ…

// user1 è°ƒç”¨åº”è¯¥å¤±è´¥
await expect(token.connect(user1).mint(1000))
  .to.be.revertedWith("Only owner");  // âœ…
```

##### ä»·å€¼2ï¼šèµ„äº§æµè½¬ï¼ˆè½¬è´¦æµ‹è¯•ï¼‰

**é—®é¢˜**ï¼šå¦‚ä½•æµ‹è¯• A ç»™ B è½¬è´¦åï¼ŒåŒæ–¹ä½™é¢éƒ½æ­£ç¡®ï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼šç”¨ä¸¤ä¸ªä¸åŒçš„ signer ä»£è¡¨ A å’Œ Bã€‚

**ç¤ºä¾‹**ï¼š
```javascript
const [alice, bob] = await ethers.getSigners();

// Alice ç»™ Bob è½¬è´¦
await token.connect(alice).transfer(bob.address, 100);

// éªŒè¯åŒæ–¹ä½™é¢
expect(await token.balanceOf(alice.address)).to.equal(900);
expect(await token.balanceOf(bob.address)).to.equal(100);
```

##### ä»·å€¼3ï¼šçœŸå®åœºæ™¯ï¼ˆé›†æˆæµ‹è¯•ï¼‰

**é—®é¢˜**ï¼šå¦‚ä½•æµ‹è¯•å¤æ‚çš„å¤šæ–¹äº¤äº’ï¼ˆå¦‚ DEX äº¤æ˜“ï¼‰ï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼šæ¨¡æ‹Ÿå¤šä¸ªç”¨æˆ·åŒæ—¶å‚ä¸ã€‚

**ç¤ºä¾‹**ï¼š
```javascript
const [deployer, trader1, trader2, liquidityProvider] = await ethers.getSigners();

// LP æ·»åŠ æµåŠ¨æ€§
await dex.connect(liquidityProvider).addLiquidity(1000, 1000);

// Trader1 ä¹°å…¥
await dex.connect(trader1).swap(tokenA, tokenB, 100);

// Trader2 å–å‡º
await dex.connect(trader2).swap(tokenB, tokenA, 50);
```

#### 4. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼ Signer æœºåˆ¶

**æ¨ç†é“¾ï¼š**

```
1. å‰æï¼šä»¥å¤ªåŠäº¤æ˜“éœ€è¦ç§é’¥ç­¾å
   â†“
2. æ¨å¯¼ï¼šæµ‹è¯•éœ€è¦æ¨¡æ‹Ÿä¸åŒç”¨æˆ· â†’ éœ€è¦å¤šä¸ªç§é’¥
   â†“
3. æ¨å¯¼ï¼šæ‰‹åŠ¨ç®¡ç†ç§é’¥å¤ªéº»çƒ¦ â†’ Hardhat é¢„ç”Ÿæˆæµ‹è¯•è´¦æˆ·
   â†“
4. æ¨å¯¼ï¼šéœ€è¦è·å–è¿™äº›è´¦æˆ· â†’ ethers.getSigners()
   â†“
5. æ¨å¯¼ï¼šéœ€è¦åˆ‡æ¢è°ƒç”¨è€… â†’ contract.connect(signer)
   â†“
6. æ¨å¯¼ï¼šéœ€è¦è·å–è´¦æˆ·åœ°å€ â†’ signer.address
   â†“
7. æœ€ç»ˆå®ç°ï¼šå®Œæ•´çš„å¤šç”¨æˆ·æµ‹è¯•æœºåˆ¶
```

#### 5. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**Signer æ˜¯èƒ½ç­¾åäº¤æ˜“çš„è´¦æˆ·æŠ½è±¡ï¼Œé€šè¿‡ `getSigners()` è·å–é¢„ç½®æµ‹è¯•è´¦æˆ·ï¼Œé€šè¿‡ `connect()` åˆ‡æ¢è°ƒç”¨è€…èº«ä»½ï¼Œå®ç°å¯¹å¤šç”¨æˆ·ã€å¤šè§’è‰²åœºæ™¯çš„å®Œæ•´æµ‹è¯•è¦†ç›–ã€‚**

---

## 3. ã€3ä¸ªæ ¸å¿ƒæ¦‚å¿µã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼šethers.getSigners() ğŸ“‹

**ä¸€å¥è¯å®šä¹‰ï¼š** `ethers.getSigners()` è¿”å› Hardhat Network é¢„ç½®çš„æµ‹è¯•è´¦æˆ·æ•°ç»„ï¼Œé»˜è®¤ 20 ä¸ªè´¦æˆ·ï¼Œæ¯ä¸ªè´¦æˆ·æœ‰ 10000 ETHã€‚

```javascript
const { ethers } = require("hardhat");

async function main() {
  // è·å–æ‰€æœ‰é¢„ç½®è´¦æˆ·
  const signers = await ethers.getSigners();
  console.log("è´¦æˆ·æ•°é‡:", signers.length);  // 20

  // è§£æ„è·å–å¸¸ç”¨è´¦æˆ·
  const [owner, user1, user2, user3] = await ethers.getSigners();

  // æ‰“å°è´¦æˆ·ä¿¡æ¯
  console.log("Owner åœ°å€:", owner.address);
  console.log("User1 åœ°å€:", user1.address);

  // è·å–è´¦æˆ·ä½™é¢
  const balance = await ethers.provider.getBalance(owner.address);
  console.log("Owner ä½™é¢:", ethers.formatEther(balance), "ETH");
  // è¾“å‡º: Owner ä½™é¢: 10000.0 ETH
}
```

**Signer å¯¹è±¡çš„å¸¸ç”¨å±æ€§å’Œæ–¹æ³•ï¼š**

```javascript
const [signer] = await ethers.getSigners();

// ===== å±æ€§ =====
signer.address;           // è´¦æˆ·åœ°å€ï¼ˆ0x...ï¼‰
signer.provider;          // å…³è”çš„ Provider

// ===== æ–¹æ³• =====
await signer.getBalance();           // è·å– ETH ä½™é¢
await signer.getNonce();             // è·å– nonceï¼ˆå·²å‘é€äº¤æ˜“æ•°ï¼‰
await signer.estimateGas(tx);        // ä¼°ç®— Gas
await signer.sendTransaction(tx);    // å‘é€äº¤æ˜“
await signer.signMessage(message);   // ç­¾åæ¶ˆæ¯
await signer.signTypedData(domain, types, value);  // EIP-712 ç­¾å
```

**è¯¦ç»†è§£é‡Šï¼š**

Hardhat Network åœ¨å¯åŠ¨æ—¶è‡ªåŠ¨ç”Ÿæˆ 20 ä¸ªæµ‹è¯•è´¦æˆ·ï¼Œä½¿ç”¨å›ºå®šçš„åŠ©è®°è¯ï¼š
```
test test test test test test test test test test test junk
```

è¿™æ„å‘³ç€ï¼š
- æ¯æ¬¡è¿è¡Œæµ‹è¯•ï¼Œè´¦æˆ·åœ°å€ç›¸åŒ
- å¯ä»¥é¢„çŸ¥è´¦æˆ·åœ°å€ï¼ˆç”¨äºæµ‹è¯•ï¼‰
- æ¯ä¸ªè´¦æˆ·åˆå§‹æœ‰ 10000 ETHï¼ˆå¯é…ç½®ï¼‰

**åœ¨æ™ºèƒ½åˆçº¦æµ‹è¯•ä¸­çš„åº”ç”¨ï¼š**

```javascript
describe("Token", function () {
  async function deployFixture() {
    // è·å–ä¸åŒè§’è‰²çš„è´¦æˆ·
    const [owner, admin, user1, user2, ...rest] = await ethers.getSigners();

    // éƒ¨ç½²åˆçº¦ï¼ˆé»˜è®¤ç”¨ ownerï¼‰
    const Token = await ethers.getContractFactory("Token");
    const token = await Token.deploy();

    return { token, owner, admin, user1, user2 };
  }

  it("Should test with multiple accounts", async function () {
    const { token, owner, user1 } = await loadFixture(deployFixture);
    // ä½¿ç”¨ä¸åŒè´¦æˆ·è¿›è¡Œæµ‹è¯•
  });
});
```

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šcontract.connect(signer) ğŸ”—

**ä¸€å¥è¯å®šä¹‰ï¼š** `contract.connect(signer)` è¿”å›ä¸€ä¸ªæ–°çš„åˆçº¦å®ä¾‹ï¼Œåç»­è°ƒç”¨å°†ä»¥æŒ‡å®š signer çš„èº«ä»½æ‰§è¡Œã€‚

```javascript
const { ethers } = require("hardhat");

async function main() {
  const [owner, user1, user2] = await ethers.getSigners();
  const Token = await ethers.getContractFactory("Token");
  const token = await Token.deploy(1000000);

  // ===== é»˜è®¤ä½¿ç”¨éƒ¨ç½²è€…ï¼ˆownerï¼‰è°ƒç”¨ =====
  await token.transfer(user1.address, 100);
  // msg.sender = owner.address

  // ===== ä½¿ç”¨ user1 è°ƒç”¨ =====
  const tokenAsUser1 = token.connect(user1);
  await tokenAsUser1.transfer(user2.address, 50);
  // msg.sender = user1.address

  // ===== æˆ–è€…é“¾å¼è°ƒç”¨ =====
  await token.connect(user1).transfer(user2.address, 50);
  // msg.sender = user1.address

  // ===== æ³¨æ„ï¼šconnect ä¸ä¿®æ”¹åŸå®ä¾‹ =====
  await token.transfer(user1.address, 100);
  // msg.sender ä»ç„¶æ˜¯ owner.addressï¼ˆåŸå®ä¾‹æœªå˜ï¼‰
}
```

**è¯¦ç»†è§£é‡Šï¼š**

`connect()` çš„å·¥ä½œåŸç†ï¼š
1. **ä¸ä¿®æ”¹åŸå®ä¾‹**ï¼šè¿”å›æ–°çš„åˆçº¦å®ä¾‹
2. **ç»‘å®šæ–° signer**ï¼šæ–°å®ä¾‹çš„äº¤æ˜“å°†ç”±æ–° signer ç­¾å
3. **åªå½±å“å†™æ“ä½œ**ï¼šè¯»æ“ä½œï¼ˆview/pureï¼‰ä¸éœ€è¦ signer

**ä¸ºä»€ä¹ˆéœ€è¦ connectï¼Ÿ**

```solidity
// åˆçº¦ä¸­çš„æƒé™æ§åˆ¶
contract Token {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function mint(uint256 amount) public onlyOwner {
        // åªæœ‰ owner èƒ½è°ƒç”¨
    }
}
```

```javascript
// æµ‹è¯•æƒé™æ§åˆ¶
it("Should only allow owner to mint", async function () {
  const { token, owner, user1 } = await loadFixture(deployFixture);

  // owner è°ƒç”¨æˆåŠŸ
  await token.mint(100);  // âœ… msg.sender = owner

  // user1 è°ƒç”¨å¤±è´¥
  await expect(token.connect(user1).mint(100))
    .to.be.revertedWith("Not owner");  // msg.sender = user1
});
```

**åœ¨æ™ºèƒ½åˆçº¦æµ‹è¯•ä¸­çš„åº”ç”¨ï¼š**

```javascript
describe("Access Control", function () {
  it("Should allow admin to pause", async function () {
    const { contract, admin } = await loadFixture(deployFixture);
    await contract.connect(admin).pause();
    expect(await contract.paused()).to.be.true;
  });

  it("Should prevent non-admin from pausing", async function () {
    const { contract, user1 } = await loadFixture(deployFixture);
    await expect(contract.connect(user1).pause())
      .to.be.revertedWith("AccessControl: account is missing role");
  });
});
```

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼šimpersonateAccountï¼ˆå†’å……çœŸå®åœ°å€ï¼‰ğŸ­

**ä¸€å¥è¯å®šä¹‰ï¼š** `impersonateAccount` å…è®¸ä½ åœ¨ Fork ä¸»ç½‘æ—¶å†’å……ä»»æ„åœ°å€å‘é€äº¤æ˜“ï¼Œç”¨äºæµ‹è¯•ä¸çœŸå®å·¨é²¸è´¦æˆ·çš„äº¤äº’ã€‚

```javascript
const { ethers } = require("hardhat");
const { impersonateAccount, stopImpersonatingAccount, setBalance } = require("@nomicfoundation/hardhat-network-helpers");

// å†’å…… Vitalik çš„åœ°å€
const VITALIK_ADDRESS = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";

async function main() {
  // 1. å¼€å§‹å†’å……
  await impersonateAccount(VITALIK_ADDRESS);

  // 2. è·å–å†’å……è´¦æˆ·çš„ signer
  const vitalik = await ethers.getSigner(VITALIK_ADDRESS);

  // 3. ç»™å†’å……è´¦æˆ·è®¾ç½®ä½™é¢ï¼ˆå¦åˆ™å¯èƒ½æ²¡æœ‰ ETH ä»˜ Gasï¼‰
  await setBalance(VITALIK_ADDRESS, ethers.parseEther("100"));

  // 4. ä½¿ç”¨å†’å……è´¦æˆ·å‘é€äº¤æ˜“
  const token = await ethers.getContractAt("IERC20", TOKEN_ADDRESS);
  await token.connect(vitalik).transfer(myAddress, 1000000n);

  // 5. åœæ­¢å†’å……
  await stopImpersonatingAccount(VITALIK_ADDRESS);
}
```

**è¯¦ç»†è§£é‡Šï¼š**

`impersonateAccount` åªåœ¨ä»¥ä¸‹æƒ…å†µä¸‹æœ‰æ•ˆï¼š
- ä½¿ç”¨ Hardhat Networkï¼ˆæœ¬åœ°æµ‹è¯•ç½‘ï¼‰
- é€šå¸¸é…åˆ Fork ä¸»ç½‘ä½¿ç”¨

**å¸¸è§ä½¿ç”¨åœºæ™¯ï¼š**

1. **æµ‹è¯•ä¸å·¨é²¸äº¤äº’**ï¼šå†’å……æŒæœ‰å¤§é‡ä»£å¸çš„åœ°å€
2. **æµ‹è¯•æ²»ç†æŠ•ç¥¨**ï¼šå†’å……å¤§æˆ·è¿›è¡ŒæŠ•ç¥¨
3. **æµ‹è¯•æ¸…ç®—é€»è¾‘**ï¼šå†’å……æœ‰å¤§é‡æŠµæŠ¼çš„è´¦æˆ·

**åœ¨æ™ºèƒ½åˆçº¦æµ‹è¯•ä¸­çš„åº”ç”¨ï¼š**

```javascript
const { impersonateAccount, setBalance } = require("@nomicfoundation/hardhat-network-helpers");

describe("Whale Interaction", function () {
  // éœ€è¦åœ¨ hardhat.config.js ä¸­é…ç½® fork
  // forking: { url: "https://eth-mainnet.g.alchemy.com/v2/..." }

  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  const WHALE_ADDRESS = "0x47ac0fb4f2d84898e4d9e7b4dab3c24507a6d503";  // Binance çƒ­é’±åŒ…

  it("Should transfer USDC from whale", async function () {
    // å†’å……å·¨é²¸
    await impersonateAccount(WHALE_ADDRESS);
    await setBalance(WHALE_ADDRESS, ethers.parseEther("10"));

    const whale = await ethers.getSigner(WHALE_ADDRESS);
    const usdc = await ethers.getContractAt("IERC20", USDC_ADDRESS);

    const [, recipient] = await ethers.getSigners();

    // å·¨é²¸è½¬è´¦
    await usdc.connect(whale).transfer(recipient.address, 1000000n);

    expect(await usdc.balanceOf(recipient.address)).to.equal(1000000n);

    await stopImpersonatingAccount(WHALE_ADDRESS);
  });
});
```

---

## 4. ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹å†…å®¹ï¼Œå°±èƒ½åœ¨æµ‹è¯•ä¸­ä½¿ç”¨ä¸åŒç­¾åè€…ï¼š

### 4.1 åŸºç¡€ç”¨æ³•ï¼šè·å–å’Œä½¿ç”¨ç­¾åè€…

```javascript
const { ethers } = require("hardhat");

describe("Multi-Signer Test", function () {
  it("Should use different signers", async function () {
    // è·å–ç­¾åè€…
    const [owner, user1, user2] = await ethers.getSigners();

    // éƒ¨ç½²åˆçº¦ï¼ˆé»˜è®¤ç”¨ç¬¬ä¸€ä¸ªè´¦æˆ·ï¼‰
    const Token = await ethers.getContractFactory("Token");
    const token = await Token.deploy(1000000);

    // owner è½¬è´¦ç»™ user1
    await token.transfer(user1.address, 100);

    // user1 è½¬è´¦ç»™ user2ï¼ˆä½¿ç”¨ connectï¼‰
    await token.connect(user1).transfer(user2.address, 50);

    // éªŒè¯ä½™é¢
    expect(await token.balanceOf(user1.address)).to.equal(50);
    expect(await token.balanceOf(user2.address)).to.equal(50);
  });
});
```

### 4.2 æƒé™æµ‹è¯•

```javascript
it("Should restrict access to owner only", async function () {
  const [owner, user1] = await ethers.getSigners();
  const token = await Token.deploy();

  // owner å¯ä»¥è°ƒç”¨
  await token.mint(100);

  // user1 ä¸èƒ½è°ƒç”¨
  await expect(token.connect(user1).mint(100))
    .to.be.revertedWith("Ownable: caller is not the owner");
});
```

### 4.3 å¤šç”¨æˆ·äº¤äº’åœºæ™¯

```javascript
it("Should handle multi-party transaction", async function () {
  const [seller, buyer, platform] = await ethers.getSigners();

  // å–å®¶ä¸Šæ¶å•†å“
  await marketplace.connect(seller).listItem(itemId, price);

  // ä¹°å®¶è´­ä¹°
  await marketplace.connect(buyer).buyItem(itemId, { value: price });

  // å¹³å°æ”¶å–æ‰‹ç»­è´¹åç»“ç®—
  await marketplace.connect(platform).settlePayment(itemId);
});
```

### 4.4 å¸¸ç”¨æ¨¡å¼

```javascript
// æ¨¡å¼1ï¼šè§£æ„è·å–å¤šä¸ªè´¦æˆ·
const [owner, admin, user1, user2, ...others] = await ethers.getSigners();

// æ¨¡å¼2ï¼šè¯­ä¹‰åŒ–å‘½å
async function deployFixture() {
  const [deployer, treasury, alice, bob] = await ethers.getSigners();
  return { deployer, treasury, alice, bob };
}

// æ¨¡å¼3ï¼šè·å–ç‰¹å®šç´¢å¼•çš„è´¦æˆ·
const signers = await ethers.getSigners();
const user10 = signers[9];  // ç¬¬10ä¸ªè´¦æˆ·

// æ¨¡å¼4ï¼šæ£€æŸ¥è°ƒç”¨è€…
const [owner] = await ethers.getSigners();
expect(await token.owner()).to.equal(owner.address);
```

---

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- âœ… è·å–æµ‹è¯•è´¦æˆ·
- âœ… åˆ‡æ¢äº¤æ˜“å‘é€è€…
- âœ… æµ‹è¯•æƒé™æ§åˆ¶
- âœ… æ¨¡æ‹Ÿå¤šç”¨æˆ·äº¤äº’
- âœ… ä¸º Fork æµ‹è¯•æ‰“åŸºç¡€

---

## 5. ã€1ä¸ªç±»æ¯”ã€‘

### ç±»æ¯”1ï¼šSigner èº«ä»½åˆ‡æ¢ ğŸ­

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šSigner = é“¶è¡ŒæŸœå°çš„èº«ä»½è¯

æƒ³è±¡ä½ åœ¨é“¶è¡ŒåŠç†ä¸šåŠ¡ï¼š

**ä¼ ç»Ÿé“¶è¡Œæµç¨‹ï¼š**
1. ä½ æ‹¿ç€**ä½ çš„èº«ä»½è¯**åŠç†è‡ªå·±çš„ä¸šåŠ¡
2. æƒ³å¸®å®¶äººåŠä¸šåŠ¡ï¼Ÿéœ€è¦æ‹¿**ä»–ä»¬çš„èº«ä»½è¯**å’Œæˆæƒä¹¦
3. æŸœå°æ ¹æ®èº«ä»½è¯ç¡®è®¤"ä½ æ˜¯è°"ï¼Œå†³å®š"ä½ èƒ½åšä»€ä¹ˆ"

**å¯¹åº”æ™ºèƒ½åˆçº¦ï¼š**
1. ä½ çš„ **Signer** = ä½ çš„èº«ä»½è¯ï¼ˆå†³å®š msg.senderï¼‰
2. `connect(anotherSigner)` = æ¢ä¸€ä¸ªäººçš„èº«ä»½è¯åŠä¸šåŠ¡
3. åˆçº¦çš„æƒé™æ£€æŸ¥ = æŸœå°æ ¸å®èº«ä»½

```javascript
// é“¶è¡Œä¸šåŠ¡"ä»£ç "
const [æˆ‘, çˆ¸çˆ¸, å¦ˆå¦ˆ] = await è·å–å®¶åº­æˆå‘˜èº«ä»½è¯();

// ç”¨æˆ‘çš„èº«ä»½è¯åŠç†æˆ‘çš„ä¸šåŠ¡
await é“¶è¡Œ.å–æ¬¾(1000);  // msg.sender = æˆ‘

// ç”¨çˆ¸çˆ¸çš„èº«ä»½è¯åŠç†ä»–çš„ä¸šåŠ¡
await é“¶è¡Œ.connect(çˆ¸çˆ¸).å–æ¬¾(2000);  // msg.sender = çˆ¸çˆ¸

// æƒé™æµ‹è¯•
await expect(é“¶è¡Œ.connect(æˆ‘).è®¿é—®çˆ¸çˆ¸è´¦æˆ·())
  .to.be.revertedWith("æ— æƒè®¿é—®ä»–äººè´¦æˆ·");
```

**å¯¹åº”å…³ç³»ï¼š**

| é“¶è¡Œæ¦‚å¿µ | Hardhat æ¦‚å¿µ | è¯´æ˜ |
|---------|-------------|------|
| èº«ä»½è¯ | Signer | è¯æ˜"ä½ æ˜¯è°" |
| æ¢èº«ä»½è¯ | connect(signer) | åˆ‡æ¢è°ƒç”¨è€… |
| æŸœå°æ ¸å® | require(msg.sender == ...) | æƒé™æ£€æŸ¥ |
| åŠä¸šåŠ¡ | è°ƒç”¨åˆçº¦å‡½æ•° | æ‰§è¡Œæ“ä½œ |
| ä¸šåŠ¡å‡­è¯ | äº¤æ˜“ç­¾å | è¯æ˜æ˜¯æœ¬äººæ“ä½œ |

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šSigner = HTTP è¯·æ±‚çš„è®¤è¯ Token

å¦‚æœä½ ç†Ÿæ‚‰å‰ç«¯å¼€å‘ï¼ŒSigner å°±åƒ API è¯·æ±‚ä¸­çš„ **Authorization Header**ï¼š

```javascript
// å‰ç«¯ API è°ƒç”¨
const userAToken = "Bearer token_user_a";
const userBToken = "Bearer token_user_b";

// ç”¨æˆ· A çš„è¯·æ±‚
await fetch("/api/transfer", {
  headers: { Authorization: userAToken },
  body: JSON.stringify({ to: "userB", amount: 100 })
});

// ç”¨æˆ· B çš„è¯·æ±‚
await fetch("/api/withdraw", {
  headers: { Authorization: userBToken },
  body: JSON.stringify({ amount: 50 })
});

// åç«¯éªŒè¯
function handleRequest(req) {
  const user = verifyToken(req.headers.authorization);
  if (user.role !== "admin") {
    throw new Error("Unauthorized");
  }
}
```

```javascript
// æ™ºèƒ½åˆçº¦è°ƒç”¨
const [userA, userB] = await ethers.getSigners();

// ç”¨æˆ· A çš„äº¤æ˜“ï¼ˆç­¾å = è®¤è¯ï¼‰
await token.connect(userA).transfer(userB.address, 100);

// ç”¨æˆ· B çš„äº¤æ˜“
await token.connect(userB).transfer(userA.address, 50);

// åˆçº¦æƒé™éªŒè¯
function onlyAdmin() public {
  require(msg.sender == admin, "Unauthorized");
}
```

**å¯¹æ¯”è¡¨ï¼š**

| æ¦‚å¿µ | å‰ç«¯ API | æ™ºèƒ½åˆçº¦ |
|------|---------|---------|
| èº«ä»½æ ‡è¯† | JWT Token | Signerï¼ˆç§é’¥ï¼‰ |
| åˆ‡æ¢ç”¨æˆ· | æ›´æ¢ Authorization Header | connect(signer) |
| èº«ä»½éªŒè¯ | åç«¯ verifyToken() | åˆçº¦ msg.sender æ£€æŸ¥ |
| æƒé™æ§åˆ¶ | åç«¯ RBAC | åˆçº¦ modifier |
| è¯·æ±‚ç­¾å | æ— ï¼ˆæˆ– HMACï¼‰ | ECDSA ç­¾å |

---

### ç±»æ¯”2ï¼šconnect() æ–¹æ³• ğŸ”Œ

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šconnect() = åˆ‡æ¢ç™»å½•è´¦å·

æƒ³è±¡ä½ åœ¨ç”¨ä¸€å°å…¬å…±ç”µè„‘ï¼š

**åˆ‡æ¢è´¦å·æµç¨‹ï¼š**
1. ç”µè„‘ä¸Šè£…äº†æ·˜å® APP
2. ä½ ç”¨**ä½ çš„è´¦å·**ç™»å½•ï¼Œèƒ½çœ‹ä½ çš„è®¢å•
3. åˆ‡æ¢åˆ°**æœ‹å‹çš„è´¦å·**ï¼Œèƒ½çœ‹æœ‹å‹çš„è®¢å•
4. åˆ‡æ¢è´¦å·**ä¸å½±å“**APP æœ¬èº«ï¼Œåªå½±å“"è°åœ¨æ“ä½œ"

```javascript
// æ·˜å®"ä»£ç "
const æ·˜å®App = await æ‰“å¼€æ·˜å®();

// é»˜è®¤ç”¨ä½ çš„è´¦å·
await æ·˜å®App.æŸ¥çœ‹è®¢å•();  // ä½ çš„è®¢å•

// åˆ‡æ¢åˆ°æœ‹å‹è´¦å·
const æ·˜å®_æœ‹å‹è´¦å· = æ·˜å®App.connect(æœ‹å‹è´¦å·);
await æ·˜å®_æœ‹å‹è´¦å·.æŸ¥çœ‹è®¢å•();  // æœ‹å‹çš„è®¢å•

// åŸæ¥çš„å®ä¾‹æ²¡å˜
await æ·˜å®App.æŸ¥çœ‹è®¢å•();  // è¿˜æ˜¯ä½ çš„è®¢å•
```

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šconnect() = React Context åˆ‡æ¢

```javascript
// React Context åˆ‡æ¢ç”¨æˆ·
const UserContext = createContext();

function App() {
  const [currentUser, setCurrentUser] = useState(userA);

  return (
    <UserContext.Provider value={currentUser}>
      <Dashboard />
      <button onClick={() => setCurrentUser(userB)}>åˆ‡æ¢åˆ°ç”¨æˆ·B</button>
    </UserContext.Provider>
  );
}

// æ™ºèƒ½åˆçº¦ connect
const token = await Token.deploy();  // é»˜è®¤ç”¨ owner

// åˆ‡æ¢åˆ° user1
const tokenAsUser1 = token.connect(user1);  // ç±»ä¼¼åˆ‡æ¢ Context

// ä½¿ç”¨åˆ‡æ¢åçš„å®ä¾‹
await tokenAsUser1.transfer(user2.address, 100);
```

---

### ç±»æ¯”3ï¼šgetSigners() é¢„ç½®è´¦æˆ· ğŸ‘¥

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šgetSigners() = ç”µå½±ç¾¤æ¼”åå•

æƒ³è±¡ä½ æ˜¯å¯¼æ¼”åœ¨æ‹ä¸€åœºå¤æ‚çš„åœºæ™¯ï¼š

**ç¾¤æ¼”ç®¡ç†ï¼š**
1. å‰§ç»„æå‰å‡†å¤‡äº† **20 ä¸ªç¾¤æ¼”**ï¼ˆé¢„ç½®è´¦æˆ·ï¼‰
2. æ¯ä¸ªç¾¤æ¼”æœ‰è‡ªå·±çš„**ç¼–å·å’Œæœè£…**ï¼ˆåœ°å€å’Œä½™é¢ï¼‰
3. ä½ å¯ä»¥æŒ‰éœ€åˆ†é…**è§’è‰²**ï¼ˆowner, user1, admin...ï¼‰
4. æ¯æ¬¡é‡æ‹ï¼ˆæµ‹è¯•ï¼‰ï¼Œç¾¤æ¼”**æ¢å¤åˆ°åˆå§‹ä½ç½®**ï¼ˆloadFixtureï¼‰

```javascript
// ç”µå½±æ‹æ‘„"ä»£ç "
const ç¾¤æ¼”åå• = await è·å–ç¾¤æ¼”();  // 20 ä¸ªç¾¤æ¼”
const [ä¸»è§’, åæ´¾, è·¯äººç”², è·¯äººä¹™] = ç¾¤æ¼”åå•;

// åˆ†é…è§’è‰²å¹¶æ‹æ‘„
await æ‹æ‘„åœºæ™¯("ä¸»è§’æ‰“è´¥åæ´¾", { ä¸»è§’, åæ´¾ });
await æ‹æ‘„åœºæ™¯("è·¯äººå›´è§‚", { è·¯äººç”², è·¯äººä¹™ });

// é‡æ‹ï¼šç¾¤æ¼”æ¢å¤åˆå§‹ä½ç½®
await loadFixture(é‡ç½®åœºæ™¯);
```

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šgetSigners() = Jest çš„ Mock Users

```javascript
// Jest æµ‹è¯•ä¸­çš„ mock ç”¨æˆ·
const mockUsers = [
  { id: 1, name: "Owner", role: "admin" },
  { id: 2, name: "User1", role: "user" },
  { id: 3, name: "User2", role: "user" },
];

beforeEach(() => {
  // æ¯ä¸ªæµ‹è¯•è·å– mock ç”¨æˆ·
  const [owner, user1, user2] = mockUsers;
});

// Hardhat æµ‹è¯•
beforeEach(async () => {
  // æ¯ä¸ªæµ‹è¯•è·å–é¢„ç½®è´¦æˆ·
  const [owner, user1, user2] = await ethers.getSigners();
});
```

---

### ç±»æ¯”æ€»ç»“è¡¨

| Signer æ¦‚å¿µ | ç”Ÿæ´»åœºæ™¯ç±»æ¯” | å‰ç«¯é¢†åŸŸç±»æ¯” | æ ¸å¿ƒç›¸ä¼¼æ€§ |
|------------|-------------|-------------|-----------|
| **Signer** | èº«ä»½è¯ | JWT Token | è¯æ˜èº«ä»½ |
| **getSigners()** | é¢†å–ç¾¤æ¼”åå• | è·å– Mock Users | è·å–æµ‹è¯•èº«ä»½ |
| **connect(signer)** | æ¢èº«ä»½è¯åŠä¸šåŠ¡ | åˆ‡æ¢ Auth Header | åˆ‡æ¢è°ƒç”¨è€… |
| **signer.address** | èº«ä»½è¯å·ç  | User ID | å”¯ä¸€æ ‡è¯† |
| **msg.sender** | æŸœå°çœ‹åˆ°çš„åŠäº‹äºº | åç«¯è·å–çš„ currentUser | å®é™…è°ƒç”¨è€… |
| **æƒé™æ£€æŸ¥** | æŸœå°æ ¸å®èº«ä»½ | åç«¯ RBAC | éªŒè¯æƒé™ |
| **impersonateAccount** | ä½¿ç”¨åˆ«äººçš„èº«ä»½è¯ | æ¨¡æ‹Ÿå…¶ä»–ç”¨æˆ·ç™»å½• | å†’å……èº«ä»½ |

---

## 6. ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼šconnect() ä¼šä¿®æ”¹åŸåˆçº¦å®ä¾‹ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

```javascript
// âŒ é”™è¯¯ç†è§£
const token = await Token.deploy();
token.connect(user1);  // ä»¥ä¸ºä¿®æ”¹äº† token
await token.transfer(user2.address, 100);  // æœŸæœ› user1 è°ƒç”¨

// å®é™…ä¸Š token çš„ signer è¿˜æ˜¯ ownerï¼
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

åœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œ`object.setXxx()` é€šå¸¸ä¼šä¿®æ”¹å¯¹è±¡æœ¬èº«ã€‚ä½† ethers.js çš„ `connect()` é‡‡ç”¨**ä¸å¯å˜æ¨¡å¼**ï¼Œè¿”å›æ–°å®ä¾‹ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// âœ… æ­£ç¡®ï¼šæ¥æ”¶ connect è¿”å›çš„æ–°å®ä¾‹
const token = await Token.deploy();
const tokenAsUser1 = token.connect(user1);  // è¿”å›æ–°å®ä¾‹

await token.transfer(user2.address, 100);         // owner è°ƒç”¨
await tokenAsUser1.transfer(user2.address, 100);  // user1 è°ƒç”¨

// âœ… æˆ–è€…é“¾å¼è°ƒç”¨
await token.connect(user1).transfer(user2.address, 100);  // user1 è°ƒç”¨
```

---

### è¯¯åŒº2ï¼šç¬¬ä¸€ä¸ª signer å°±æ˜¯åˆçº¦ owner âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

```javascript
// âŒ é”™è¯¯ç†è§£
const [owner] = await ethers.getSigners();
// ä»¥ä¸ºæ‰€æœ‰åˆçº¦çš„ owner éƒ½æ˜¯è¿™ä¸ª signer
```

å®é™…ä¸Šï¼š
- `getSigners()[0]` åªæ˜¯ **é»˜è®¤éƒ¨ç½²è€…**
- åˆçº¦çš„ `owner` å–å†³äº**åˆçº¦ä»£ç **å¦‚ä½•è®¾ç½®

```solidity
// åˆçº¦ Aï¼šéƒ¨ç½²è€…æ˜¯ owner
contract A {
    address public owner = msg.sender;  // éƒ¨ç½²è€…
}

// åˆçº¦ Bï¼šå¯ä»¥æŒ‡å®š owner
contract B {
    address public owner;
    constructor(address _owner) {
        owner = _owner;  // å¯ä»¥æ˜¯ä»»ä½•åœ°å€
    }
}
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å¤§å¤šæ•°æ•™ç¨‹é»˜è®¤ç”¨ç¬¬ä¸€ä¸ª signer éƒ¨ç½²å¹¶ä½œä¸º ownerï¼Œå½¢æˆä¹ æƒ¯æ€§è®¤çŸ¥ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
const [deployer, actualOwner, user1] = await ethers.getSigners();

// éƒ¨ç½²è€… â‰  owner
const Token = await ethers.getContractFactory("Token");
const token = await Token.connect(deployer).deploy(actualOwner.address);

// deployer æ˜¯éƒ¨ç½²è€…
// actualOwner æ˜¯åˆçº¦çš„ owner
expect(await token.owner()).to.equal(actualOwner.address);
```

---

### è¯¯åŒº3ï¼šæ¯ä¸ªæµ‹è¯•çš„ signer é¡ºåºå¯èƒ½ä¸åŒ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

```javascript
// âŒ é”™è¯¯ç†è§£
it("Test 1", async () => {
  const [a, b, c] = await ethers.getSigners();
  // æ‹…å¿ƒå¦ä¸€ä¸ªæµ‹è¯•ä¸­é¡ºåºä¸åŒ
});
```

å®é™…ä¸Šï¼ŒHardhat ä½¿ç”¨**å›ºå®šçš„åŠ©è®°è¯**ç”Ÿæˆè´¦æˆ·ï¼Œé¡ºåºæ°¸è¿œç›¸åŒï¼š

```
Account #0: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000 ETH)
Account #1: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 (10000 ETH)
Account #2: 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC (10000 ETH)
...
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

åœ¨å…¶ä»–æµ‹è¯•æ¡†æ¶ä¸­ï¼Œéšæœºæ•°æ®æ˜¯å¸¸è§çš„ï¼Œå®¹æ˜“äº§ç”Ÿ"ä¸ç¡®å®šæ€§"çš„æ‹…å¿§ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// âœ… å¯ä»¥æ”¾å¿ƒä½¿ç”¨ï¼Œé¡ºåºå§‹ç»ˆä¸€è‡´
describe("Test Suite", function () {
  it("Test 1", async function () {
    const [owner, user1] = await ethers.getSigners();
    console.log(owner.address);  // å§‹ç»ˆæ˜¯ 0xf39Fd6e51...
  });

  it("Test 2", async function () {
    const [owner, user1] = await ethers.getSigners();
    console.log(owner.address);  // è¿˜æ˜¯ 0xf39Fd6e51...ï¼ˆç›¸åŒï¼‰
  });
});
```

---

## 7. ã€å®æˆ˜ä»£ç ã€‘

### åŸºç¡€å®ç°ï¼šå¤šè§’è‰²æƒé™æµ‹è¯•

```solidity
// contracts/RoleBasedToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract RoleBasedToken {
    string public name = "RoleToken";
    string public symbol = "RTK";
    
    address public owner;
    address public minter;
    address public pauser;
    
    uint256 public totalSupply;
    bool public paused;
    
    mapping(address => uint256) public balanceOf;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event RoleChanged(string role, address oldAddress, address newAddress);
    event Paused(address account);
    event Unpaused(address account);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    modifier onlyMinter() {
        require(msg.sender == minter, "Not minter");
        _;
    }
    
    modifier onlyPauser() {
        require(msg.sender == pauser, "Not pauser");
        _;
    }
    
    modifier whenNotPaused() {
        require(!paused, "Paused");
        _;
    }
    
    constructor(address _minter, address _pauser) {
        owner = msg.sender;
        minter = _minter;
        pauser = _pauser;
    }
    
    function setMinter(address _minter) external onlyOwner {
        emit RoleChanged("minter", minter, _minter);
        minter = _minter;
    }
    
    function setPauser(address _pauser) external onlyOwner {
        emit RoleChanged("pauser", pauser, _pauser);
        pauser = _pauser;
    }
    
    function mint(address to, uint256 amount) external onlyMinter whenNotPaused {
        totalSupply += amount;
        balanceOf[to] += amount;
        emit Transfer(address(0), to, amount);
    }
    
    function transfer(address to, uint256 amount) external whenNotPaused {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }
    
    function pause() external onlyPauser {
        paused = true;
        emit Paused(msg.sender);
    }
    
    function unpause() external onlyPauser {
        paused = false;
        emit Unpaused(msg.sender);
    }
}
```

```javascript
// test/RoleBasedToken.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

describe("RoleBasedToken", function () {
  // ===== Fixture =====
  async function deployFixture() {
    // è·å–ä¸åŒè§’è‰²çš„ç­¾åè€…
    const [owner, minter, pauser, user1, user2, attacker] = await ethers.getSigners();

    // éƒ¨ç½²åˆçº¦ï¼Œè®¾ç½®è§’è‰²
    const RoleBasedToken = await ethers.getContractFactory("RoleBasedToken");
    const token = await RoleBasedToken.deploy(minter.address, pauser.address);

    return { token, owner, minter, pauser, user1, user2, attacker };
  }

  // ===== éƒ¨ç½²æµ‹è¯• =====
  describe("Deployment", function () {
    it("Should set the correct owner", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      expect(await token.owner()).to.equal(owner.address);
    });

    it("Should set the correct minter", async function () {
      const { token, minter } = await loadFixture(deployFixture);
      expect(await token.minter()).to.equal(minter.address);
    });

    it("Should set the correct pauser", async function () {
      const { token, pauser } = await loadFixture(deployFixture);
      expect(await token.pauser()).to.equal(pauser.address);
    });
  });

  // ===== Owner æƒé™æµ‹è¯• =====
  describe("Owner Functions", function () {
    it("Should allow owner to change minter", async function () {
      const { token, owner, user1 } = await loadFixture(deployFixture);

      await expect(token.connect(owner).setMinter(user1.address))
        .to.emit(token, "RoleChanged")
        .withArgs("minter", await token.minter(), user1.address);

      expect(await token.minter()).to.equal(user1.address);
    });

    it("Should prevent non-owner from changing minter", async function () {
      const { token, minter, user1 } = await loadFixture(deployFixture);

      await expect(token.connect(minter).setMinter(user1.address))
        .to.be.revertedWith("Not owner");
    });

    it("Should prevent attacker from changing roles", async function () {
      const { token, attacker, user1 } = await loadFixture(deployFixture);

      await expect(token.connect(attacker).setMinter(user1.address))
        .to.be.revertedWith("Not owner");

      await expect(token.connect(attacker).setPauser(user1.address))
        .to.be.revertedWith("Not owner");
    });
  });

  // ===== Minter æƒé™æµ‹è¯• =====
  describe("Minter Functions", function () {
    it("Should allow minter to mint tokens", async function () {
      const { token, minter, user1 } = await loadFixture(deployFixture);

      await token.connect(minter).mint(user1.address, 1000);

      expect(await token.balanceOf(user1.address)).to.equal(1000);
      expect(await token.totalSupply()).to.equal(1000);
    });

    it("Should prevent non-minter from minting", async function () {
      const { token, owner, user1 } = await loadFixture(deployFixture);

      // å³ä½¿æ˜¯ owner ä¹Ÿä¸èƒ½ mint
      await expect(token.connect(owner).mint(user1.address, 1000))
        .to.be.revertedWith("Not minter");
    });

    it("Should prevent attacker from minting", async function () {
      const { token, attacker, user1 } = await loadFixture(deployFixture);

      await expect(token.connect(attacker).mint(user1.address, 1000))
        .to.be.revertedWith("Not minter");
    });
  });

  // ===== Pauser æƒé™æµ‹è¯• =====
  describe("Pauser Functions", function () {
    it("Should allow pauser to pause", async function () {
      const { token, pauser } = await loadFixture(deployFixture);

      await expect(token.connect(pauser).pause())
        .to.emit(token, "Paused")
        .withArgs(pauser.address);

      expect(await token.paused()).to.be.true;
    });

    it("Should allow pauser to unpause", async function () {
      const { token, pauser } = await loadFixture(deployFixture);

      await token.connect(pauser).pause();
      await token.connect(pauser).unpause();

      expect(await token.paused()).to.be.false;
    });

    it("Should prevent non-pauser from pausing", async function () {
      const { token, owner } = await loadFixture(deployFixture);

      await expect(token.connect(owner).pause())
        .to.be.revertedWith("Not pauser");
    });
  });

  // ===== æš‚åœçŠ¶æ€æµ‹è¯• =====
  describe("Pause Effect", function () {
    it("Should prevent minting when paused", async function () {
      const { token, minter, pauser, user1 } = await loadFixture(deployFixture);

      await token.connect(pauser).pause();

      await expect(token.connect(minter).mint(user1.address, 1000))
        .to.be.revertedWith("Paused");
    });

    it("Should prevent transfer when paused", async function () {
      const { token, minter, pauser, user1, user2 } = await loadFixture(deployFixture);

      // å…ˆé“¸é€ ä¸€äº›ä»£å¸
      await token.connect(minter).mint(user1.address, 1000);

      // æš‚åœ
      await token.connect(pauser).pause();

      // è½¬è´¦åº”è¯¥å¤±è´¥
      await expect(token.connect(user1).transfer(user2.address, 100))
        .to.be.revertedWith("Paused");
    });

    it("Should allow transfer after unpause", async function () {
      const { token, minter, pauser, user1, user2 } = await loadFixture(deployFixture);

      await token.connect(minter).mint(user1.address, 1000);
      await token.connect(pauser).pause();
      await token.connect(pauser).unpause();

      // ç°åœ¨å¯ä»¥è½¬è´¦äº†
      await token.connect(user1).transfer(user2.address, 100);
      expect(await token.balanceOf(user2.address)).to.equal(100);
    });
  });

  // ===== å¤šç”¨æˆ·äº¤äº’æµ‹è¯• =====
  describe("Multi-User Interactions", function () {
    it("Should handle complex role interactions", async function () {
      const { token, owner, minter, pauser, user1, user2 } = await loadFixture(deployFixture);

      // 1. Minter é“¸é€ ç»™ user1
      await token.connect(minter).mint(user1.address, 1000);

      // 2. user1 è½¬è´¦ç»™ user2
      await token.connect(user1).transfer(user2.address, 300);

      // 3. Owner æ›´æ¢ minter
      await token.connect(owner).setMinter(user1.address);

      // 4. åŸ minter ä¸èƒ½å†é“¸é€ 
      await expect(token.connect(minter).mint(user2.address, 500))
        .to.be.revertedWith("Not minter");

      // 5. æ–° minter (user1) å¯ä»¥é“¸é€ 
      await token.connect(user1).mint(user2.address, 500);

      // éªŒè¯æœ€ç»ˆçŠ¶æ€
      expect(await token.balanceOf(user1.address)).to.equal(700);
      expect(await token.balanceOf(user2.address)).to.equal(800);
    });

    it("Should correctly handle role transitions", async function () {
      const { token, owner, minter, user1 } = await loadFixture(deployFixture);

      // è®°å½•åˆå§‹ minter
      const oldMinter = await token.minter();
      expect(oldMinter).to.equal(minter.address);

      // Owner æ›´æ¢ minter ä¸º user1
      await token.connect(owner).setMinter(user1.address);

      // éªŒè¯è§’è‰²å˜æ›´
      expect(await token.minter()).to.equal(user1.address);

      // æ–° minter å¼€å§‹å·¥ä½œ
      await token.connect(user1).mint(user1.address, 1000);
      expect(await token.balanceOf(user1.address)).to.equal(1000);
    });
  });

  // ===== è¾¹ç•Œæ¡ä»¶æµ‹è¯• =====
  describe("Edge Cases", function () {
    it("Should handle same address for multiple roles", async function () {
      const { token, owner, user1 } = await loadFixture(deployFixture);

      // Owner å°†æ‰€æœ‰è§’è‰²è®¾ç½®ä¸ºåŒä¸€ä¸ªåœ°å€
      await token.connect(owner).setMinter(user1.address);
      await token.connect(owner).setPauser(user1.address);

      // user1 ç°åœ¨å¯ä»¥é“¸é€ å’Œæš‚åœ
      await token.connect(user1).mint(user1.address, 1000);
      await token.connect(user1).pause();

      expect(await token.balanceOf(user1.address)).to.equal(1000);
      expect(await token.paused()).to.be.true;
    });
  });
});
```

**è¿è¡Œè¾“å‡ºç¤ºä¾‹ï¼š**

```
$ npx hardhat test test/RoleBasedToken.test.js

  RoleBasedToken
    Deployment
      âœ” Should set the correct owner
      âœ” Should set the correct minter
      âœ” Should set the correct pauser
    Owner Functions
      âœ” Should allow owner to change minter
      âœ” Should prevent non-owner from changing minter
      âœ” Should prevent attacker from changing roles
    Minter Functions
      âœ” Should allow minter to mint tokens
      âœ” Should prevent non-minter from minting
      âœ” Should prevent attacker from minting
    Pauser Functions
      âœ” Should allow pauser to pause
      âœ” Should allow pauser to unpause
      âœ” Should prevent non-pauser from pausing
    Pause Effect
      âœ” Should prevent minting when paused
      âœ” Should prevent transfer when paused
      âœ” Should allow transfer after unpause
    Multi-User Interactions
      âœ” Should handle complex role interactions
      âœ” Should correctly handle role transitions
    Edge Cases
      âœ” Should handle same address for multiple roles

  18 passing (2s)
```

---

## 8. ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜1ï¼š"å¦‚ä½•åœ¨æµ‹è¯•ä¸­æ¨¡æ‹Ÿå¤šç”¨æˆ·åœºæ™¯ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"ç”¨ ethers.getSigners() è·å–å¤šä¸ªè´¦æˆ·ï¼Œç„¶åç”¨ connect åˆ‡æ¢ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **å¤šç”¨æˆ·æµ‹è¯•éœ€è¦ä»ä¸‰ä¸ªå±‚é¢è€ƒè™‘ï¼š**
>
> **1. è·å–æµ‹è¯•è´¦æˆ·**ï¼š
> ```javascript
> const [owner, admin, user1, user2, attacker] = await ethers.getSigners();
> // Hardhat é¢„ç½® 20 ä¸ªè´¦æˆ·ï¼Œæ¯ä¸ª 10000 ETH
> // å¯ä»¥è¯­ä¹‰åŒ–å‘½åï¼Œæé«˜å¯è¯»æ€§
> ```
>
> **2. åˆ‡æ¢è°ƒç”¨è€…**ï¼š
> ```javascript
> // æ–¹å¼1ï¼šé“¾å¼è°ƒç”¨
> await token.connect(user1).transfer(user2.address, 100);
>
> // æ–¹å¼2ï¼šåˆ›å»ºç»‘å®šå®ä¾‹ï¼ˆå¤šæ¬¡è°ƒç”¨æ—¶æ›´æ¸…æ™°ï¼‰
> const tokenAsUser1 = token.connect(user1);
> await tokenAsUser1.transfer(user2.address, 100);
> await tokenAsUser1.approve(spender, 1000);
> ```
>
> **3. è§’è‰²éš”ç¦»æµ‹è¯•**ï¼š
> ```javascript
> // æ­£å‘æµ‹è¯•ï¼šæ­£ç¡®è§’è‰²å¯ä»¥æ“ä½œ
> it("Admin can pause", async () => {
>   await contract.connect(admin).pause();
> });
>
> // è´Ÿå‘æµ‹è¯•ï¼šé”™è¯¯è§’è‰²ä¼šè¢«æ‹’ç»
> it("Non-admin cannot pause", async () => {
>   await expect(contract.connect(user1).pause())
>     .to.be.revertedWith("Not admin");
> });
> ```
>
> **4. Fork åœºæ™¯ä¸‹çš„çœŸå®è´¦æˆ·**ï¼š
> ```javascript
> // å†’å……ä¸»ç½‘å·¨é²¸
> await impersonateAccount(WHALE_ADDRESS);
> const whale = await ethers.getSigner(WHALE_ADDRESS);
> await token.connect(whale).transfer(recipient, 1000000n);
> ```
>
> **æœ€ä½³å®è·µ**ï¼š
> - åœ¨ fixture ä¸­è¯­ä¹‰åŒ–å‘½åè´¦æˆ·
> - æµ‹è¯•æ­£å‘å’Œè´Ÿå‘åœºæ™¯
> - ä½¿ç”¨ loadFixture ç¡®ä¿æµ‹è¯•ç‹¬ç«‹

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… åˆ†å±‚æ¬¡å›ç­”ï¼ˆè·å–ã€åˆ‡æ¢ã€æµ‹è¯•æ¨¡å¼ï¼‰
2. âœ… ç»™å‡ºäº†å¤šç§å®ç°æ–¹å¼
3. âœ… åŒ…å«äº† Fork åœºæ™¯
4. âœ… æåˆ°äº†æœ€ä½³å®è·µ

---

### é—®é¢˜2ï¼š"connect() å’Œç›´æ¥è°ƒç”¨æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"connect å¯ä»¥åˆ‡æ¢è°ƒç”¨è€…ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **åŒºåˆ«ä½“ç°åœ¨ä¸‰ä¸ªæ–¹é¢ï¼š**
>
> **1. è°ƒç”¨è€…èº«ä»½ï¼ˆmsg.senderï¼‰**ï¼š
> ```javascript
> const token = await Token.deploy();  // ç”¨ signers[0] éƒ¨ç½²
>
> await token.transfer(user, 100);
> // msg.sender = signers[0] (éƒ¨ç½²è€…)
>
> await token.connect(user1).transfer(user2, 100);
> // msg.sender = user1
> ```
>
> **2. äº¤æ˜“ç­¾åè€…**ï¼š
> - ç›´æ¥è°ƒç”¨ï¼šç”¨éƒ¨ç½²æ—¶çš„ signer ç­¾å
> - connect åè°ƒç”¨ï¼šç”¨æŒ‡å®šçš„ signer ç­¾å
> - é“¾ä¸Šä¼šéªŒè¯ç­¾åä¸ msg.sender åŒ¹é…
>
> **3. å®ä¾‹å…³ç³»**ï¼š
> ```javascript
> const tokenAsUser = token.connect(user);
>
> // connect è¿”å›æ–°å®ä¾‹ï¼Œä¸ä¿®æ”¹åŸå®ä¾‹
> token === tokenAsUser  // false
>
> // åŸå®ä¾‹çš„ signer ä¸å˜
> await token.owner();  // è¿˜æ˜¯ç”¨åŸ signer
> ```
>
> **å®é™…åº”ç”¨åœºæ™¯**ï¼š
> - **æƒé™æµ‹è¯•**ï¼šéªŒè¯ä¸åŒè§’è‰²çš„è®¿é—®æ§åˆ¶
> - **èµ„äº§æµè½¬**ï¼šæ¨¡æ‹Ÿ A â†’ B â†’ C çš„ä»£å¸æµåŠ¨
> - **æ”»å‡»æ¨¡æ‹Ÿ**ï¼šç”¨ attacker è´¦æˆ·å°è¯•éæ³•æ“ä½œ

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… ä» msg.senderã€ç­¾åã€å®ä¾‹ä¸‰ä¸ªç»´åº¦è§£é‡Š
2. âœ… ç»™å‡ºäº†ä»£ç å¯¹æ¯”
3. âœ… è§£é‡Šäº†ä¸å¯å˜æ€§
4. âœ… è”ç³»äº†å®é™…åº”ç”¨åœºæ™¯

---

## 9. ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼šä»€ä¹ˆæ˜¯ Signerï¼Ÿ ğŸ¯

**ä¸€å¥è¯ï¼š** Signer æ˜¯èƒ½å¤Ÿç­¾åäº¤æ˜“çš„ä»¥å¤ªåŠè´¦æˆ·å¯¹è±¡ï¼ŒåŒ…å«ç§é’¥ã€åœ°å€å’Œå‘é€äº¤æ˜“çš„èƒ½åŠ›ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
const [signer] = await ethers.getSigners();
console.log(signer.address);  // 0xf39Fd6e51...
await signer.sendTransaction({ to: recipient, value: 100 });
```

**åº”ç”¨ï¼š** æ™ºèƒ½åˆçº¦æµ‹è¯•éœ€è¦æ¨¡æ‹Ÿä¸åŒç”¨æˆ·ï¼Œæ¯ä¸ªç”¨æˆ·å¯¹åº”ä¸€ä¸ª Signerã€‚

---

### å¡ç‰‡2ï¼šè·å–é¢„ç½®è´¦æˆ· ğŸ“‹

**ä¸€å¥è¯ï¼š** `ethers.getSigners()` è¿”å› Hardhat é¢„ç½®çš„ 20 ä¸ªæµ‹è¯•è´¦æˆ·ï¼Œæ¯ä¸ªæœ‰ 10000 ETHã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
const signers = await ethers.getSigners();
console.log(signers.length);  // 20

const [owner, user1, user2] = await ethers.getSigners();
```

**åº”ç”¨ï¼š** è§£æ„èµ‹å€¼è·å–å¸¸ç”¨è´¦æˆ·ï¼Œè¯­ä¹‰åŒ–å‘½åæé«˜å¯è¯»æ€§ã€‚

---

### å¡ç‰‡3ï¼šåˆ‡æ¢è°ƒç”¨è€… ğŸ”—

**ä¸€å¥è¯ï¼š** `contract.connect(signer)` è¿”å›æ–°åˆçº¦å®ä¾‹ï¼Œåç»­è°ƒç”¨ä»¥è¯¥ signer èº«ä»½æ‰§è¡Œã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
// é»˜è®¤ owner è°ƒç”¨
await token.transfer(user, 100);

// user1 è°ƒç”¨
await token.connect(user1).transfer(user2, 50);
```

**åº”ç”¨ï¼š** æµ‹è¯•å¤šç”¨æˆ·äº¤äº’ã€æƒé™æ§åˆ¶ã€ä»£å¸è½¬è´¦ç­‰åœºæ™¯ã€‚

---

### å¡ç‰‡4ï¼šè·å–è´¦æˆ·åœ°å€ ğŸ“

**ä¸€å¥è¯ï¼š** `signer.address` è¿”å›è´¦æˆ·çš„ä»¥å¤ªåŠåœ°å€ï¼ˆ42 å­—ç¬¦çš„ 0x æ ¼å¼ï¼‰ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
const [owner] = await ethers.getSigners();
console.log(owner.address);  // 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266

// ç”¨äºéªŒè¯
expect(await token.owner()).to.equal(owner.address);
```

**åº”ç”¨ï¼š** æ–­è¨€ ownerã€æ£€æŸ¥ä½™é¢ã€ä½œä¸ºå‡½æ•°å‚æ•°ç­‰ã€‚

---

### å¡ç‰‡5ï¼šæƒé™æµ‹è¯•æ¨¡å¼ ğŸ”

**ä¸€å¥è¯ï¼š** æµ‹è¯•æƒé™æ§åˆ¶æ—¶ï¼Œæ­£å‘æµ‹è¯•"æ­£ç¡®è§’è‰²èƒ½æ“ä½œ"ï¼Œè´Ÿå‘æµ‹è¯•"é”™è¯¯è§’è‰²è¢«æ‹’ç»"ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
// æ­£å‘ï¼šadmin å¯ä»¥æš‚åœ
await contract.connect(admin).pause();

// è´Ÿå‘ï¼šæ™®é€šç”¨æˆ·ä¸èƒ½æš‚åœ
await expect(contract.connect(user).pause())
  .to.be.revertedWith("Not admin");
```

**åº”ç”¨ï¼š** ç¡®ä¿åˆçº¦æƒé™æ§åˆ¶æ­£ç¡®å®ç°ã€‚

---

### å¡ç‰‡6ï¼šå¤šç”¨æˆ·äº¤äº’æµ‹è¯• ğŸ‘¥

**ä¸€å¥è¯ï¼š** ä½¿ç”¨å¤šä¸ª signer æ¨¡æ‹ŸçœŸå®çš„å¤šæ–¹äº¤äº’åœºæ™¯ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
const [seller, buyer, platform] = await ethers.getSigners();

await marketplace.connect(seller).list(item, price);
await marketplace.connect(buyer).buy(item, { value: price });
await marketplace.connect(platform).settle(item);
```

**åº”ç”¨ï¼š** æµ‹è¯• DEX äº¤æ˜“ã€NFT ä¹°å–ã€å¤šç­¾é’±åŒ…ç­‰å¤æ‚åœºæ™¯ã€‚

---

### å¡ç‰‡7ï¼šconnect ä¸ä¿®æ”¹åŸå®ä¾‹ âš ï¸

**ä¸€å¥è¯ï¼š** `connect()` è¿”å›æ–°å®ä¾‹ï¼ŒåŸåˆçº¦å®ä¾‹çš„ signer ä¿æŒä¸å˜ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
const token = await Token.deploy();
const tokenAsUser = token.connect(user);

token.signer !== tokenAsUser.signer  // trueï¼ˆä¸åŒçš„ signerï¼‰
await token.transfer(a, 100);        // ä»ç”¨åŸ signerï¼ˆownerï¼‰
```

**åº”ç”¨ï¼š** æ³¨æ„ä¿å­˜ connect è¿”å›å€¼ï¼Œæˆ–ä½¿ç”¨é“¾å¼è°ƒç”¨ã€‚

---

### å¡ç‰‡8ï¼šimpersonateAccount å†’å……è´¦æˆ· ğŸ­

**ä¸€å¥è¯ï¼š** Fork ä¸»ç½‘æ—¶ï¼Œä½¿ç”¨ `impersonateAccount` å¯ä»¥å†’å……ä»»æ„åœ°å€å‘é€äº¤æ˜“ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
await impersonateAccount(WHALE_ADDRESS);
const whale = await ethers.getSigner(WHALE_ADDRESS);
await token.connect(whale).transfer(recipient, 1000000n);
```

**åº”ç”¨ï¼š** æµ‹è¯•ä¸ä¸»ç½‘å·¨é²¸äº¤äº’ã€æ¨¡æ‹Ÿæ²»ç†æŠ•ç¥¨ç­‰ã€‚

---

### å¡ç‰‡9ï¼šå›ºå®šè´¦æˆ·åœ°å€ ğŸ“Œ

**ä¸€å¥è¯ï¼š** Hardhat ä½¿ç”¨å›ºå®šåŠ©è®°è¯ï¼Œæ¯æ¬¡è¿è¡Œæµ‹è¯•è´¦æˆ·åœ°å€ç›¸åŒã€‚

**ä¸¾ä¾‹ï¼š**
```
Account #0: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
Account #1: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8
Account #2: 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC
```

**åº”ç”¨ï¼š** å¯ä»¥åœ¨æµ‹è¯•ä¸­ç¡¬ç¼–ç åœ°å€ï¼ˆè™½ç„¶ä¸æ¨èï¼‰ã€‚

---

### å¡ç‰‡10ï¼šæœ€ä½³å®è·µæ€»ç»“ ğŸ†

**ä¸€å¥è¯ï¼š** è¯­ä¹‰åŒ–å‘½åè´¦æˆ·ï¼Œæµ‹è¯•æ­£ååœºæ™¯ï¼Œä½¿ç”¨ loadFixture ç¡®ä¿ç‹¬ç«‹æ€§ã€‚

**æœ€ä½³å®è·µæ¸…å•ï¼š**
- âœ… è§£æ„æ—¶è¯­ä¹‰åŒ–å‘½åï¼ˆowner, admin, user1...ï¼‰
- âœ… åœ¨ fixture ä¸­è®¾ç½®è§’è‰²
- âœ… æµ‹è¯•æ­£ç¡®è§’è‰²å’Œé”™è¯¯è§’è‰²
- âœ… ä½¿ç”¨ loadFixture éš”ç¦»æµ‹è¯•
- âœ… é“¾å¼è°ƒç”¨æˆ–ä¿å­˜ connect è¿”å›å€¼

**åº”ç”¨ï¼š** éµå¾ªæœ€ä½³å®è·µè®©å¤šç”¨æˆ·æµ‹è¯•æ›´æ¸…æ™°ã€æ›´å¯é ã€‚

---

## 10. ã€ä¸€å¥è¯æ€»ç»“ã€‘

**`ethers.getSigners()` è¿”å› Hardhat é¢„ç½®çš„ 20 ä¸ªæµ‹è¯•è´¦æˆ·ï¼Œé€šè¿‡ `contract.connect(signer)` åˆ‡æ¢äº¤æ˜“ç­¾åè€…ï¼Œä»è€Œæ¨¡æ‹Ÿå¤šç”¨æˆ·äº¤äº’ã€æƒé™æ§åˆ¶ã€èµ„äº§æµè½¬ç­‰çœŸå®åœºæ™¯ï¼Œæ˜¯æ™ºèƒ½åˆçº¦æµ‹è¯•ä¸­éªŒè¯å¤šæ–¹é€»è¾‘çš„æ ¸å¿ƒæœºåˆ¶ã€‚**

---

## ğŸ“š é™„å½•

### å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆæœ¬çŸ¥è¯†ç‚¹å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] ä½¿ç”¨ `ethers.getSigners()` è·å–æµ‹è¯•è´¦æˆ·
- [ ] ä½¿ç”¨ `contract.connect(signer)` åˆ‡æ¢è°ƒç”¨è€…
- [ ] æµ‹è¯•æƒé™æ§åˆ¶ï¼ˆæ­£å‘å’Œè´Ÿå‘ï¼‰
- [ ] æ¨¡æ‹Ÿå¤šç”¨æˆ·äº¤äº’åœºæ™¯
- [ ] ç†è§£ connect çš„ä¸å¯å˜æ€§
- [ ] ä½¿ç”¨ impersonateAccount å†’å……ä¸»ç½‘è´¦æˆ·
- [ ] è¯­ä¹‰åŒ–å‘½åæµ‹è¯•è´¦æˆ·

### å¿«é€Ÿå‚è€ƒå¡

**å¸¸ç”¨ä»£ç ï¼š**

```javascript
// è·å–ç­¾åè€…
const [owner, admin, user1, user2] = await ethers.getSigners();

// åˆ‡æ¢è°ƒç”¨è€…
await token.connect(user1).transfer(user2.address, 100);

// éªŒè¯æƒé™
await expect(token.connect(user1).mint(100))
  .to.be.revertedWith("Not owner");

// è·å–åœ°å€
const ownerAddress = owner.address;

// å†’å……è´¦æˆ·
await impersonateAccount(address);
const impersonated = await ethers.getSigner(address);
```

### ä¸‹ä¸€æ­¥å­¦ä¹ 

æ¨èæŒ‰ä»¥ä¸‹é¡ºåºç»§ç»­å­¦ä¹ ï¼š

1. **æ¨¡æ‹Ÿæ—¶é—´æµé€** - æµ‹è¯•æ—¶é—´é”å’Œé”ä»“é€»è¾‘
2. **Fork ä¸»ç½‘æµ‹è¯•** - æµ‹è¯•ä¸çœŸå® DeFi åè®®é›†æˆ
3. **é«˜çº§æƒé™æ¨¡å¼** - OpenZeppelin AccessControl

### å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£ï¼š**
- [Hardhat Network Accounts](https://hardhat.org/hardhat-network/docs/reference#accounts)
- [ethers.js Signers](https://docs.ethers.org/v6/api/providers/#Signer)

**å·¥å…·ï¼š**
- [Hardhat Network Helpers](https://hardhat.org/hardhat-network-helpers/docs/reference)

---

**ç‰ˆæœ¬ï¼š** v1.0
**åˆ›å»ºæ—¥æœŸï¼š** 2025-12-08
**ä½œè€…ï¼š** Droid
**é€‚ç”¨äººç¾¤ï¼š** å‰ç«¯å·¥ç¨‹å¸ˆè½¬ Web3 å¼€å‘
