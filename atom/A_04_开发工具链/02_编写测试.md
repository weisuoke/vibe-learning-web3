# å¼€å‘å·¥å…·é“¾ - ç¼–å†™æµ‹è¯•

## 1. ã€30å­—æ ¸å¿ƒã€‘

**Hardhat æµ‹è¯•ä½¿ç”¨ Mocha/Chai æ¡†æ¶ï¼Œé€šè¿‡ ethers.js ä¸åˆçº¦äº¤äº’ï¼ŒéªŒè¯åˆçº¦é€»è¾‘æ­£ç¡®æ€§ï¼Œæ˜¯æ™ºèƒ½åˆçº¦å¼€å‘çš„è´¨é‡ä¿éšœã€‚**

---

## 2. ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### æ™ºèƒ½åˆçº¦æµ‹è¯•çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**æ™ºèƒ½åˆçº¦æµ‹è¯• = åœ¨å—æ§ç¯å¢ƒä¸­éªŒè¯åˆçº¦è¡Œä¸ºæ˜¯å¦ç¬¦åˆé¢„æœŸ**

ä»…æ­¤è€Œå·²ï¼æ²¡æœ‰æ›´åŸºç¡€çš„äº†ã€‚

#### 2. ä¸ºä»€ä¹ˆéœ€è¦æµ‹è¯•ï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šæ™ºèƒ½åˆçº¦ä¸€æ—¦éƒ¨ç½²å°±ä¸å¯ä¿®æ”¹ï¼Œå¦‚ä½•ç¡®ä¿ä»£ç æ²¡æœ‰ bugï¼Ÿ**

æ™ºèƒ½åˆçº¦çš„ç‰¹æ®Šæ€§ï¼š
- **ä¸å¯ä¿®æ”¹**ï¼šéƒ¨ç½²åä»£ç æ°¸ä¹…å›ºå®šï¼ˆé™¤éä½¿ç”¨ä»£ç†æ¨¡å¼ï¼‰
- **èµ„é‡‘é£é™©**ï¼šbug å¯èƒ½å¯¼è‡´èµ„é‡‘æ°¸ä¹…ä¸¢å¤±
- **å…¬å¼€é€æ˜**ï¼šä»»ä½•äººéƒ½å¯ä»¥è°ƒç”¨ï¼Œæ”»å‡»è€…å¯ä»¥æ‰¾æ¼æ´
- **Gas æˆæœ¬**ï¼šæ¯æ¬¡éƒ¨ç½²å’Œæµ‹è¯•éƒ½æœ‰æˆæœ¬

#### 3. æµ‹è¯•çš„ä¸‰å±‚ä»·å€¼

##### ä»·å€¼1ï¼šå‘ç° Bugï¼ˆåŠŸèƒ½éªŒè¯ï¼‰

**é—®é¢˜**ï¼šå¤æ‚çš„åˆçº¦é€»è¾‘å¯èƒ½æœ‰è¾¹ç•Œæ¡ä»¶é”™è¯¯ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼šç¼–å†™æµ‹è¯•ç”¨ä¾‹è¦†ç›–å„ç§åœºæ™¯ã€‚

**ç¤ºä¾‹**ï¼š
```javascript
// æµ‹è¯• ERC20 è½¬è´¦çš„è¾¹ç•Œæ¡ä»¶
it("Should fail if sender has 0 balance", async function () {
  await expect(
    token.connect(user1).transfer(user2.address, 100)
  ).to.be.revertedWith("Insufficient balance");
});

it("Should allow transfer of entire balance", async function () {
  const balance = await token.balanceOf(owner.address);
  await token.transfer(user1.address, balance);
  expect(await token.balanceOf(owner.address)).to.equal(0);
});
```

##### ä»·å€¼2ï¼šé˜²æ­¢å›å½’ï¼ˆé‡æ„ä¿éšœï¼‰

**é—®é¢˜**ï¼šä¿®æ”¹ä»£ç åå¯èƒ½ç ´ååŸæœ‰åŠŸèƒ½ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼šæŒç»­è¿è¡Œæµ‹è¯•ï¼Œç¡®ä¿ä¿®æ”¹ä¸ç ´åç°æœ‰é€»è¾‘ã€‚

**ç¤ºä¾‹**ï¼š
```bash
# æ¯æ¬¡ä¿®æ”¹åè¿è¡Œæµ‹è¯•
npx hardhat test

# CI/CD è‡ªåŠ¨åŒ–æµ‹è¯•
# .github/workflows/test.yml
# on: [push, pull_request]
# jobs:
#   test:
#     runs-on: ubuntu-latest
#     steps:
#       - run: npm test
```

##### ä»·å€¼3ï¼šæ–‡æ¡£ä½œç”¨ï¼ˆè¡Œä¸ºè¯´æ˜ï¼‰

**é—®é¢˜**ï¼šåˆçº¦åŠŸèƒ½ä¸æ¸…æ™°ï¼Œæ–°æˆå‘˜éš¾ä»¥ç†è§£ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼šæµ‹è¯•ç”¨ä¾‹å°±æ˜¯æœ€å¥½çš„æ–‡æ¡£ï¼Œæè¿°é¢„æœŸè¡Œä¸ºã€‚

**ç¤ºä¾‹**ï¼š
```javascript
describe("Token Transfer", function () {
  it("Should transfer tokens between accounts", ...);
  it("Should emit Transfer event on successful transfer", ...);
  it("Should fail when sender has insufficient balance", ...);
  it("Should update both sender and recipient balances", ...);
});
// é˜…è¯»æµ‹è¯•å°±èƒ½ç†è§£è½¬è´¦åŠŸèƒ½çš„æ‰€æœ‰è¡Œä¸º
```

#### 4. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼æµ‹è¯•å®ç°

**æ¨ç†é“¾ï¼š**

```
1. å‰æï¼šéœ€è¦éªŒè¯æ™ºèƒ½åˆçº¦è¡Œä¸ºæ­£ç¡®
   â†“
2. æ¨å¯¼ï¼šéœ€è¦ä¸€ä¸ªå¯æ§çš„æ‰§è¡Œç¯å¢ƒ â†’ Hardhat Networkï¼ˆæœ¬åœ°æµ‹è¯•ç½‘ï¼‰
   â†“
3. æ¨å¯¼ï¼šéœ€è¦ä¸åˆçº¦äº¤äº’çš„å·¥å…· â†’ ethers.jsï¼ˆåˆçº¦è°ƒç”¨åº“ï¼‰
   â†“
4. æ¨å¯¼ï¼šéœ€è¦ç»„ç»‡æµ‹è¯•ç»“æ„ â†’ Mochaï¼ˆæµ‹è¯•æ¡†æ¶ï¼šdescribe/itï¼‰
   â†“
5. æ¨å¯¼ï¼šéœ€è¦æ–­è¨€ç»“æœ â†’ Chaiï¼ˆæ–­è¨€åº“ï¼šexpectï¼‰
   â†“
6. æ¨å¯¼ï¼šéœ€è¦éªŒè¯é“¾ä¸Šç‰¹æ€§ â†’ Hardhat Chai Matchersï¼ˆäº‹ä»¶ã€revertï¼‰
   â†“
7. æ¨å¯¼ï¼šéœ€è¦ä¼˜åŒ–æµ‹è¯•æ€§èƒ½ â†’ loadFixtureï¼ˆå¿«ç…§æ¢å¤ï¼‰
   â†“
8. æœ€ç»ˆå®ç°ï¼šå®Œæ•´çš„æ™ºèƒ½åˆçº¦æµ‹è¯•æ¡†æ¶
```

#### 5. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**æ™ºèƒ½åˆçº¦æµ‹è¯•çš„æœ¬è´¨æ˜¯åœ¨éƒ¨ç½²å‰æ¨¡æ‹Ÿæ‰€æœ‰å¯èƒ½çš„ä½¿ç”¨åœºæ™¯ï¼Œç¡®ä¿åˆçº¦åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½è¡¨ç°æ­£ç¡®ï¼Œå› ä¸ºéƒ¨ç½²åæ— æ³•ä¿®æ”¹ã€‚**

---

## 3. ã€3ä¸ªæ ¸å¿ƒæ¦‚å¿µã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼šMocha æµ‹è¯•ç»“æ„ï¼ˆdescribe/itï¼‰ğŸ“‹

**ä¸€å¥è¯å®šä¹‰ï¼š** Mocha æ˜¯ JavaScript æµ‹è¯•æ¡†æ¶ï¼Œä½¿ç”¨ `describe` ç»„ç»‡æµ‹è¯•å¥—ä»¶ï¼Œ`it` å®šä¹‰å•ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

// describeï¼šå®šä¹‰æµ‹è¯•å¥—ä»¶ï¼ˆå¯åµŒå¥—ï¼‰
describe("MyToken", function () {
  
  // åµŒå¥— describeï¼šåˆ†ç»„ç›¸å…³æµ‹è¯•
  describe("Deployment", function () {
    // itï¼šå•ä¸ªæµ‹è¯•ç”¨ä¾‹
    it("Should set the right owner", async function () {
      // æµ‹è¯•é€»è¾‘
    });

    it("Should assign total supply to owner", async function () {
      // æµ‹è¯•é€»è¾‘
    });
  });

  describe("Transfers", function () {
    it("Should transfer tokens", async function () {
      // æµ‹è¯•é€»è¾‘
    });

    it("Should fail on insufficient balance", async function () {
      // æµ‹è¯•é€»è¾‘
    });
  });
});
```

**Mocha ç”Ÿå‘½å‘¨æœŸé’©å­ï¼š**

```javascript
describe("Token", function () {
  // åœ¨æ‰€æœ‰æµ‹è¯•å‰æ‰§è¡Œä¸€æ¬¡
  before(async function () {
    console.log("Setup: runs once before all tests");
  });

  // åœ¨æ¯ä¸ªæµ‹è¯•å‰æ‰§è¡Œ
  beforeEach(async function () {
    console.log("Runs before each test");
    // å¸¸ç”¨äºéƒ¨ç½²åˆçº¦
  });

  // åœ¨æ¯ä¸ªæµ‹è¯•åæ‰§è¡Œ
  afterEach(async function () {
    console.log("Runs after each test");
  });

  // åœ¨æ‰€æœ‰æµ‹è¯•åæ‰§è¡Œä¸€æ¬¡
  after(async function () {
    console.log("Cleanup: runs once after all tests");
  });

  it("Test 1", async function () { /* ... */ });
  it("Test 2", async function () { /* ... */ });
});
```

**è¯¦ç»†è§£é‡Šï¼š**

- `describe`ï¼šåˆ†ç»„æµ‹è¯•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æè¿°ï¼Œç¬¬äºŒä¸ªæ˜¯åŒ…å«æµ‹è¯•çš„å‡½æ•°
- `it`ï¼šå•ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæè¿°é¢„æœŸè¡Œä¸º
- `async function`ï¼šæ™ºèƒ½åˆçº¦æµ‹è¯•å‡ ä¹éƒ½æ˜¯å¼‚æ­¥çš„
- é’©å­ï¼š`before`/`beforeEach`/`afterEach`/`after` ç”¨äºè®¾ç½®å’Œæ¸…ç†

**åœ¨æ™ºèƒ½åˆçº¦æµ‹è¯•ä¸­çš„åº”ç”¨ï¼š**

```javascript
describe("ERC20 Token", function () {
  let token, owner, user1, user2;

  beforeEach(async function () {
    // æ¯ä¸ªæµ‹è¯•å‰é‡æ–°éƒ¨ç½²åˆçº¦ï¼Œç¡®ä¿æµ‹è¯•ç‹¬ç«‹
    [owner, user1, user2] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MyToken");
    token = await Token.deploy(1000000);
  });

  describe("Transfer", function () {
    it("Should transfer tokens", async function () {
      await token.transfer(user1.address, 100);
      expect(await token.balanceOf(user1.address)).to.equal(100);
    });
  });
});
```

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šChai æ–­è¨€ï¼ˆexpectï¼‰âœ…

**ä¸€å¥è¯å®šä¹‰ï¼š** Chai æ˜¯æ–­è¨€åº“ï¼Œä½¿ç”¨ `expect` éªŒè¯å®é™…å€¼ä¸é¢„æœŸå€¼æ˜¯å¦åŒ¹é…ï¼ŒHardhat æ‰©å±•äº† Chai ä»¥æ”¯æŒé“¾ä¸Šç‰¹æ€§ã€‚

```javascript
const { expect } = require("chai");

// ===== åŸºç¡€æ–­è¨€ =====
expect(42).to.equal(42);                    // ç›¸ç­‰
expect("hello").to.not.equal("world");      // ä¸ç›¸ç­‰
expect(100).to.be.gt(50);                   // å¤§äº
expect(100).to.be.lt(200);                  // å°äº
expect(100).to.be.gte(100);                 // å¤§äºç­‰äº
expect(100).to.be.lte(100);                 // å°äºç­‰äº
expect(true).to.be.true;                    // å¸ƒå°”çœŸ
expect(false).to.be.false;                  // å¸ƒå°”å‡
expect([1, 2, 3]).to.include(2);            // åŒ…å«
expect({ a: 1 }).to.have.property("a");     // æœ‰å±æ€§

// ===== BigInt æ–­è¨€ï¼ˆæ™ºèƒ½åˆçº¦å¸¸ç”¨ï¼‰=====
const balance = await token.balanceOf(user.address);
expect(balance).to.equal(ethers.parseEther("100"));
expect(balance).to.be.gt(0n);  // BigInt æ¯”è¾ƒ

// ===== Hardhat æ‰©å±•æ–­è¨€ =====

// 1. éªŒè¯äº‹ä»¶è§¦å‘
await expect(token.transfer(user1.address, 100))
  .to.emit(token, "Transfer")
  .withArgs(owner.address, user1.address, 100);

// 2. éªŒè¯äº¤æ˜“å›æ»š
await expect(token.transfer(user1.address, 1000000000))
  .to.be.revertedWith("Insufficient balance");

// 3. éªŒè¯è‡ªå®šä¹‰é”™è¯¯å›æ»š
await expect(token.transfer(ethers.ZeroAddress, 100))
  .to.be.revertedWithCustomError(token, "InvalidAddress");

// 4. éªŒè¯ Panic é”™è¯¯ï¼ˆå¦‚æº¢å‡ºï¼‰
await expect(token.overflow())
  .to.be.revertedWithPanic(0x11);  // 0x11 = ç®—æœ¯æº¢å‡º

// 5. éªŒè¯ä½™é¢å˜åŒ–
await expect(token.transfer(user1.address, 100))
  .to.changeTokenBalance(token, user1, 100);

// 6. éªŒè¯ ETH ä½™é¢å˜åŒ–
await expect(contract.withdraw())
  .to.changeEtherBalance(owner, ethers.parseEther("1"));
```

**è¯¦ç»†è§£é‡Šï¼š**

Hardhat Chai Matchers æä¾›äº†æ™ºèƒ½åˆçº¦ä¸“ç”¨çš„æ–­è¨€ï¼š

| æ–­è¨€ | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| `emit` | éªŒè¯äº‹ä»¶ | `.to.emit(contract, "EventName")` |
| `revertedWith` | éªŒè¯é”™è¯¯æ¶ˆæ¯ | `.to.be.revertedWith("error message")` |
| `revertedWithCustomError` | éªŒè¯è‡ªå®šä¹‰é”™è¯¯ | `.to.be.revertedWithCustomError(contract, "ErrorName")` |
| `changeTokenBalance` | éªŒè¯ä»£å¸ä½™é¢å˜åŒ– | `.to.changeTokenBalance(token, addr, amount)` |
| `changeEtherBalance` | éªŒè¯ ETH ä½™é¢å˜åŒ– | `.to.changeEtherBalance(addr, amount)` |

**åœ¨æ™ºèƒ½åˆçº¦æµ‹è¯•ä¸­çš„åº”ç”¨ï¼š**

```javascript
describe("Token Transfers", function () {
  it("Should emit Transfer event", async function () {
    await expect(token.transfer(user1.address, 100))
      .to.emit(token, "Transfer")
      .withArgs(owner.address, user1.address, 100);
  });

  it("Should revert on zero address", async function () {
    await expect(token.transfer(ethers.ZeroAddress, 100))
      .to.be.revertedWith("Transfer to zero address");
  });

  it("Should change balances correctly", async function () {
    await expect(token.transfer(user1.address, 100))
      .to.changeTokenBalances(token, [owner, user1], [-100, 100]);
  });
});
```

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼šloadFixtureï¼ˆæµ‹è¯•å¿«ç…§ï¼‰ğŸ“¸

**ä¸€å¥è¯å®šä¹‰ï¼š** `loadFixture` æ˜¯ Hardhat çš„æµ‹è¯•ä¼˜åŒ–å·¥å…·ï¼Œé€šè¿‡å¿«ç…§æœºåˆ¶å¤ç”¨éƒ¨ç½²çŠ¶æ€ï¼Œå¤§å¹…æå‡æµ‹è¯•é€Ÿåº¦ã€‚

```javascript
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("MyToken", function () {
  // å®šä¹‰ fixture å‡½æ•°ï¼ˆéƒ¨ç½²é€»è¾‘ï¼‰
  async function deployTokenFixture() {
    const [owner, user1, user2] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MyToken");
    const token = await Token.deploy(1000000);
    
    // è¿”å›æ‰€æœ‰éœ€è¦çš„å˜é‡
    return { token, owner, user1, user2 };
  }

  // æ¯ä¸ªæµ‹è¯•ä½¿ç”¨ loadFixture è·å–å¹²å‡€çŠ¶æ€
  it("Should deploy with correct supply", async function () {
    const { token, owner } = await loadFixture(deployTokenFixture);
    expect(await token.totalSupply()).to.equal(1000000);
  });

  it("Should transfer tokens", async function () {
    const { token, owner, user1 } = await loadFixture(deployTokenFixture);
    await token.transfer(user1.address, 100);
    expect(await token.balanceOf(user1.address)).to.equal(100);
  });

  it("Should not affect other tests", async function () {
    // è¿™ä¸ªæµ‹è¯•è·å¾—çš„æ˜¯å¹²å‡€çš„åˆå§‹çŠ¶æ€
    // ä¸Šä¸€ä¸ªæµ‹è¯•çš„ transfer ä¸ä¼šå½±å“è¿™é‡Œ
    const { token, user1 } = await loadFixture(deployTokenFixture);
    expect(await token.balanceOf(user1.address)).to.equal(0); // ä»ç„¶æ˜¯ 0
  });
});
```

**è¯¦ç»†è§£é‡Šï¼š**

`loadFixture` çš„å·¥ä½œåŸç†ï¼š

1. **é¦–æ¬¡è°ƒç”¨**ï¼šæ‰§è¡Œ fixture å‡½æ•°ï¼Œéƒ¨ç½²åˆçº¦ï¼Œä¿å­˜åŒºå—é“¾å¿«ç…§
2. **åç»­è°ƒç”¨**ï¼šä¸é‡æ–°æ‰§è¡Œéƒ¨ç½²ï¼Œç›´æ¥æ¢å¤åˆ°å¿«ç…§çŠ¶æ€
3. **æ€§èƒ½æå‡**ï¼šN ä¸ªæµ‹è¯•åªéœ€ 1 æ¬¡éƒ¨ç½²ï¼Œè€Œé N æ¬¡

**å¯¹æ¯” beforeEachï¼š**

```javascript
// âŒ ä¼ ç»Ÿæ–¹å¼ï¼šæ¯ä¸ªæµ‹è¯•éƒ½é‡æ–°éƒ¨ç½²
describe("Token", function () {
  let token, owner;
  
  beforeEach(async function () {
    [owner] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MyToken");
    token = await Token.deploy(1000000);
    // æ¯ä¸ªæµ‹è¯•éƒ½ä¼šæ‰§è¡Œè¿™æ®µä»£ç ï¼
  });
  
  it("Test 1", ...);  // éƒ¨ç½²ä¸€æ¬¡
  it("Test 2", ...);  // åˆéƒ¨ç½²ä¸€æ¬¡
  it("Test 3", ...);  // åˆéƒ¨ç½²ä¸€æ¬¡
});

// âœ… ä½¿ç”¨ loadFixtureï¼šåªéƒ¨ç½²ä¸€æ¬¡ï¼Œå¿«ç…§æ¢å¤
describe("Token", function () {
  async function deployFixture() {
    const [owner] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MyToken");
    const token = await Token.deploy(1000000);
    return { token, owner };
  }

  it("Test 1", async function () {
    const { token } = await loadFixture(deployFixture);  // éƒ¨ç½²
  });
  it("Test 2", async function () {
    const { token } = await loadFixture(deployFixture);  // æ¢å¤å¿«ç…§
  });
  it("Test 3", async function () {
    const { token } = await loadFixture(deployFixture);  // æ¢å¤å¿«ç…§
  });
});
```

**åœ¨æ™ºèƒ½åˆçº¦æµ‹è¯•ä¸­çš„åº”ç”¨ï¼š**

```javascript
// å¤æ‚åœºæ™¯ï¼šå¤šä¸ª fixture ç»„åˆ
async function deployTokenFixture() {
  const [owner, user1] = await ethers.getSigners();
  const Token = await ethers.getContractFactory("MyToken");
  const token = await Token.deploy(1000000);
  return { token, owner, user1 };
}

async function deployWithTransferFixture() {
  // å¯ä»¥å¤ç”¨å…¶ä»– fixture
  const { token, owner, user1 } = await deployTokenFixture();
  await token.transfer(user1.address, 500);  // é¢„è®¾è½¬è´¦
  return { token, owner, user1 };
}

describe("After Transfer", function () {
  it("Should have updated balances", async function () {
    const { token, user1 } = await loadFixture(deployWithTransferFixture);
    expect(await token.balanceOf(user1.address)).to.equal(500);
  });
});
```

---

## 4. ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹å†…å®¹ï¼Œå°±èƒ½ç¼–å†™æ™ºèƒ½åˆçº¦æµ‹è¯•ï¼š

### 4.1 åŸºç¡€æµ‹è¯•ç»“æ„

```javascript
// test/MyToken.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

describe("MyToken", function () {
  async function deployFixture() {
    const [owner, user1, user2] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MyToken");
    const token = await Token.deploy(1000000);
    return { token, owner, user1, user2 };
  }

  it("Should have correct name", async function () {
    const { token } = await loadFixture(deployFixture);
    expect(await token.name()).to.equal("MyToken");
  });
});
```

### 4.2 å¸¸ç”¨æ–­è¨€

```javascript
// å€¼ç›¸ç­‰
expect(await token.totalSupply()).to.equal(1000000);

// å¤§äº/å°äº
expect(balance).to.be.gt(0);
expect(balance).to.be.lt(1000000);

// äº‹ä»¶è§¦å‘
await expect(token.transfer(user1.address, 100))
  .to.emit(token, "Transfer");

// äº¤æ˜“å›æ»š
await expect(token.transfer(user1.address, 999999999))
  .to.be.revertedWith("Insufficient balance");

// ä½™é¢å˜åŒ–
await expect(token.transfer(user1.address, 100))
  .to.changeTokenBalance(token, user1, 100);
```

### 4.3 è·å–ç­¾åè€…

```javascript
// è·å–æµ‹è¯•è´¦æˆ·
const [owner, user1, user2] = await ethers.getSigners();

// ç”¨ä¸åŒè´¦æˆ·è°ƒç”¨åˆçº¦
await token.transfer(user1.address, 100);           // owner è°ƒç”¨
await token.connect(user1).transfer(user2.address, 50);  // user1 è°ƒç”¨
```

### 4.4 è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
npx hardhat test

# è¿è¡Œç‰¹å®šæ–‡ä»¶
npx hardhat test test/MyToken.test.js

# è¿è¡ŒåŒ¹é…çš„æµ‹è¯•
npx hardhat test --grep "transfer"

# æ˜¾ç¤º Gas æŠ¥å‘Š
REPORT_GAS=true npx hardhat test

# æ˜¾ç¤ºè¯¦ç»†è¾“å‡º
npx hardhat test --verbose
```

### 4.5 å®Œæ•´æµ‹è¯•ç¤ºä¾‹

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

describe("SimpleToken", function () {
  const INITIAL_SUPPLY = 1000000n;

  async function deployFixture() {
    const [owner, user1, user2] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("SimpleToken");
    const token = await Token.deploy(INITIAL_SUPPLY);
    return { token, owner, user1, user2 };
  }

  describe("Deployment", function () {
    it("Should set correct name and symbol", async function () {
      const { token } = await loadFixture(deployFixture);
      expect(await token.name()).to.equal("SimpleToken");
      expect(await token.symbol()).to.equal("STK");
    });

    it("Should assign total supply to owner", async function () {
      const { token, owner } = await loadFixture(deployFixture);
      expect(await token.balanceOf(owner.address)).to.equal(INITIAL_SUPPLY);
    });
  });

  describe("Transfer", function () {
    it("Should transfer tokens", async function () {
      const { token, owner, user1 } = await loadFixture(deployFixture);
      await token.transfer(user1.address, 100n);
      expect(await token.balanceOf(user1.address)).to.equal(100n);
      expect(await token.balanceOf(owner.address)).to.equal(INITIAL_SUPPLY - 100n);
    });

    it("Should emit Transfer event", async function () {
      const { token, owner, user1 } = await loadFixture(deployFixture);
      await expect(token.transfer(user1.address, 100n))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, user1.address, 100n);
    });

    it("Should fail on insufficient balance", async function () {
      const { token, user1, user2 } = await loadFixture(deployFixture);
      await expect(token.connect(user1).transfer(user2.address, 100n))
        .to.be.revertedWith("Insufficient balance");
    });
  });
});
```

---

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- âœ… ä½¿ç”¨ describe/it ç»„ç»‡æµ‹è¯•
- âœ… ä½¿ç”¨ expect æ–­è¨€éªŒè¯ç»“æœ
- âœ… ä½¿ç”¨ loadFixture ä¼˜åŒ–æµ‹è¯•æ€§èƒ½
- âœ… éªŒè¯äº‹ä»¶å’Œå›æ»š
- âœ… æµ‹è¯•å¤šè´¦æˆ·äº¤äº’åœºæ™¯

---

## 5. ã€1ä¸ªç±»æ¯”ã€‘

### ç±»æ¯”1ï¼šæµ‹è¯•ç»“æ„ ğŸ§ª

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šæ™ºèƒ½åˆçº¦æµ‹è¯• = æ–°äº§å“è´¨æ£€

æƒ³è±¡ä½ æ˜¯ä¸€å®¶æ‰‹æœºå·¥å‚çš„è´¨æ£€å‘˜ï¼š

**è´¨æ£€æµç¨‹ï¼š**
1. **åˆ†ç±»æ£€æµ‹**ï¼ˆdescribeï¼‰ï¼šå±å¹•æµ‹è¯•ã€ç”µæ± æµ‹è¯•ã€æŒ‰é”®æµ‹è¯•
2. **å•é¡¹æ£€æµ‹**ï¼ˆitï¼‰ï¼šå±å¹•äº®åº¦ã€å±å¹•è§¦æ§ã€å±å¹•è‰²å½©
3. **éªŒæ”¶æ ‡å‡†**ï¼ˆexpectï¼‰ï¼šäº®åº¦ > 500nitã€è§¦æ§å»¶è¿Ÿ < 50ms
4. **æ¯æ¬¡é‡ç½®**ï¼ˆloadFixtureï¼‰ï¼šæ¯ä¸ªæµ‹è¯•ç”¨å…¨æ–°æ‰‹æœº

```javascript
// æ‰‹æœºè´¨æ£€"æµ‹è¯•ä»£ç "
describe("æ‰‹æœºè´¨æ£€", function () {
  describe("å±å¹•æµ‹è¯•", function () {
    it("äº®åº¦åº”è¯¥å¤§äº 500nit", function () {
      expect(æµ‹é‡äº®åº¦()).to.be.gt(500);
    });
    it("è§¦æ§å»¶è¿Ÿåº”è¯¥å°äº 50ms", function () {
      expect(æµ‹é‡è§¦æ§å»¶è¿Ÿ()).to.be.lt(50);
    });
  });

  describe("ç”µæ± æµ‹è¯•", function () {
    it("å……ç”µåŠŸç‡åº”è¯¥è¾¾æ ‡", function () {
      expect(æµ‹é‡å……ç”µåŠŸç‡()).to.be.gte(65);
    });
  });
});
```

**å¯¹åº”å…³ç³»ï¼š**

| è´¨æ£€æ¦‚å¿µ | æµ‹è¯•æ¦‚å¿µ | è¯´æ˜ |
|---------|---------|------|
| è´¨æ£€åˆ†ç±» | describe | ç»„ç»‡ç›¸å…³æµ‹è¯• |
| å•é¡¹æ£€æµ‹ | it | å•ä¸ªæµ‹è¯•ç”¨ä¾‹ |
| éªŒæ”¶æ ‡å‡† | expect | æ–­è¨€é¢„æœŸç»“æœ |
| å…¨æ–°æ ·å“ | loadFixture | æ¯æ¬¡æµ‹è¯•å¹²å‡€çŠ¶æ€ |
| æ£€æµ‹æŠ¥å‘Š | æµ‹è¯•è¾“å‡º | é€šè¿‡/å¤±è´¥ç»“æœ |

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šHardhat æµ‹è¯• = Jest å•å…ƒæµ‹è¯•

å¦‚æœä½ ç†Ÿæ‚‰å‰ç«¯æµ‹è¯•ï¼ŒHardhat æµ‹è¯•ç»“æ„å‡ ä¹ç›¸åŒï¼š

```javascript
// Jestï¼ˆå‰ç«¯æµ‹è¯•ï¼‰
describe("Calculator", () => {
  let calculator;

  beforeEach(() => {
    calculator = new Calculator();
  });

  it("should add two numbers", () => {
    expect(calculator.add(2, 3)).toBe(5);
  });

  it("should throw on division by zero", () => {
    expect(() => calculator.divide(1, 0)).toThrow("Division by zero");
  });
});

// Hardhatï¼ˆæ™ºèƒ½åˆçº¦æµ‹è¯•ï¼‰
describe("Token", function () {
  async function deployFixture() {
    const Token = await ethers.getContractFactory("Token");
    const token = await Token.deploy(1000);
    return { token };
  }

  it("Should transfer tokens", async function () {
    const { token } = await loadFixture(deployFixture);
    expect(await token.balanceOf(user)).to.equal(0);
  });

  it("Should revert on insufficient balance", async function () {
    const { token } = await loadFixture(deployFixture);
    await expect(token.transfer(user, 9999)).to.be.revertedWith("Insufficient");
  });
});
```

**å¯¹æ¯”è¡¨ï¼š**

| æ¦‚å¿µ | Jest (å‰ç«¯) | Hardhat (æ™ºèƒ½åˆçº¦) |
|------|------------|-------------------|
| æµ‹è¯•å¥—ä»¶ | `describe()` | `describe()` |
| æµ‹è¯•ç”¨ä¾‹ | `it()` / `test()` | `it()` |
| æ–­è¨€ | `expect().toBe()` | `expect().to.equal()` |
| è®¾ç½® | `beforeEach()` | `loadFixture()` |
| å¼‚å¸¸æµ‹è¯• | `expect().toThrow()` | `expect().to.be.revertedWith()` |
| å¼‚æ­¥ | `async/await` å¯é€‰ | `async/await` å¿…é¡» |
| è¿è¡Œ | `npm test` | `npx hardhat test` |

**ä»£ç å¯¹æ¯”ï¼š**

```javascript
// å‰ç«¯ï¼šæµ‹è¯• API è°ƒç”¨
describe("UserService", () => {
  it("should fetch user", async () => {
    const user = await userService.getUser(1);
    expect(user.name).toBe("Alice");
  });

  it("should throw on user not found", async () => {
    await expect(userService.getUser(999)).rejects.toThrow("Not found");
  });
});

// æ™ºèƒ½åˆçº¦ï¼šæµ‹è¯•åˆçº¦è°ƒç”¨
describe("UserRegistry", function () {
  it("Should register user", async function () {
    await registry.register("Alice");
    expect(await registry.getUser(owner.address)).to.equal("Alice");
  });

  it("Should revert on duplicate registration", async function () {
    await registry.register("Alice");
    await expect(registry.register("Bob")).to.be.revertedWith("Already registered");
  });
});
```

---

### ç±»æ¯”2ï¼šæ–­è¨€æ–¹å¼ âœ“

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šexpect æ–­è¨€ = è€ƒè¯•è¯„åˆ†

æƒ³è±¡ä½ æ˜¯è€å¸ˆåœ¨æ‰¹æ”¹è¯•å·ï¼š

**è¯„åˆ†è¿‡ç¨‹ï¼š**
- å­¦ç”Ÿç­”æ¡ˆï¼š`3 + 5 = 8`
- æ ‡å‡†ç­”æ¡ˆï¼š`8`
- åˆ¤æ–­ï¼š`å­¦ç”Ÿç­”æ¡ˆ === æ ‡å‡†ç­”æ¡ˆ ? âœ“ : âœ—`

```javascript
// æ‰¹æ”¹è¯•å·"ä»£ç "
describe("æ•°å­¦è€ƒè¯•", function () {
  it("3 + 5 åº”è¯¥ç­‰äº 8", function () {
    const å­¦ç”Ÿç­”æ¡ˆ = è®¡ç®—(3, 5, "+");
    expect(å­¦ç”Ÿç­”æ¡ˆ).to.equal(8);  // âœ“ æ­£ç¡®
  });

  it("10 / 0 åº”è¯¥æŠ¥é”™", function () {
    expect(() => è®¡ç®—(10, 0, "/")).to.throw("ä¸èƒ½é™¤ä»¥é›¶");
  });
});
```

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šHardhat Chai = Jest Matchers

```javascript
// Jest Matchersï¼ˆå‰ç«¯ï¼‰
expect(value).toBe(expected);           // ä¸¥æ ¼ç›¸ç­‰
expect(value).toEqual(expected);        // æ·±åº¦ç›¸ç­‰
expect(value).toBeGreaterThan(n);       // å¤§äº
expect(fn).toThrow("error");            // æŠ›å‡ºå¼‚å¸¸
expect(fn).toHaveBeenCalled();          // å‡½æ•°è¢«è°ƒç”¨

// Chai Matchersï¼ˆæ™ºèƒ½åˆçº¦ï¼‰
expect(value).to.equal(expected);       // ç›¸ç­‰
expect(value).to.deep.equal(expected);  // æ·±åº¦ç›¸ç­‰
expect(value).to.be.gt(n);              // å¤§äº
await expect(tx).to.be.revertedWith("error");  // å›æ»š
await expect(tx).to.emit(contract, "Event");   // äº‹ä»¶è§¦å‘
```

---

### ç±»æ¯”3ï¼šloadFixture å¿«ç…§ ğŸ“¸

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šloadFixture = æ¸¸æˆå­˜æ¡£

æƒ³è±¡ä½ åœ¨ç©ä¸€ä¸ª RPG æ¸¸æˆï¼š

**ä¼ ç»Ÿæ–¹å¼ï¼ˆæ— å­˜æ¡£ï¼‰ï¼š**
- æµ‹è¯• Boss æˆ˜ â†’ ä»å¤´å¼€å§‹æ‰“åˆ° Boss
- æµ‹è¯•å¦ä¸€ä¸ªç­–ç•¥ â†’ åˆä»å¤´å¼€å§‹æ‰“åˆ° Boss
- é‡å¤ N æ¬¡ â†’ æµªè´¹ N å€æ—¶é—´

**ä½¿ç”¨å­˜æ¡£ï¼š**
- ç¬¬ä¸€æ¬¡æ‰“åˆ° Boss å‰ â†’ å­˜æ¡£
- æµ‹è¯•ç­–ç•¥ 1 â†’ è¯»æ¡£ï¼Œæ‰“ Boss
- æµ‹è¯•ç­–ç•¥ 2 â†’ è¯»æ¡£ï¼Œæ‰“ Boss
- åªéœ€æ‰“ä¸€æ¬¡åˆ° Boss ä½ç½®

```javascript
// æ¸¸æˆå­˜æ¡£"ä»£ç "
async function æ‰“åˆ°Bosså­˜æ¡£ç‚¹() {
  const è§’è‰² = åˆ›å»ºè§’è‰²();
  await æ‰“æ€ªå‡çº§åˆ°30çº§();
  await èµ°åˆ°Bossæˆ¿é—´();
  return { è§’è‰² };
}

describe("Bossæˆ˜æµ‹è¯•", function () {
  it("ç­–ç•¥1ï¼šå…¨åŠ›æ”»å‡»", async function () {
    const { è§’è‰² } = await loadFixture(æ‰“åˆ°Bosså­˜æ¡£ç‚¹);  // è¯»æ¡£
    await è§’è‰².å…¨åŠ›æ”»å‡»();
    expect(Boss.è¡€é‡).to.equal(0);
  });

  it("ç­–ç•¥2ï¼šé˜²å®ˆåå‡»", async function () {
    const { è§’è‰² } = await loadFixture(æ‰“åˆ°Bosså­˜æ¡£ç‚¹);  // è¯»æ¡£ï¼ˆä¸ç”¨é‡æ‰“ï¼‰
    await è§’è‰².é˜²å®ˆåå‡»();
    expect(Boss.è¡€é‡).to.equal(0);
  });
});
```

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šloadFixture = æ•°æ®åº“äº‹åŠ¡å›æ»š

```javascript
// åç«¯æµ‹è¯•ï¼šäº‹åŠ¡å›æ»š
describe("UserService", () => {
  beforeEach(async () => {
    await db.beginTransaction();  // å¼€å§‹äº‹åŠ¡
  });

  afterEach(async () => {
    await db.rollback();  // å›æ»šï¼Œæ¢å¤åˆå§‹çŠ¶æ€
  });

  it("Test 1", async () => {
    await db.insert({ name: "Alice" });
    // æµ‹è¯•ç»“æŸåè‡ªåŠ¨å›æ»š
  });

  it("Test 2", async () => {
    // è·å¾—å¹²å‡€çš„æ•°æ®åº“çŠ¶æ€
  });
});

// æ™ºèƒ½åˆçº¦æµ‹è¯•ï¼šå¿«ç…§æ¢å¤
describe("Token", function () {
  async function deployFixture() {
    const token = await Token.deploy(1000);
    return { token };  // å¿«ç…§
  }

  it("Test 1", async function () {
    const { token } = await loadFixture(deployFixture);  // æ¢å¤å¿«ç…§
    await token.transfer(user, 100);
  });

  it("Test 2", async function () {
    const { token } = await loadFixture(deployFixture);  // æ¢å¤å¿«ç…§
    // è·å¾—å¹²å‡€çš„åŒºå—é“¾çŠ¶æ€
  });
});
```

---

### ç±»æ¯”æ€»ç»“è¡¨

| æµ‹è¯•æ¦‚å¿µ | ç”Ÿæ´»åœºæ™¯ç±»æ¯” | å‰ç«¯é¢†åŸŸç±»æ¯” | æ ¸å¿ƒç›¸ä¼¼æ€§ |
|---------|-------------|-------------|-----------|
| **describe** | è´¨æ£€åˆ†ç±» | Jest describe | ç»„ç»‡ç›¸å…³æµ‹è¯• |
| **it** | å•é¡¹æ£€æµ‹ | Jest it/test | å•ä¸ªæµ‹è¯•ç”¨ä¾‹ |
| **expect** | éªŒæ”¶æ ‡å‡†/æ‰¹æ”¹è¯•å· | Jest expect | æ–­è¨€é¢„æœŸç»“æœ |
| **loadFixture** | æ¸¸æˆå­˜æ¡£ | æ•°æ®åº“äº‹åŠ¡å›æ»š | å¿«ç…§æ¢å¤åˆå§‹çŠ¶æ€ |
| **revertedWith** | é”™è¯¯åœºæ™¯éªŒæ”¶ | toThrow | å¼‚å¸¸æµ‹è¯• |
| **emit** | æ£€æŸ¥é€šçŸ¥å‘é€ | äº‹ä»¶ç›‘å¬æµ‹è¯• | äº‹ä»¶éªŒè¯ |
| **changeBalance** | æ£€æŸ¥è´¦æˆ·å˜åŠ¨ | çŠ¶æ€å˜æ›´æµ‹è¯• | å‰¯ä½œç”¨éªŒè¯ |

---

## 6. ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼šæ¯ä¸ª it ä¹‹é—´çŠ¶æ€ä¼šè‡ªåŠ¨é‡ç½® âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

å¾ˆå¤šåˆå­¦è€…è®¤ä¸ºæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä¹‹é—´åŒºå—é“¾çŠ¶æ€ä¼šè‡ªåŠ¨æ¸…ç©ºï¼š

```javascript
// âŒ é”™è¯¯ç†è§£
describe("Token", function () {
  let token;

  before(async function () {
    token = await Token.deploy(1000);
  });

  it("Test 1: Transfer 100", async function () {
    await token.transfer(user1, 100);
    expect(await token.balanceOf(user1)).to.equal(100);
  });

  it("Test 2: Check balance", async function () {
    // ä»¥ä¸º user1 ä½™é¢æ˜¯ 0ï¼Œå®é™…æ˜¯ 100ï¼
    expect(await token.balanceOf(user1)).to.equal(0);  // âŒ å¤±è´¥
  });
});
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

åœ¨ä¼ ç»Ÿå•å…ƒæµ‹è¯•ä¸­ï¼Œæ¯ä¸ªæµ‹è¯•é€šå¸¸æ˜¯ç‹¬ç«‹çš„ã€‚ä½† Hardhat Network æ˜¯æŒä¹…çš„åŒºå—é“¾ï¼ŒçŠ¶æ€ä¼šç´¯ç§¯ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// âœ… ä½¿ç”¨ loadFixture ç¡®ä¿æ¯ä¸ªæµ‹è¯•ç‹¬ç«‹
describe("Token", function () {
  async function deployFixture() {
    const token = await Token.deploy(1000);
    return { token };
  }

  it("Test 1: Transfer 100", async function () {
    const { token } = await loadFixture(deployFixture);
    await token.transfer(user1, 100);
    expect(await token.balanceOf(user1)).to.equal(100);
  });

  it("Test 2: Check balance", async function () {
    const { token } = await loadFixture(deployFixture);
    // ç°åœ¨ user1 ä½™é¢ç¡®å®æ˜¯ 0
    expect(await token.balanceOf(user1)).to.equal(0);  // âœ… é€šè¿‡
  });
});
```

---

### è¯¯åŒº2ï¼šåŒæ­¥è°ƒç”¨åˆçº¦æ–¹æ³• âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

å‰ç«¯å·¥ç¨‹å¸ˆä¹ æƒ¯åŒæ­¥ä»£ç ï¼Œå®¹æ˜“å¿˜è®° `await`ï¼š

```javascript
// âŒ é”™è¯¯ï¼šå¿˜è®° await
it("Should transfer", function () {  // æ³¨æ„æ²¡æœ‰ async
  const balance = token.balanceOf(user);  // è¿”å› Promiseï¼Œä¸æ˜¯å€¼
  expect(balance).to.equal(100);  // æ¯”è¾ƒçš„æ˜¯ Promise å¯¹è±¡ï¼
});

// âŒ é”™è¯¯ï¼šéƒ¨åˆ†å¿˜è®° await
it("Should transfer", async function () {
  await token.transfer(user, 100);
  const balance = token.balanceOf(user);  // å¿˜è®° await
  expect(balance).to.equal(100);  // ä»ç„¶æ˜¯ Promiseï¼
});
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å‰ç«¯å¼€å‘ä¸­å¾ˆå¤šæ“ä½œæ˜¯åŒæ­¥çš„ï¼Œå®¹æ˜“å¿˜è®°é“¾ä¸Šè°ƒç”¨éƒ½æ˜¯å¼‚æ­¥çš„ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// âœ… æ‰€æœ‰åˆçº¦è°ƒç”¨éƒ½ä½¿ç”¨ await
it("Should transfer", async function () {
  await token.transfer(user, 100);                    // await å†™å…¥æ“ä½œ
  const balance = await token.balanceOf(user);        // await è¯»å–æ“ä½œ
  expect(balance).to.equal(100);                      // ç°åœ¨æ˜¯çœŸå®çš„å€¼
});

// âœ… æˆ–è€…é“¾å¼è°ƒç”¨
it("Should transfer", async function () {
  await token.transfer(user, 100);
  expect(await token.balanceOf(user)).to.equal(100);  // å†…è” await
});
```

---

### è¯¯åŒº3ï¼šexpect å†…ç›´æ¥æ”¾ await ä¸éœ€è¦ to.be âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

éªŒè¯å›æ»šæ—¶ï¼Œè¯­æ³•å®¹æ˜“å‡ºé”™ï¼š

```javascript
// âŒ é”™è¯¯ï¼šexpect å†… await ä½ç½®é”™è¯¯
it("Should revert", async function () {
  expect(await token.transfer(user, 999999)).to.be.revertedWith("Insufficient");
  // await åœ¨ expect å†…éƒ¨æ‰§è¡Œï¼Œå¦‚æœäº¤æ˜“å¤±è´¥ï¼Œawait ä¼šç›´æ¥æŠ›å‡ºå¼‚å¸¸
  // æ ¹æœ¬èµ°ä¸åˆ° .to.be.revertedWith()
});

// âŒ é”™è¯¯ï¼šå¿˜è®° await expect
it("Should revert", async function () {
  expect(token.transfer(user, 999999)).to.be.revertedWith("Insufficient");
  // æ²¡æœ‰ awaitï¼Œæ–­è¨€ä¸ä¼šç­‰å¾…ï¼Œæµ‹è¯•å¯èƒ½è¯¯æŠ¥é€šè¿‡
});
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

`await` å’Œ `expect` çš„ç»„åˆè®©è¯­æ³•å˜å¤æ‚ï¼Œå®¹æ˜“æ··æ·†ä½ç½®ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// âœ… await åœ¨ expect å¤–é¢
it("Should revert", async function () {
  await expect(token.transfer(user, 999999)).to.be.revertedWith("Insufficient");
  // ^^^^^^ await åœ¨è¿™é‡Œï¼
});

// âœ… äº‹ä»¶éªŒè¯ä¹Ÿæ˜¯ä¸€æ ·
it("Should emit event", async function () {
  await expect(token.transfer(user, 100))
    .to.emit(token, "Transfer")
    .withArgs(owner, user, 100);
});

// è§„åˆ™ï¼š
// - è¯»å–å€¼ï¼šexpect(await contract.method())
// - éªŒè¯å¼‚å¸¸/äº‹ä»¶ï¼šawait expect(contract.method())
```

---

## 7. ã€å®æˆ˜ä»£ç ã€‘

### åŸºç¡€å®ç°ï¼šå®Œæ•´çš„ ERC20 æµ‹è¯•

```solidity
// contracts/SimpleToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SimpleToken {
    string public name = "SimpleToken";
    string public symbol = "STK";
    uint8 public decimals = 18;
    uint256 public totalSupply;
    address public owner;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    error InsufficientBalance(uint256 available, uint256 required);
    error InsufficientAllowance(uint256 available, uint256 required);
    error ZeroAddress();

    constructor(uint256 _initialSupply) {
        owner = msg.sender;
        totalSupply = _initialSupply;
        balanceOf[msg.sender] = _initialSupply;
        emit Transfer(address(0), msg.sender, _initialSupply);
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        if (to == address(0)) revert ZeroAddress();
        if (balanceOf[msg.sender] < amount) {
            revert InsufficientBalance(balanceOf[msg.sender], amount);
        }

        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        if (spender == address(0)) revert ZeroAddress();
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        if (to == address(0)) revert ZeroAddress();
        if (balanceOf[from] < amount) {
            revert InsufficientBalance(balanceOf[from], amount);
        }
        if (allowance[from][msg.sender] < amount) {
            revert InsufficientAllowance(allowance[from][msg.sender], amount);
        }

        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        allowance[from][msg.sender] -= amount;
        emit Transfer(from, to, amount);
        return true;
    }
}
```

```javascript
// test/SimpleToken.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

describe("SimpleToken", function () {
  // ===== å¸¸é‡ =====
  const TOKEN_NAME = "SimpleToken";
  const TOKEN_SYMBOL = "STK";
  const INITIAL_SUPPLY = 1000000n;

  // ===== Fixtureï¼šéƒ¨ç½²åˆçº¦ =====
  async function deployTokenFixture() {
    const [owner, user1, user2, user3] = await ethers.getSigners();
    const SimpleToken = await ethers.getContractFactory("SimpleToken");
    const token = await SimpleToken.deploy(INITIAL_SUPPLY);
    return { token, owner, user1, user2, user3 };
  }

  // ===== éƒ¨ç½²æµ‹è¯• =====
  describe("Deployment", function () {
    it("Should set the correct name and symbol", async function () {
      const { token } = await loadFixture(deployTokenFixture);
      expect(await token.name()).to.equal(TOKEN_NAME);
      expect(await token.symbol()).to.equal(TOKEN_SYMBOL);
    });

    it("Should set the correct decimals", async function () {
      const { token } = await loadFixture(deployTokenFixture);
      expect(await token.decimals()).to.equal(18);
    });

    it("Should assign total supply to owner", async function () {
      const { token, owner } = await loadFixture(deployTokenFixture);
      expect(await token.totalSupply()).to.equal(INITIAL_SUPPLY);
      expect(await token.balanceOf(owner.address)).to.equal(INITIAL_SUPPLY);
    });

    it("Should set the deployer as owner", async function () {
      const { token, owner } = await loadFixture(deployTokenFixture);
      expect(await token.owner()).to.equal(owner.address);
    });

    it("Should emit Transfer event on deployment", async function () {
      const [owner] = await ethers.getSigners();
      const SimpleToken = await ethers.getContractFactory("SimpleToken");

      await expect(SimpleToken.deploy(INITIAL_SUPPLY))
        .to.emit(await SimpleToken.deploy(INITIAL_SUPPLY), "Transfer")
        .withArgs(ethers.ZeroAddress, owner.address, INITIAL_SUPPLY);
    });
  });

  // ===== è½¬è´¦æµ‹è¯• =====
  describe("Transfer", function () {
    it("Should transfer tokens between accounts", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);
      const amount = 100n;

      await token.transfer(user1.address, amount);

      expect(await token.balanceOf(user1.address)).to.equal(amount);
      expect(await token.balanceOf(owner.address)).to.equal(INITIAL_SUPPLY - amount);
    });

    it("Should emit Transfer event", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);
      const amount = 100n;

      await expect(token.transfer(user1.address, amount))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, user1.address, amount);
    });

    it("Should allow transfer of entire balance", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);

      await token.transfer(user1.address, INITIAL_SUPPLY);

      expect(await token.balanceOf(owner.address)).to.equal(0);
      expect(await token.balanceOf(user1.address)).to.equal(INITIAL_SUPPLY);
    });

    it("Should allow transfer of zero tokens", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);

      await expect(token.transfer(user1.address, 0n))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, user1.address, 0n);
    });

    it("Should revert when sender has insufficient balance", async function () {
      const { token, user1, user2 } = await loadFixture(deployTokenFixture);
      const amount = 100n;

      await expect(token.connect(user1).transfer(user2.address, amount))
        .to.be.revertedWithCustomError(token, "InsufficientBalance")
        .withArgs(0n, amount);
    });

    it("Should revert when transferring to zero address", async function () {
      const { token } = await loadFixture(deployTokenFixture);

      await expect(token.transfer(ethers.ZeroAddress, 100n))
        .to.be.revertedWithCustomError(token, "ZeroAddress");
    });

    it("Should update balances correctly for multiple transfers", async function () {
      const { token, owner, user1, user2 } = await loadFixture(deployTokenFixture);

      await token.transfer(user1.address, 100n);
      await token.connect(user1).transfer(user2.address, 50n);

      expect(await token.balanceOf(owner.address)).to.equal(INITIAL_SUPPLY - 100n);
      expect(await token.balanceOf(user1.address)).to.equal(50n);
      expect(await token.balanceOf(user2.address)).to.equal(50n);
    });
  });

  // ===== æˆæƒæµ‹è¯• =====
  describe("Approval", function () {
    it("Should approve tokens for spender", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);
      const amount = 100n;

      await token.approve(user1.address, amount);

      expect(await token.allowance(owner.address, user1.address)).to.equal(amount);
    });

    it("Should emit Approval event", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);
      const amount = 100n;

      await expect(token.approve(user1.address, amount))
        .to.emit(token, "Approval")
        .withArgs(owner.address, user1.address, amount);
    });

    it("Should allow updating allowance", async function () {
      const { token, owner, user1 } = await loadFixture(deployTokenFixture);

      await token.approve(user1.address, 100n);
      await token.approve(user1.address, 200n);

      expect(await token.allowance(owner.address, user1.address)).to.equal(200n);
    });

    it("Should revert when approving zero address", async function () {
      const { token } = await loadFixture(deployTokenFixture);

      await expect(token.approve(ethers.ZeroAddress, 100n))
        .to.be.revertedWithCustomError(token, "ZeroAddress");
    });
  });

  // ===== transferFrom æµ‹è¯• =====
  describe("TransferFrom", function () {
    it("Should transfer tokens using allowance", async function () {
      const { token, owner, user1, user2 } = await loadFixture(deployTokenFixture);
      const amount = 100n;

      await token.approve(user1.address, amount);
      await token.connect(user1).transferFrom(owner.address, user2.address, amount);

      expect(await token.balanceOf(user2.address)).to.equal(amount);
      expect(await token.allowance(owner.address, user1.address)).to.equal(0n);
    });

    it("Should emit Transfer event", async function () {
      const { token, owner, user1, user2 } = await loadFixture(deployTokenFixture);
      const amount = 100n;

      await token.approve(user1.address, amount);

      await expect(token.connect(user1).transferFrom(owner.address, user2.address, amount))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, user2.address, amount);
    });

    it("Should revert when allowance is insufficient", async function () {
      const { token, owner, user1, user2 } = await loadFixture(deployTokenFixture);

      await token.approve(user1.address, 50n);

      await expect(token.connect(user1).transferFrom(owner.address, user2.address, 100n))
        .to.be.revertedWithCustomError(token, "InsufficientAllowance")
        .withArgs(50n, 100n);
    });

    it("Should revert when from address has insufficient balance", async function () {
      const { token, owner, user1, user2, user3 } = await loadFixture(deployTokenFixture);

      // user1 æ²¡æœ‰ä»£å¸ï¼Œä½†æˆæƒç»™äº† user2
      await token.connect(user1).approve(user2.address, 100n);

      await expect(token.connect(user2).transferFrom(user1.address, user3.address, 100n))
        .to.be.revertedWithCustomError(token, "InsufficientBalance")
        .withArgs(0n, 100n);
    });

    it("Should decrease allowance after transfer", async function () {
      const { token, owner, user1, user2 } = await loadFixture(deployTokenFixture);

      await token.approve(user1.address, 100n);
      await token.connect(user1).transferFrom(owner.address, user2.address, 30n);

      expect(await token.allowance(owner.address, user1.address)).to.equal(70n);
    });
  });

  // ===== è¾¹ç•Œæ¡ä»¶æµ‹è¯• =====
  describe("Edge Cases", function () {
    it("Should handle maximum uint256 correctly", async function () {
      const [deployer] = await ethers.getSigners();
      const SimpleToken = await ethers.getContractFactory("SimpleToken");
      const maxSupply = ethers.MaxUint256;
      const token = await SimpleToken.deploy(maxSupply);

      expect(await token.totalSupply()).to.equal(maxSupply);
    });

    it("Should allow self-transfer", async function () {
      const { token, owner } = await loadFixture(deployTokenFixture);

      await expect(token.transfer(owner.address, 100n))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, owner.address, 100n);
    });
  });
});
```

**è¿è¡Œè¾“å‡ºç¤ºä¾‹ï¼š**

```
$ npx hardhat test

  SimpleToken
    Deployment
      âœ” Should set the correct name and symbol (823ms)
      âœ” Should set the correct decimals
      âœ” Should assign total supply to owner
      âœ” Should set the deployer as owner
      âœ” Should emit Transfer event on deployment
    Transfer
      âœ” Should transfer tokens between accounts
      âœ” Should emit Transfer event
      âœ” Should allow transfer of entire balance
      âœ” Should allow transfer of zero tokens
      âœ” Should revert when sender has insufficient balance
      âœ” Should revert when transferring to zero address
      âœ” Should update balances correctly for multiple transfers
    Approval
      âœ” Should approve tokens for spender
      âœ” Should emit Approval event
      âœ” Should allow updating allowance
      âœ” Should revert when approving zero address
    TransferFrom
      âœ” Should transfer tokens using allowance
      âœ” Should emit Transfer event
      âœ” Should revert when allowance is insufficient
      âœ” Should revert when from address has insufficient balance
      âœ” Should decrease allowance after transfer
    Edge Cases
      âœ” Should handle maximum uint256 correctly
      âœ” Should allow self-transfer

  23 passing (3s)
```

---

## 8. ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜1ï¼š"å¦‚ä½•æµ‹è¯•æ™ºèƒ½åˆçº¦ä¸­çš„ revert æƒ…å†µï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"ç”¨ try-catch åŒ…èµ·æ¥ï¼Œæˆ–è€…ç”¨ expect.to.be.revertedã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **æµ‹è¯• revert æœ‰ä¸‰ç§å¸¸è§åœºæ™¯ï¼Œéœ€è¦ç”¨ä¸åŒçš„æ–­è¨€ï¼š**
>
> **1. æ™®é€šé”™è¯¯æ¶ˆæ¯ï¼ˆrequire/revert with stringï¼‰**ï¼š
> ```javascript
> // åˆçº¦ä»£ç 
> require(balance >= amount, "Insufficient balance");
>
> // æµ‹è¯•ä»£ç 
> await expect(token.transfer(user, 999999))
>   .to.be.revertedWith("Insufficient balance");
> ```
>
> **2. è‡ªå®šä¹‰é”™è¯¯ï¼ˆCustom Errorï¼Œæ¨èæ–¹å¼ï¼‰**ï¼š
> ```javascript
> // åˆçº¦ä»£ç 
> error InsufficientBalance(uint256 available, uint256 required);
> if (balance < amount) revert InsufficientBalance(balance, amount);
>
> // æµ‹è¯•ä»£ç 
> await expect(token.transfer(user, 999999))
>   .to.be.revertedWithCustomError(token, "InsufficientBalance")
>   .withArgs(0, 999999);  // éªŒè¯é”™è¯¯å‚æ•°
> ```
>
> **3. Panic é”™è¯¯ï¼ˆæº¢å‡ºã€é™¤é›¶ç­‰ï¼‰**ï¼š
> ```javascript
> // æµ‹è¯•ç®—æœ¯æº¢å‡º
> await expect(contract.overflow())
>   .to.be.revertedWithPanic(0x11);  // 0x11 = ç®—æœ¯æº¢å‡º
>
> // æµ‹è¯•é™¤é›¶
> await expect(contract.divideByZero())
>   .to.be.revertedWithPanic(0x12);  // 0x12 = é™¤é›¶
> ```
>
> **æœ€ä½³å®è·µ**ï¼š
> - ä¼˜å…ˆä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ï¼ˆçœ Gas + å¯ä¼ å‚ï¼‰
> - æµ‹è¯•æ—¶éªŒè¯é”™è¯¯å‚æ•°ï¼Œç¡®ä¿é”™è¯¯åŸå› æ­£ç¡®
> - ä½¿ç”¨ Hardhat Chai Matchers æä¾›çš„ä¸“ç”¨æ–­è¨€

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… åˆ†ç±»ä»‹ç»ä¸‰ç§ revert åœºæ™¯
2. âœ… ç»™å‡ºäº†å¯¹åº”çš„ä»£ç ç¤ºä¾‹
3. âœ… æåˆ°äº†æœ€ä½³å®è·µï¼ˆè‡ªå®šä¹‰é”™è¯¯ï¼‰
4. âœ… å±•ç¤ºäº†å®Œæ•´çš„æµ‹è¯•æŠ€æœ¯æ ˆ

---

### é—®é¢˜2ï¼š"ä¸ºä»€ä¹ˆè¦ç”¨ loadFixture è€Œä¸æ˜¯ beforeEachï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"loadFixture æ€§èƒ½æ›´å¥½ï¼Œæµ‹è¯•æ›´å¿«ã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **loadFixture ç›¸æ¯” beforeEach æœ‰ä¸‰ä¸ªæ ¸å¿ƒä¼˜åŠ¿ï¼š**
>
> **1. æ€§èƒ½ä¼˜åŠ¿ï¼ˆå¿«ç…§æ¢å¤ vs é‡å¤æ‰§è¡Œï¼‰**ï¼š
> ```javascript
> // beforeEachï¼šæ¯ä¸ªæµ‹è¯•éƒ½é‡æ–°éƒ¨ç½²
> beforeEach(async () => {
>   token = await Token.deploy(1000000);  // æ‰§è¡Œ N æ¬¡
> });
>
> // loadFixtureï¼šåªéƒ¨ç½²ä¸€æ¬¡ï¼Œåç»­æ¢å¤å¿«ç…§
> async function deployFixture() {
>   return await Token.deploy(1000000);   // åªæ‰§è¡Œ 1 æ¬¡
> }
> it("Test 1", async () => {
>   const token = await loadFixture(deployFixture);  // æ¢å¤å¿«ç…§
> });
> ```
> - 10 ä¸ªæµ‹è¯•ï¼šbeforeEach éƒ¨ç½² 10 æ¬¡ï¼ŒloadFixture éƒ¨ç½² 1 æ¬¡
> - å¤§å‹æµ‹è¯•å¥—ä»¶å¯èƒ½èŠ‚çœ 90% ä»¥ä¸Šçš„æ—¶é—´
>
> **2. çŠ¶æ€éš”ç¦»æ›´å¯é **ï¼š
> - loadFixture ä½¿ç”¨åŒºå—é“¾å¿«ç…§æœºåˆ¶ï¼Œå®Œå…¨æ¢å¤åˆ°åˆå§‹çŠ¶æ€
> - beforeEach ä¾èµ–å˜é‡ä½œç”¨åŸŸï¼Œå¯èƒ½æœ‰çŠ¶æ€æ³„éœ²
>
> **3. ä»£ç ç»„ç»‡æ›´æ¸…æ™°**ï¼š
> ```javascript
> // å¯ä»¥å®šä¹‰å¤šä¸ª fixtureï¼Œç»„åˆä½¿ç”¨
> async function deployTokenFixture() { ... }
> async function deployWithTransferFixture() {
>   const base = await deployTokenFixture();
>   await base.token.transfer(user, 500);
>   return { ...base };
> }
> ```
>
> **æ€§èƒ½æ•°æ®ç¤ºä¾‹**ï¼š
> - 100 ä¸ªæµ‹è¯• + beforeEachï¼šçº¦ 50 ç§’
> - 100 ä¸ªæµ‹è¯• + loadFixtureï¼šçº¦ 8 ç§’
> - æå‡çº¦ 6 å€

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… é‡åŒ–äº†æ€§èƒ½å·®å¼‚
2. âœ… è§£é‡Šäº†æŠ€æœ¯åŸç†ï¼ˆå¿«ç…§æœºåˆ¶ï¼‰
3. âœ… ç»™å‡ºäº†ä»£ç å¯¹æ¯”
4. âœ… æåˆ°äº†é¢å¤–ä¼˜åŠ¿ï¼ˆä»£ç ç»„ç»‡ï¼‰

---

## 9. ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼šä¸ºä»€ä¹ˆè¦æµ‹è¯•æ™ºèƒ½åˆçº¦ï¼Ÿ ğŸ¯

**ä¸€å¥è¯ï¼š** æ™ºèƒ½åˆçº¦éƒ¨ç½²åä¸å¯ä¿®æ”¹ï¼Œbug ä¼šå¯¼è‡´èµ„é‡‘æ°¸ä¹…ä¸¢å¤±ï¼Œæµ‹è¯•æ˜¯ä¸Šçº¿å‰çš„æœ€åé˜²çº¿ã€‚

**ä¸¾ä¾‹ï¼š**
- 2016 å¹´ The DAO æ”»å‡»ï¼šæ™ºèƒ½åˆçº¦æ¼æ´å¯¼è‡´ 6000 ä¸‡ç¾å…ƒè¢«ç›—
- 2021 å¹´ Poly Networkï¼šè·¨é“¾æ¡¥æ¼æ´å¯¼è‡´ 6.1 äº¿ç¾å…ƒè¢«ç›—

**åº”ç”¨ï¼š** ä¸“ä¸šé¡¹ç›®é€šå¸¸è¦æ±‚ 90%+ æµ‹è¯•è¦†ç›–ç‡ï¼Œé‡è¦åˆçº¦è¿˜éœ€è¦ä¸“ä¸šå®¡è®¡ã€‚

---

### å¡ç‰‡2ï¼šMocha æµ‹è¯•ç»“æ„ ğŸ“‹

**ä¸€å¥è¯ï¼š** ä½¿ç”¨ `describe` åˆ†ç»„æµ‹è¯•ï¼Œ`it` å®šä¹‰å•ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ‰€æœ‰åˆçº¦è°ƒç”¨éƒ½æ˜¯å¼‚æ­¥çš„ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
describe("Token", function () {
  describe("Transfer", function () {
    it("should transfer tokens", async function () {
      // æµ‹è¯•ä»£ç 
    });
  });
});
```

**åº”ç”¨ï¼š** æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡æµ‹è¯•ï¼Œæ–¹ä¾¿å®šä½å¤±è´¥ä½ç½®ã€‚

---

### å¡ç‰‡3ï¼šChai æ–­è¨€åŸºç¡€ âœ…

**ä¸€å¥è¯ï¼š** `expect(å®é™…å€¼).to.equal(é¢„æœŸå€¼)` éªŒè¯ç»“æœï¼Œæ™ºèƒ½åˆçº¦æµ‹è¯•å¸¸ç”¨ BigInt æ¯”è¾ƒã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
expect(await token.balanceOf(user)).to.equal(100n);
expect(balance).to.be.gt(0n);
expect(name).to.equal("MyToken");
```

**åº”ç”¨ï¼š** æ‰€æœ‰æµ‹è¯•éƒ½éœ€è¦æ–­è¨€æ¥éªŒè¯é¢„æœŸè¡Œä¸ºã€‚

---

### å¡ç‰‡4ï¼šäº‹ä»¶éªŒè¯ ğŸ“¡

**ä¸€å¥è¯ï¼š** ä½¿ç”¨ `await expect(tx).to.emit(contract, "EventName")` éªŒè¯åˆçº¦æ˜¯å¦æ­£ç¡®è§¦å‘äº‹ä»¶ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
await expect(token.transfer(user, 100))
  .to.emit(token, "Transfer")
  .withArgs(owner, user, 100);
```

**åº”ç”¨ï¼š** äº‹ä»¶æ˜¯ DApp å‰ç«¯ç›‘å¬é“¾ä¸Šå˜åŒ–çš„æ ¸å¿ƒæœºåˆ¶ï¼Œå¿…é¡»æµ‹è¯•ã€‚

---

### å¡ç‰‡5ï¼šå›æ»šéªŒè¯ âš ï¸

**ä¸€å¥è¯ï¼š** ä½¿ç”¨ `await expect(tx).to.be.revertedWith("message")` éªŒè¯äº¤æ˜“æ˜¯å¦æ­£ç¡®å›æ»šã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
// æ™®é€šé”™è¯¯
await expect(token.transfer(user, 999999))
  .to.be.revertedWith("Insufficient balance");

// è‡ªå®šä¹‰é”™è¯¯
await expect(token.transfer(user, 999999))
  .to.be.revertedWithCustomError(token, "InsufficientBalance");
```

**åº”ç”¨ï¼š** æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œæƒé™æ§åˆ¶æ˜¯å¦ç”Ÿæ•ˆã€‚

---

### å¡ç‰‡6ï¼šloadFixture å¿«ç…§ ğŸ“¸

**ä¸€å¥è¯ï¼š** `loadFixture` åªéƒ¨ç½²ä¸€æ¬¡åˆçº¦ï¼Œåç»­æµ‹è¯•é€šè¿‡å¿«ç…§æ¢å¤çŠ¶æ€ï¼Œå¤§å¹…æå‡æµ‹è¯•é€Ÿåº¦ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
async function deployFixture() {
  const token = await Token.deploy(1000);
  return { token };
}

it("Test 1", async () => {
  const { token } = await loadFixture(deployFixture);
});
```

**åº”ç”¨ï¼š** 100 ä¸ªæµ‹è¯•å¯èƒ½ä» 50 ç§’é™åˆ° 8 ç§’ã€‚

---

### å¡ç‰‡7ï¼šè·å–ç­¾åè€… ğŸ‘¥

**ä¸€å¥è¯ï¼š** `ethers.getSigners()` è¿”å›æµ‹è¯•è´¦æˆ·æ•°ç»„ï¼Œ`contract.connect(signer)` åˆ‡æ¢è°ƒç”¨è€…ã€‚

**ä¸¾ä¾‹ï¼š**
```javascript
const [owner, user1, user2] = await ethers.getSigners();
await token.transfer(user1.address, 100);        // owner è°ƒç”¨
await token.connect(user1).transfer(user2.address, 50);  // user1 è°ƒç”¨
```

**åº”ç”¨ï¼š** æµ‹è¯•å¤šç”¨æˆ·åœºæ™¯ã€æƒé™æ§åˆ¶ã€ä»£å¸è½¬è´¦ç­‰ã€‚

---

### å¡ç‰‡8ï¼šæµ‹è¯•è¦†ç›–ç‡ ğŸ“Š

**ä¸€å¥è¯ï¼š** ä½¿ç”¨ `npx hardhat coverage` ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Šï¼Œç›®æ ‡è‡³å°‘ 80%ã€‚

**ä¸¾ä¾‹ï¼š**
```bash
npx hardhat coverage

# è¾“å‡º
# ----------------------|----------|----------|----------|----------|
# File                  |  % Stmts | % Branch |  % Funcs |  % Lines |
# ----------------------|----------|----------|----------|----------|
# contracts/            |      100 |    91.67 |      100 |      100 |
#   SimpleToken.sol     |      100 |    91.67 |      100 |      100 |
# ----------------------|----------|----------|----------|----------|
```

**åº”ç”¨ï¼š** è¦†ç›–ç‡æŠ¥å‘Šå¸®åŠ©å‘ç°æœªæµ‹è¯•çš„ä»£ç è·¯å¾„ã€‚

---

### å¡ç‰‡9ï¼šGas æŠ¥å‘Š â›½

**ä¸€å¥è¯ï¼š** ä½¿ç”¨ `REPORT_GAS=true npx hardhat test` è¾“å‡ºæ¯ä¸ªå‡½æ•°çš„ Gas æ¶ˆè€—ã€‚

**ä¸¾ä¾‹ï¼š**
```
Â·-----------------------|---------------------------|--------------|
|  Contract             Â·  Method                   Â·  Gas         |
Â·-----------------------|---------------------------|--------------|
|  SimpleToken          Â·  transfer                 Â·  51,234      |
|  SimpleToken          Â·  approve                  Â·  46,182      |
|  SimpleToken          Â·  transferFrom             Â·  58,901      |
Â·-----------------------|---------------------------|--------------|
```

**åº”ç”¨ï¼š** ä¼˜åŒ–é«˜ Gas æ¶ˆè€—çš„å‡½æ•°ï¼Œé™ä½ç”¨æˆ·ä½¿ç”¨æˆæœ¬ã€‚

---

### å¡ç‰‡10ï¼šæµ‹è¯•æœ€ä½³å®è·µ ğŸ†

**ä¸€å¥è¯ï¼š** ä¸€ä¸ªæµ‹è¯•åªéªŒè¯ä¸€ä»¶äº‹ï¼Œä½¿ç”¨æè¿°æ€§åç§°ï¼Œè¦†ç›–æ­£å¸¸è·¯å¾„å’Œè¾¹ç•Œæ¡ä»¶ã€‚

**æœ€ä½³å®è·µæ¸…å•ï¼š**
- âœ… æ¯ä¸ª it åªæµ‹è¯•ä¸€ä¸ªè¡Œä¸º
- âœ… æµ‹è¯•åç§°æè¿°é¢„æœŸè¡Œä¸ºï¼ˆ"Should..."ï¼‰
- âœ… ä½¿ç”¨ loadFixture ä¼˜åŒ–æ€§èƒ½
- âœ… æµ‹è¯•æ­£å¸¸è·¯å¾„ + é”™è¯¯è·¯å¾„
- âœ… æµ‹è¯•è¾¹ç•Œæ¡ä»¶ï¼ˆ0ã€æœ€å¤§å€¼ã€ç©ºåœ°å€ï¼‰
- âœ… éªŒè¯äº‹ä»¶è§¦å‘
- âœ… ä¿æŒæµ‹è¯•ç‹¬ç«‹ï¼Œä¸ä¾èµ–æ‰§è¡Œé¡ºåº

**åº”ç”¨ï¼š** éµå¾ªæœ€ä½³å®è·µè®©æµ‹è¯•æ›´å¯é ã€æ›´æ˜“ç»´æŠ¤ã€‚

---

## 10. ã€ä¸€å¥è¯æ€»ç»“ã€‘

**Hardhat æµ‹è¯•ä½¿ç”¨ Mocha ç»„ç»‡ç»“æ„ã€Chai æ–­è¨€éªŒè¯ã€loadFixture ä¼˜åŒ–æ€§èƒ½ï¼Œé€šè¿‡éªŒè¯äº‹ä»¶ã€å›æ»šã€ä½™é¢å˜åŒ–ç­‰é“¾ä¸Šç‰¹æ€§ï¼Œç¡®ä¿æ™ºèƒ½åˆçº¦åœ¨éƒ¨ç½²å‰é€»è¾‘æ­£ç¡®ï¼Œæ˜¯ Web3 å¼€å‘è´¨é‡ä¿éšœçš„æ ¸å¿ƒç¯èŠ‚ã€‚**

---

## ğŸ“š é™„å½•

### å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆæœ¬çŸ¥è¯†ç‚¹å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] ä½¿ç”¨ describe/it ç»„ç»‡æµ‹è¯•ç»“æ„
- [ ] ä½¿ç”¨ expect è¿›è¡Œå„ç§æ–­è¨€
- [ ] ä½¿ç”¨ loadFixture ä¼˜åŒ–æµ‹è¯•æ€§èƒ½
- [ ] éªŒè¯äº‹ä»¶è§¦å‘å’Œå‚æ•°
- [ ] éªŒè¯äº¤æ˜“å›æ»šå’Œé”™è¯¯æ¶ˆæ¯
- [ ] ä½¿ç”¨ connect åˆ‡æ¢è°ƒç”¨è€…
- [ ] è¿è¡Œæµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
- [ ] ç¼–å†™è¾¹ç•Œæ¡ä»¶æµ‹è¯•

### å¿«é€Ÿå‚è€ƒå¡

**å¸¸ç”¨æ–­è¨€ï¼š**

```javascript
// å€¼æ¯”è¾ƒ
expect(value).to.equal(expected);
expect(value).to.be.gt(n);
expect(value).to.be.lt(n);

// äº‹ä»¶
await expect(tx).to.emit(contract, "Event").withArgs(...);

// å›æ»š
await expect(tx).to.be.revertedWith("message");
await expect(tx).to.be.revertedWithCustomError(contract, "Error");

// ä½™é¢å˜åŒ–
await expect(tx).to.changeTokenBalance(token, addr, amount);
await expect(tx).to.changeEtherBalance(addr, amount);
```

**å¸¸ç”¨å‘½ä»¤ï¼š**

```bash
npx hardhat test                    # è¿è¡Œæ‰€æœ‰æµ‹è¯•
npx hardhat test test/Token.test.js # è¿è¡Œç‰¹å®šæ–‡ä»¶
npx hardhat test --grep "transfer"  # è¿è¡ŒåŒ¹é…æµ‹è¯•
npx hardhat coverage                # æµ‹è¯•è¦†ç›–ç‡
REPORT_GAS=true npx hardhat test    # Gas æŠ¥å‘Š
```

### ä¸‹ä¸€æ­¥å­¦ä¹ 

æ¨èæŒ‰ä»¥ä¸‹é¡ºåºç»§ç»­å­¦ä¹ ï¼š

1. **è·å–ä¸åŒç­¾åè€…** - æµ‹è¯•å¤šè´¦æˆ·äº¤äº’
2. **æ¨¡æ‹Ÿæ—¶é—´æµé€** - æµ‹è¯•æ—¶é—´é”é€»è¾‘
3. **Fork ä¸»ç½‘æµ‹è¯•** - æµ‹è¯•ä¸çœŸå®åè®®é›†æˆ
4. **æ¨¡ç³Šæµ‹è¯•ï¼ˆFuzzingï¼‰** - éšæœºè¾“å…¥å‘ç°è¾¹ç•Œ bug

### å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£ï¼š**
- [Hardhat Testing](https://hardhat.org/tutorial/testing-contracts)
- [Hardhat Chai Matchers](https://hardhat.org/hardhat-chai-matchers/docs/overview)

**æµ‹è¯•æœ€ä½³å®è·µï¼š**
- [OpenZeppelin Test Helpers](https://docs.openzeppelin.com/test-helpers/)
- [Solidity Coverage](https://github.com/sc-forks/solidity-coverage)

---

**ç‰ˆæœ¬ï¼š** v1.0
**åˆ›å»ºæ—¥æœŸï¼š** 2025-12-08
**ä½œè€…ï¼š** Droid
**é€‚ç”¨äººç¾¤ï¼š** å‰ç«¯å·¥ç¨‹å¸ˆè½¬ Web3 å¼€å‘
