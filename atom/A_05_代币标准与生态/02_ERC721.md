# ERC721 - éåŒè´¨åŒ–ä»£å¸ï¼ˆNFTï¼‰æ ‡å‡†

## 1. ã€30å­—æ ¸å¿ƒã€‘

**ERC721æ˜¯ä»¥å¤ªåŠéåŒè´¨åŒ–ä»£å¸ï¼ˆNFTï¼‰çš„æ¥å£æ ‡å‡†ï¼Œæ¯ä¸ªä»£å¸éƒ½æœ‰å”¯ä¸€tokenIdï¼Œç”¨äºè¡¨ç¤ºç‹¬ä¸€æ— äºŒçš„æ•°å­—èµ„äº§æ‰€æœ‰æƒã€‚**

---

## 2. ã€ç¬¬ä¸€æ€§åŸç†ã€‘

### ä»€ä¹ˆæ˜¯ç¬¬ä¸€æ€§åŸç†ï¼Ÿ

**ç¬¬ä¸€æ€§åŸç†**ï¼šå›åˆ°äº‹ç‰©æœ€åŸºæœ¬çš„çœŸç†ï¼Œä»æºå¤´æ€è€ƒé—®é¢˜

### ERC721çš„ç¬¬ä¸€æ€§åŸç† ğŸ¯

#### 1. æœ€åŸºç¡€çš„å®šä¹‰

**ERC721 = ä¸€å¥—ç”¨äºè¿½è¸ªç‹¬ä¸€æ— äºŒèµ„äº§æ‰€æœ‰æƒçš„æ¥å£è§„èŒƒ**

ä»…æ­¤è€Œå·²ï¼æ²¡æœ‰æ›´åŸºç¡€çš„äº†ã€‚

ERC721çš„æ ¸å¿ƒæ˜¯`mapping(uint256 => address)`ï¼Œå³**tokenId â†’ æ‰€æœ‰è€…åœ°å€**çš„æ˜ å°„ã€‚æ¯ä¸ªtokenIdéƒ½æ˜¯ç‹¬ä¸€æ— äºŒçš„ï¼Œä¸èƒ½äº’æ¢ã€‚

#### 2. ä¸ºä»€ä¹ˆéœ€è¦ERC721ï¼Ÿ

**æ ¸å¿ƒé—®é¢˜ï¼šå¦‚ä½•åœ¨åŒºå—é“¾ä¸Šè¡¨ç¤ºå’Œè½¬ç§»ç‹¬ä¸€æ— äºŒçš„æ•°å­—èµ„äº§ï¼Ÿ**

åœ¨ERC721å‡ºç°ä¹‹å‰ï¼ˆ2018å¹´ä¹‹å‰ï¼‰ï¼š
- ERC20åªèƒ½è¡¨ç¤º"å¯äº’æ¢"çš„ä»£å¸ï¼ˆä½ çš„1 USDCå’Œæˆ‘çš„1 USDCæ²¡æœ‰åŒºåˆ«ï¼‰
- æ— æ³•è¡¨ç¤ºç‹¬ç‰¹æ€§ï¼ˆæ¯å¹…ç”»ã€æ¯å—åœŸåœ°ã€æ¯ä¸ªæ¸¸æˆé“å…·éƒ½æ˜¯ä¸åŒçš„ï¼‰
- æ²¡æœ‰æ ‡å‡†æ–¹å¼è¿½è¸ª"è¿™ä¸ªç‰¹å®šç‰©å“å±äºè°"

**ç±»æ¯”**ï¼šERC20åƒäººæ°‘å¸ï¼ˆæ¯å¼ 100å…ƒéƒ½ä¸€æ ·ï¼‰ï¼ŒERC721åƒæˆ¿äº§è¯ï¼ˆæ¯å¥—æˆ¿å­éƒ½ä¸åŒï¼‰ã€‚

#### 3. ERC721çš„ä¸‰å±‚ä»·å€¼

##### ä»·å€¼1ï¼šå”¯ä¸€æ€§è¯æ˜ï¼ˆUniquenessï¼‰

æ¯ä¸ªNFTéƒ½æœ‰å”¯ä¸€çš„tokenIdï¼Œå¯ä»¥ä»£è¡¨ç°å®æˆ–è™šæ‹Ÿä¸–ç•Œä¸­ç‹¬ä¸€æ— äºŒçš„èµ„äº§ã€‚

```solidity
// æ¯ä¸ªtokenIdå¯¹åº”å”¯ä¸€çš„æ‰€æœ‰è€…
mapping(uint256 => address) private _owners;

// tokenId 1 å’Œ tokenId 2 æ˜¯å®Œå…¨ä¸åŒçš„èµ„äº§
_owners[1] = 0xAlice;  // NFT #1 å±äº Alice
_owners[2] = 0xBob;    // NFT #2 å±äº Bob
```

##### ä»·å€¼2ï¼šå¯éªŒè¯çš„æ‰€æœ‰æƒï¼ˆVerifiable Ownershipï¼‰

ä»»ä½•äººéƒ½å¯ä»¥åœ¨é“¾ä¸ŠéªŒè¯æŸä¸ªNFTçš„å½“å‰æ‰€æœ‰è€…å’Œå†å²è½¬ç§»è®°å½•ã€‚

```javascript
// æŸ¥è¯¢NFT #123 çš„æ‰€æœ‰è€…
const owner = await nftContract.ownerOf(123);
console.log(`NFT #123 å±äº: ${owner}`);

// æŸ¥è¯¢å†å²è½¬ç§»è®°å½•ï¼ˆé€šè¿‡äº‹ä»¶ï¼‰
const transfers = await nftContract.queryFilter(
    nftContract.filters.Transfer(null, null, 123)
);
```

##### ä»·å€¼3ï¼šå…ƒæ•°æ®æ‰©å±•ï¼ˆMetadataï¼‰

é€šè¿‡`tokenURI`å‡½æ•°ï¼Œæ¯ä¸ªNFTå¯ä»¥å…³è”ä¸°å¯Œçš„å…ƒæ•°æ®ï¼ˆå›¾ç‰‡ã€å±æ€§ã€æè¿°ç­‰ï¼‰ã€‚

```solidity
// è¿”å›NFTçš„å…ƒæ•°æ®URI
function tokenURI(uint256 tokenId) public view returns (string memory) {
    return string(abi.encodePacked(baseURI, tokenId.toString(), ".json"));
}

// å…ƒæ•°æ®JSONç¤ºä¾‹
{
    "name": "Bored Ape #1234",
    "description": "A unique Bored Ape",
    "image": "ipfs://QmXxx.../1234.png",
    "attributes": [
        { "trait_type": "Background", "value": "Blue" },
        { "trait_type": "Fur", "value": "Golden" }
    ]
}
```

#### 4. ä»ç¬¬ä¸€æ€§åŸç†æ¨å¯¼ERC721è®¾è®¡

**æ¨ç†é“¾ï¼š**

```
1. å‰æï¼šéœ€è¦è¡¨ç¤ºç‹¬ä¸€æ— äºŒçš„æ•°å­—èµ„äº§
   â†“
2. æ¨å¯¼ï¼šæ¯ä¸ªèµ„äº§éœ€è¦å”¯ä¸€æ ‡è¯†ç¬¦
   - tokenIdï¼ˆuint256ï¼‰ä½œä¸ºå”¯ä¸€æ ‡è¯†
   â†“
3. æ¨å¯¼ï¼šéœ€è¦è¿½è¸ªæ‰€æœ‰æƒ
   - ownerOf(tokenId) â†’ address
   - balanceOf(address) â†’ æ‹¥æœ‰çš„NFTæ•°é‡
   â†“
4. æ¨å¯¼ï¼šéœ€è¦è½¬ç§»æ‰€æœ‰æƒ
   - transferFrom(from, to, tokenId)
   - safeTransferFromï¼ˆå®‰å…¨ç‰ˆæœ¬ï¼Œæ£€æŸ¥æ¥æ”¶æ–¹ï¼‰
   â†“
5. æ¨å¯¼ï¼šéœ€è¦æˆæƒæœºåˆ¶ï¼ˆç±»ä¼¼ERC20ï¼‰
   - approve(to, tokenId) â†’ æˆæƒå•ä¸ªNFT
   - setApprovalForAll(operator, approved) â†’ æˆæƒæ‰€æœ‰NFT
   - getApproved(tokenId) / isApprovedForAll(owner, operator)
   â†“
6. æ¨å¯¼ï¼šéœ€è¦å…³è”å…ƒæ•°æ®
   - tokenURI(tokenId) â†’ è¿”å›å…ƒæ•°æ®URL
   - å…ƒæ•°æ®å­˜å‚¨åœ¨é“¾ä¸‹ï¼ˆIPFSã€Arweaveæˆ–ä¸­å¿ƒåŒ–æœåŠ¡å™¨ï¼‰
   â†“
7. æœ€ç»ˆå®ç°ï¼šERC721æ ‡å‡†
   - æ ¸å¿ƒå‡½æ•°ï¼šbalanceOf, ownerOf, transferFrom, safeTransferFrom, approve, setApprovalForAll
   - å…ƒæ•°æ®æ‰©å±•ï¼šname, symbol, tokenURI
   - æšä¸¾æ‰©å±•ï¼štotalSupply, tokenByIndex, tokenOfOwnerByIndex
```

#### 5. ä¸€å¥è¯æ€»ç»“ç¬¬ä¸€æ€§åŸç†

**ERC721æ˜¯æ•°å­—èµ„äº§çš„"æˆ¿äº§è¯æ ‡å‡†"ï¼Œé€šè¿‡tokenIdè¿½è¸ªç‹¬ä¸€æ— äºŒèµ„äº§çš„æ‰€æœ‰æƒï¼Œä½¿NFTèƒ½å¤Ÿè¢«æ‰€æœ‰é’±åŒ…ã€å¸‚åœºå’Œåº”ç”¨ç»Ÿä¸€è¯†åˆ«å’Œäº¤æ˜“ã€‚**

---

## 3. ã€3ä¸ªæ ¸å¿ƒæ¦‚å¿µã€‘

### æ ¸å¿ƒæ¦‚å¿µ1ï¼štokenId - å”¯ä¸€æ ‡è¯†ç¬¦ ğŸ”¢

**ä¸€å¥è¯å®šä¹‰ï¼š** tokenIdæ˜¯æ¯ä¸ªNFTçš„å”¯ä¸€èº«ä»½è¯å·ï¼Œç”¨uint256è¡¨ç¤ºï¼Œåœ¨åŒä¸€ä¸ªåˆçº¦å†…ä¸ä¼šé‡å¤ã€‚

```solidity
// ERC721çš„æ ¸å¿ƒæ•°æ®ç»“æ„
contract ERC721 {
    // tokenId â†’ æ‰€æœ‰è€…åœ°å€
    mapping(uint256 => address) private _owners;

    // åœ°å€ â†’ æ‹¥æœ‰çš„NFTæ•°é‡
    mapping(address => uint256) private _balances;

    // æŸ¥è¯¢NFTæ‰€æœ‰è€…
    function ownerOf(uint256 tokenId) public view returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: invalid token ID");
        return owner;
    }

    // æŸ¥è¯¢æŸåœ°å€æ‹¥æœ‰å¤šå°‘ä¸ªNFT
    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), "ERC721: zero address");
        return _balances[owner];
    }
}
```

**è¯¦ç»†è§£é‡Šï¼š**

**tokenIdçš„å¸¸è§ç”Ÿæˆæ–¹å¼ï¼š**

```solidity
// æ–¹å¼1ï¼šé€’å¢IDï¼ˆæœ€å¸¸ç”¨ï¼‰
uint256 private _tokenIdCounter;

function mint(address to) public {
    _tokenIdCounter++;
    _mint(to, _tokenIdCounter);
}

// æ–¹å¼2ï¼šåŸºäºå†…å®¹å“ˆå¸Œ
function mint(address to, string memory contentURI) public {
    uint256 tokenId = uint256(keccak256(abi.encodePacked(contentURI)));
    _mint(to, tokenId);
}

// æ–¹å¼3ï¼šå¤–éƒ¨æŒ‡å®šï¼ˆå¦‚å¯¼å…¥å·²æœ‰æ•°æ®ï¼‰
function mint(address to, uint256 tokenId) public onlyOwner {
    _mint(to, tokenId);
}
```

**ERC721 vs ERC20çš„æ ¸å¿ƒåŒºåˆ«ï¼š**

| ç‰¹æ€§ | ERC20 | ERC721 |
|-----|-------|--------|
| æ ¸å¿ƒæ˜ å°„ | `address â†’ ä½™é¢` | `tokenId â†’ æ‰€æœ‰è€…` |
| ä»£å¸æ€§è´¨ | åŒè´¨åŒ–ï¼ˆå¯äº’æ¢ï¼‰ | éåŒè´¨åŒ–ï¼ˆä¸å¯äº’æ¢ï¼‰ |
| è½¬è´¦å‚æ•° | `transfer(to, amount)` | `transferFrom(from, to, tokenId)` |
| ä½™é¢å«ä¹‰ | æŒæœ‰çš„ä»£å¸æ•°é‡ | æŒæœ‰çš„NFTä¸ªæ•° |
| æˆæƒæ–¹å¼ | æˆæƒé‡‘é¢ | æˆæƒç‰¹å®štokenId |

**åœ¨DAppå¼€å‘ä¸­çš„åº”ç”¨ï¼š**

```javascript
// æŸ¥è¯¢ç”¨æˆ·æ‹¥æœ‰çš„NFTåˆ—è¡¨
async function getUserNFTs(nftContract, userAddress) {
    const balance = await nftContract.balanceOf(userAddress);
    const nfts = [];

    // å¦‚æœåˆçº¦æ”¯æŒERC721Enumerable
    for (let i = 0; i < balance; i++) {
        const tokenId = await nftContract.tokenOfOwnerByIndex(userAddress, i);
        const tokenURI = await nftContract.tokenURI(tokenId);
        nfts.push({ tokenId, tokenURI });
    }

    return nfts;
}
```

---

### æ ¸å¿ƒæ¦‚å¿µ2ï¼šsafeTransferFrom - å®‰å…¨è½¬è´¦ ğŸ›¡ï¸

**ä¸€å¥è¯å®šä¹‰ï¼š** `safeTransferFrom`åœ¨è½¬è´¦æ—¶æ£€æŸ¥æ¥æ”¶æ–¹æ˜¯å¦èƒ½å¤„ç†NFTï¼Œé˜²æ­¢NFTè¢«æ°¸ä¹…é”å®šåœ¨æ— æ³•å¤„ç†å®ƒçš„åˆçº¦ä¸­ã€‚

```solidity
contract ERC721 {
    // å®‰å…¨è½¬è´¦ï¼šæ£€æŸ¥æ¥æ”¶æ–¹
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public {
        safeTransferFrom(from, to, tokenId, "");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) public {
        // å…ˆæ‰§è¡Œæ™®é€šè½¬è´¦
        transferFrom(from, to, tokenId);

        // å¦‚æœæ¥æ”¶æ–¹æ˜¯åˆçº¦ï¼Œæ£€æŸ¥æ˜¯å¦å®ç°äº†onERC721Received
        if (to.code.length > 0) {
            try IERC721Receiver(to).onERC721Received(
                msg.sender, from, tokenId, data
            ) returns (bytes4 retval) {
                require(
                    retval == IERC721Receiver.onERC721Received.selector,
                    "ERC721: transfer to non ERC721Receiver"
                );
            } catch {
                revert("ERC721: transfer to non ERC721Receiver");
            }
        }
    }

    // æ™®é€šè½¬è´¦ï¼šä¸æ£€æŸ¥æ¥æ”¶æ–¹
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public {
        require(_isApprovedOrOwner(msg.sender, tokenId), "Not approved");
        require(ownerOf(tokenId) == from, "Not owner");
        require(to != address(0), "Transfer to zero address");

        // æ¸…é™¤æ—§çš„æˆæƒ
        delete _tokenApprovals[tokenId];

        // æ›´æ–°ä½™é¢
        _balances[from] -= 1;
        _balances[to] += 1;

        // æ›´æ–°æ‰€æœ‰æƒ
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }
}

// æ¥æ”¶NFTçš„åˆçº¦å¿…é¡»å®ç°è¿™ä¸ªæ¥å£
interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}
```

**è¯¦ç»†è§£é‡Šï¼š**

**ä¸ºä»€ä¹ˆéœ€è¦safeTransferFromï¼Ÿ**

```solidity
// å±é™©åœºæ™¯ï¼šæŠŠNFTè½¬åˆ°ä¸€ä¸ªæ— æ³•å¤„ç†å®ƒçš„åˆçº¦
// ä½¿ç”¨transferFromï¼šNFTè¢«æ°¸ä¹…é”å®šï¼
nft.transferFrom(alice, someContractWithoutReceiver, tokenId);
// someContractæ— æ³•è½¬å‡ºè¿™ä¸ªNFTï¼Œæ°¸ä¹…ä¸¢å¤±

// å®‰å…¨åœºæ™¯ï¼šä½¿ç”¨safeTransferFrom
// å¦‚æœæ¥æ”¶åˆçº¦æ²¡å®ç°onERC721Receivedï¼Œäº¤æ˜“ä¼šrevert
nft.safeTransferFrom(alice, someContractWithoutReceiver, tokenId);
// äº¤æ˜“å¤±è´¥ï¼ŒNFTä»åœ¨Aliceè´¦æˆ·ï¼Œå®‰å…¨ï¼
```

**å®ç°æ¥æ”¶NFTçš„åˆçº¦ï¼š**

```solidity
// å¯ä»¥æ¥æ”¶NFTçš„åˆçº¦
contract NFTVault is IERC721Receiver {
    // å­˜å‚¨æ”¶åˆ°çš„NFT
    mapping(address => mapping(uint256 => address)) public deposits;

    // å¿…é¡»å®ç°è¿™ä¸ªå‡½æ•°æ‰èƒ½æ¥æ”¶NFT
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external override returns (bytes4) {
        // è®°å½•å­˜æ¬¾
        deposits[msg.sender][tokenId] = from;

        // è¿”å›selectorè¡¨ç¤ºæˆåŠŸæ¥æ”¶
        return IERC721Receiver.onERC721Received.selector;
    }

    // æå–NFT
    function withdraw(address nftContract, uint256 tokenId) external {
        require(deposits[nftContract][tokenId] == msg.sender, "Not depositor");
        delete deposits[nftContract][tokenId];

        IERC721(nftContract).safeTransferFrom(address(this), msg.sender, tokenId);
    }
}
```

**åœ¨DAppå¼€å‘ä¸­çš„åº”ç”¨ï¼š**

```javascript
// å‰ç«¯è½¬è´¦NFTï¼ˆæ¨èä½¿ç”¨safeTransferFromï¼‰
async function transferNFT(nftContract, signer, to, tokenId) {
    const contractWithSigner = nftContract.connect(signer);

    // æ£€æŸ¥æ˜¯å¦æ˜¯åˆçº¦åœ°å€
    const code = await provider.getCode(to);

    if (code !== "0x") {
        // æ¥æ”¶æ–¹æ˜¯åˆçº¦ï¼Œä½¿ç”¨safeTransferFrom
        console.log("æ¥æ”¶æ–¹æ˜¯åˆçº¦ï¼Œä½¿ç”¨å®‰å…¨è½¬è´¦");
        const tx = await contractWithSigner["safeTransferFrom(address,address,uint256)"](
            await signer.getAddress(),
            to,
            tokenId
        );
        return tx.wait();
    } else {
        // æ¥æ”¶æ–¹æ˜¯EOAï¼Œå¯ä»¥ä½¿ç”¨æ™®é€šè½¬è´¦ï¼ˆä½†safeTransferFromä¹Ÿå®‰å…¨ï¼‰
        const tx = await contractWithSigner.transferFrom(
            await signer.getAddress(),
            to,
            tokenId
        );
        return tx.wait();
    }
}
```

---

### æ ¸å¿ƒæ¦‚å¿µ3ï¼štokenURI - å…ƒæ•°æ® ğŸ“„

**ä¸€å¥è¯å®šä¹‰ï¼š** `tokenURI`è¿”å›NFTå…ƒæ•°æ®çš„URLï¼Œå…ƒæ•°æ®åŒ…å«NFTçš„åç§°ã€æè¿°ã€å›¾ç‰‡å’Œå±æ€§ç­‰ä¿¡æ¯ã€‚

```solidity
contract ERC721WithMetadata {
    string private _baseTokenURI;

    // å¯é€‰ï¼šæ¯ä¸ªtokenIdå•ç‹¬è®¾ç½®URI
    mapping(uint256 => string) private _tokenURIs;

    // è¿”å›å…ƒæ•°æ®URI
    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "URI query for nonexistent token");

        // æ–¹å¼1ï¼šä½¿ç”¨å•ç‹¬è®¾ç½®çš„URI
        string memory _tokenURI = _tokenURIs[tokenId];
        if (bytes(_tokenURI).length > 0) {
            return _tokenURI;
        }

        // æ–¹å¼2ï¼šä½¿ç”¨baseURI + tokenId
        return string(abi.encodePacked(_baseTokenURI, tokenId.toString(), ".json"));
    }

    // è®¾ç½®baseURI
    function setBaseURI(string memory baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
    }
}
```

**è¯¦ç»†è§£é‡Šï¼š**

**å…ƒæ•°æ®JSONæ ‡å‡†æ ¼å¼ï¼ˆOpenSeaå…¼å®¹ï¼‰ï¼š**

```json
{
    "name": "Cool Cat #1234",
    "description": "Cool Cats is a collection of 9,999 randomly generated cats.",
    "image": "ipfs://QmXxxx.../1234.png",
    "external_url": "https://coolcats.com/cat/1234",
    "attributes": [
        {
            "trait_type": "Background",
            "value": "Blue"
        },
        {
            "trait_type": "Fur",
            "value": "Golden"
        },
        {
            "trait_type": "Eyes",
            "value": "Laser"
        },
        {
            "display_type": "number",
            "trait_type": "Generation",
            "value": 1
        },
        {
            "display_type": "boost_percentage",
            "trait_type": "Power Boost",
            "value": 25
        }
    ],
    "animation_url": "ipfs://QmYyyy.../1234.mp4"
}
```

**å…ƒæ•°æ®å­˜å‚¨æ–¹æ¡ˆå¯¹æ¯”ï¼š**

| å­˜å‚¨æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|---------|------|------|---------|
| **IPFS** | å»ä¸­å¿ƒåŒ–ã€å†…å®¹å¯»å€ã€æ°¸ä¹… | éœ€è¦PinæœåŠ¡ã€è®¿é—®é€Ÿåº¦ä¸€èˆ¬ | é«˜ä»·å€¼NFT |
| **Arweave** | æ°¸ä¹…å­˜å‚¨ã€ä¸€æ¬¡ä»˜è´¹ | æˆæœ¬è¾ƒé«˜ | éœ€è¦æ°¸ä¹…ä¿è¯çš„NFT |
| **ä¸­å¿ƒåŒ–æœåŠ¡å™¨** | é€Ÿåº¦å¿«ã€æ˜“ä¿®æ”¹ | å¯èƒ½ä¸‹çº¿ã€ä¸é€æ˜ | æ¸¸æˆé“å…·ã€å¯å˜NFT |
| **é“¾ä¸Šå­˜å‚¨** | å®Œå…¨å»ä¸­å¿ƒåŒ– | Gasæˆæœ¬æé«˜ | å°å‹SVGã€çº¯æ–‡æœ¬ |

**åœ¨DAppå¼€å‘ä¸­çš„åº”ç”¨ï¼š**

```javascript
// è·å–NFTå…ƒæ•°æ®å¹¶æ˜¾ç¤º
async function getNFTMetadata(nftContract, tokenId) {
    // 1. è·å–tokenURI
    const tokenURI = await nftContract.tokenURI(tokenId);
    console.log(`Token URI: ${tokenURI}`);

    // 2. å¤„ç†ä¸åŒåè®®çš„URI
    let metadataURL = tokenURI;

    // IPFSåè®®è½¬æ¢
    if (tokenURI.startsWith("ipfs://")) {
        metadataURL = tokenURI.replace("ipfs://", "https://ipfs.io/ipfs/");
    }

    // Arweaveåè®®è½¬æ¢
    if (tokenURI.startsWith("ar://")) {
        metadataURL = tokenURI.replace("ar://", "https://arweave.net/");
    }

    // 3. è·å–å…ƒæ•°æ®JSON
    const response = await fetch(metadataURL);
    const metadata = await response.json();

    // 4. å¤„ç†å›¾ç‰‡URL
    let imageURL = metadata.image;
    if (imageURL.startsWith("ipfs://")) {
        imageURL = imageURL.replace("ipfs://", "https://ipfs.io/ipfs/");
    }

    return {
        name: metadata.name,
        description: metadata.description,
        image: imageURL,
        attributes: metadata.attributes
    };
}

// åœ¨Reactç»„ä»¶ä¸­ä½¿ç”¨
function NFTCard({ nftContract, tokenId }) {
    const [metadata, setMetadata] = useState(null);

    useEffect(() => {
        getNFTMetadata(nftContract, tokenId).then(setMetadata);
    }, [tokenId]);

    if (!metadata) return <div>Loading...</div>;

    return (
        <div className="nft-card">
            <img src={metadata.image} alt={metadata.name} />
            <h3>{metadata.name}</h3>
            <p>{metadata.description}</p>
            <div className="attributes">
                {metadata.attributes?.map(attr => (
                    <span key={attr.trait_type}>
                        {attr.trait_type}: {attr.value}
                    </span>
                ))}
            </div>
        </div>
    );
}
```

---

## 4. ã€æœ€å°å¯ç”¨ã€‘

æŒæ¡ä»¥ä¸‹å†…å®¹ï¼Œå°±èƒ½å¼€å‘åŸºç¡€çš„NFTåº”ç”¨ï¼š

### 4.1 ERC721çš„æ ¸å¿ƒå‡½æ•°

```solidity
// ERC721æ ¸å¿ƒæ¥å£
interface IERC721 {
    // ===== æŸ¥è¯¢å‡½æ•° =====
    // æŸ¥è¯¢æŸåœ°å€æ‹¥æœ‰çš„NFTæ•°é‡
    function balanceOf(address owner) external view returns (uint256);

    // æŸ¥è¯¢æŸtokenIdçš„æ‰€æœ‰è€…
    function ownerOf(uint256 tokenId) external view returns (uint256);

    // ===== è½¬è´¦å‡½æ•° =====
    // å®‰å…¨è½¬è´¦ï¼ˆæ£€æŸ¥æ¥æ”¶æ–¹ï¼‰
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;

    // æ™®é€šè½¬è´¦ï¼ˆä¸æ£€æŸ¥æ¥æ”¶æ–¹ï¼‰
    function transferFrom(address from, address to, uint256 tokenId) external;

    // ===== æˆæƒå‡½æ•° =====
    // æˆæƒå•ä¸ªNFTç»™æŸåœ°å€
    function approve(address to, uint256 tokenId) external;

    // æˆæƒ/å–æ¶ˆæˆæƒæ“ä½œå‘˜ç®¡ç†æ‰€æœ‰NFT
    function setApprovalForAll(address operator, bool approved) external;

    // æŸ¥è¯¢å•ä¸ªNFTçš„æˆæƒåœ°å€
    function getApproved(uint256 tokenId) external view returns (address);

    // æŸ¥è¯¢æ˜¯å¦æˆæƒäº†æ“ä½œå‘˜
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

// å…ƒæ•°æ®æ‰©å±•æ¥å£
interface IERC721Metadata {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}
```

### 4.2 ä½¿ç”¨OpenZeppelinåˆ›å»ºNFTåˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyNFT is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;

    constructor() ERC721("My NFT Collection", "MNFT") Ownable(msg.sender) {}

    // é“¸é€ NFT
    function mint(address to, string memory uri) public onlyOwner {
        _tokenIdCounter++;
        uint256 tokenId = _tokenIdCounter;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    // æ‰¹é‡é“¸é€ 
    function batchMint(address to, string[] memory uris) public onlyOwner {
        for (uint i = 0; i < uris.length; i++) {
            mint(to, uris[i]);
        }
    }

    // é‡å†™å¿…è¦çš„å‡½æ•°
    function tokenURI(uint256 tokenId)
        public view override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public view override(ERC721, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

### 4.3 å‰ç«¯è¯»å–NFTä¿¡æ¯

```javascript
const { ethers } = require('ethers');

// ERC721æœ€å°ABI
const ERC721_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)",
    "function ownerOf(uint256) view returns (address)",
    "function tokenURI(uint256) view returns (string)",
    "function getApproved(uint256) view returns (address)",
    "function isApprovedForAll(address, address) view returns (bool)",
    "function approve(address, uint256)",
    "function setApprovalForAll(address, bool)",
    "function transferFrom(address, address, uint256)",
    "function safeTransferFrom(address, address, uint256)",
    "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",
    "event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)",
    "event ApprovalForAll(address indexed owner, address indexed operator, bool approved)"
];

// åˆ›å»ºåˆçº¦å®ä¾‹
const provider = new ethers.JsonRpcProvider('https://eth.llamarpc.com');
const nftContract = new ethers.Contract(nftAddress, ERC721_ABI, provider);

// è¯»å–NFTåŸºæœ¬ä¿¡æ¯
async function getNFTInfo(tokenId) {
    const name = await nftContract.name();
    const symbol = await nftContract.symbol();
    const owner = await nftContract.ownerOf(tokenId);
    const tokenURI = await nftContract.tokenURI(tokenId);

    console.log(`Collection: ${name} (${symbol})`);
    console.log(`Token #${tokenId} Owner: ${owner}`);
    console.log(`Metadata URI: ${tokenURI}`);
}
```

### 4.4 å‰ç«¯è½¬è´¦å’ŒæˆæƒNFT

```javascript
// è½¬è´¦NFT
async function transferNFT(signer, to, tokenId) {
    const contractWithSigner = nftContract.connect(signer);
    const from = await signer.getAddress();

    // ä½¿ç”¨safeTransferFromï¼ˆæ¨èï¼‰
    const tx = await contractWithSigner["safeTransferFrom(address,address,uint256)"](
        from, to, tokenId
    );
    const receipt = await tx.wait();
    console.log(`NFT #${tokenId} è½¬è´¦æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œ: ${receipt.hash}`);
}

// æˆæƒNFTç»™å¸‚åœºåˆçº¦ï¼ˆå¦‚OpenSeaï¼‰
async function approveForMarketplace(signer, marketplaceAddress, tokenId) {
    const contractWithSigner = nftContract.connect(signer);

    // æ–¹å¼1ï¼šæˆæƒå•ä¸ªNFT
    const tx1 = await contractWithSigner.approve(marketplaceAddress, tokenId);
    await tx1.wait();

    // æ–¹å¼2ï¼šæˆæƒæ‰€æœ‰NFTç»™å¸‚åœºï¼ˆæ›´æ–¹ä¾¿ï¼Œä½†éœ€è¦ä¿¡ä»»å¸‚åœºåˆçº¦ï¼‰
    const tx2 = await contractWithSigner.setApprovalForAll(marketplaceAddress, true);
    await tx2.wait();

    console.log("æˆæƒæˆåŠŸï¼");
}

// æ£€æŸ¥æˆæƒçŠ¶æ€
async function checkApproval(ownerAddress, operatorAddress, tokenId) {
    // æ£€æŸ¥å•ä¸ªNFTæˆæƒ
    const approved = await nftContract.getApproved(tokenId);
    console.log(`Token #${tokenId} æˆæƒç»™: ${approved}`);

    // æ£€æŸ¥å…¨éƒ¨æˆæƒ
    const isApprovedForAll = await nftContract.isApprovedForAll(ownerAddress, operatorAddress);
    console.log(`${ownerAddress} æ˜¯å¦æˆæƒæ‰€æœ‰NFTç»™ ${operatorAddress}: ${isApprovedForAll}`);
}
```

### 4.5 ç›‘å¬NFTè½¬è´¦äº‹ä»¶

```javascript
// ç›‘å¬Transferäº‹ä»¶
nftContract.on("Transfer", (from, to, tokenId, event) => {
    console.log(`\nNFTè½¬è´¦äº‹ä»¶:`);
    console.log(`  From: ${from}`);
    console.log(`  To: ${to}`);
    console.log(`  Token ID: ${tokenId}`);
    console.log(`  äº¤æ˜“å“ˆå¸Œ: ${event.log.transactionHash}`);
});

// æŸ¥è¯¢æŸåœ°å€çš„NFTè½¬å…¥è®°å½•
async function getIncomingTransfers(address, fromBlock = 0) {
    const filter = nftContract.filters.Transfer(null, address);
    const events = await nftContract.queryFilter(filter, fromBlock);

    return events.map(e => ({
        from: e.args.from,
        tokenId: e.args.tokenId.toString(),
        txHash: e.transactionHash
    }));
}
```

---

**è¿™äº›çŸ¥è¯†è¶³ä»¥ï¼š**
- âœ… åˆ›å»ºå’Œéƒ¨ç½²è‡ªå·±çš„NFTåˆçº¦
- âœ… åœ¨DAppä¸­æ˜¾ç¤ºNFTå›¾ç‰‡å’Œå…ƒæ•°æ®
- âœ… å®ç°NFTçš„è½¬è´¦å’ŒæˆæƒåŠŸèƒ½
- âœ… ä¸NFTå¸‚åœºï¼ˆOpenSeaã€Blurç­‰ï¼‰äº¤äº’
- âœ… ç›‘å¬NFTè½¬è´¦äº‹ä»¶æ›´æ–°UI

---

## 5. ã€1ä¸ªç±»æ¯”ã€‘

### ç±»æ¯”1ï¼šERC721 NFT ğŸ¨

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šERC721 = æˆ¿äº§è¯/è‰ºæœ¯å“è¯ä¹¦

æƒ³è±¡ä½ å»æˆ¿äº§äº¤æ˜“ä¸­å¿ƒåŠç†æˆ¿äº§è¿‡æˆ·ï¼š

**æˆ¿äº§è¯ç³»ç»Ÿï¼š**
- æ¯å¥—æˆ¿å­éƒ½æœ‰å”¯ä¸€çš„**æˆ¿äº§è¯å·**ï¼ˆtokenIdï¼‰
- æˆ¿äº§è¯ä¸Šå†™ç€**æ‰€æœ‰è€…å§“å**ï¼ˆownerOfï¼‰
- æƒ³å–æˆ¿éœ€è¦å…ˆå»æˆ¿ç®¡å±€**åŠç†æˆæƒ**ï¼ˆapproveï¼‰ç»™ä¸­ä»‹æˆ–ä¹°å®¶
- ä¸­ä»‹å¯ä»¥ä»£ä¸º**åŠç†è¿‡æˆ·**ï¼ˆtransferFromï¼‰
- æ¯å¥—æˆ¿å­çš„**è¯¦ç»†ä¿¡æ¯**ï¼ˆé¢ç§¯ã€æˆ·å‹ã€åœ°å€ï¼‰è®°å½•åœ¨æ¡£æ¡ˆä¸­ï¼ˆtokenURI â†’ metadataï¼‰

**å¯¹åº”å…³ç³»ï¼š**

| æˆ¿äº§è¯ç³»ç»Ÿ | ERC721 | è¯´æ˜ |
|-----------|--------|------|
| æˆ¿äº§è¯å· | tokenId | å”¯ä¸€æ ‡è¯†ç¬¦ |
| æ‰€æœ‰è€…å§“å | ownerOf(tokenId) | å½“å‰æ‰€æœ‰è€… |
| æŸäººåä¸‹æˆ¿äº§æ•° | balanceOf(address) | æŒæœ‰çš„NFTæ•°é‡ |
| æˆæƒä¸­ä»‹ä»£å”® | approve(ä¸­ä»‹, tokenId) | æˆæƒå•ä¸ªNFT |
| æˆæƒä¸­ä»‹ä»£å”®æ‰€æœ‰æˆ¿äº§ | setApprovalForAll(ä¸­ä»‹, true) | æˆæƒæ‰€æœ‰NFT |
| è¿‡æˆ· | transferFrom(å–å®¶, ä¹°å®¶, tokenId) | è½¬ç§»æ‰€æœ‰æƒ |
| æˆ¿äº§æ¡£æ¡ˆä¿¡æ¯ | tokenURI â†’ metadata | NFTå…ƒæ•°æ® |

**ä¸¾ä¾‹ï¼ˆ10å²å°æœ‹å‹èƒ½æ‡‚ï¼‰ï¼š**

> å°æ˜æœ‰ä¸€å¼ ç‰¹åˆ«çš„å¡ç‰‡ï¼Œä¸Šé¢å†™ç€ "å¡ç‰‡#001"ã€‚è¿™å¼ å¡ç‰‡å…¨ä¸–ç•Œåªæœ‰ä¸€å¼ ï¼
>
> - **æŸ¥çœ‹å½’å±**ï¼šä»»ä½•äººéƒ½å¯ä»¥çœ‹åˆ°"å¡ç‰‡#001å±äºå°æ˜"
> - **æ•°é‡ç»Ÿè®¡**ï¼šå°æ˜ä¸€å…±æœ‰3å¼ ç‹¬ç‰¹å¡ç‰‡ï¼ˆ#001, #015, #088ï¼‰
> - **æˆæƒæœ‹å‹**ï¼šå°æ˜è¯´"å°çº¢å¯ä»¥å¸®æˆ‘å–æ‰å¡ç‰‡#001"
> - **å–å‡ºå¡ç‰‡**ï¼šå°çº¢å¸®å°æ˜æŠŠå¡ç‰‡#001å–ç»™äº†å°åˆšï¼Œç°åœ¨å¡ç‰‡#001å±äºå°åˆš
> - **å¡ç‰‡ä¿¡æ¯**ï¼šæ‰«æå¡ç‰‡ä¸Šçš„äºŒç»´ç ï¼Œå¯ä»¥çœ‹åˆ°è¿™å¼ å¡ç‰‡çš„å›¾ç‰‡å’Œè¯¦ç»†ä¿¡æ¯
>
> ERC721å°±åƒä¸€ä¸ªç®¡ç†è¿™äº›ç‹¬ç‰¹å¡ç‰‡çš„ç³»ç»Ÿï¼Œç¡®ä¿æ¯å¼ å¡ç‰‡éƒ½æœ‰ä¸»äººï¼Œè€Œä¸”å¯ä»¥å®‰å…¨åœ°ä¹°å–ï¼

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šERC721 = æ•°æ®åº“ä¸­çš„å”¯ä¸€è®°å½•

å¦‚æœä½ ç†Ÿæ‚‰åç«¯å¼€å‘ï¼ŒERC721å°±åƒä¸€ä¸ª**ä¸»é”®å”¯ä¸€çš„æ•°æ®åº“è¡¨**ï¼š

```javascript
// ERC721å°±åƒä¸€ä¸ªæ•°æ®åº“è¡¨
// tokenId æ˜¯ä¸»é”®ï¼ˆPRIMARY KEYï¼‰ï¼Œç¡®ä¿å”¯ä¸€æ€§

// æ•°æ®åº“æ¨¡å‹
const NFTTable = {
    // ä¸»é”® â†’ æ‰€æœ‰è€…ï¼ˆæ ¸å¿ƒæ˜ å°„ï¼‰
    records: {
        1: { owner: "0xAlice", approved: null },
        2: { owner: "0xBob", approved: "0xMarketplace" },
        3: { owner: "0xAlice", approved: null }
    },

    // ownerOf: SELECT owner FROM nfts WHERE tokenId = ?
    ownerOf(tokenId) {
        return this.records[tokenId]?.owner;
    },

    // balanceOf: SELECT COUNT(*) FROM nfts WHERE owner = ?
    balanceOf(owner) {
        return Object.values(this.records)
            .filter(r => r.owner === owner).length;
    },

    // transferFrom: UPDATE nfts SET owner = ? WHERE tokenId = ?
    transferFrom(from, to, tokenId) {
        if (this.records[tokenId].owner !== from) throw new Error("Not owner");
        this.records[tokenId].owner = to;
        this.records[tokenId].approved = null; // æ¸…é™¤æˆæƒ
    }
};
```

**æ›´è¯¦ç»†çš„å‰ç«¯ç±»æ¯”ï¼š**

```javascript
// ERC721çš„æˆæƒæœºåˆ¶ ç±»ä¼¼äº RBACæƒé™ç³»ç»Ÿ

// å•ä¸ªèµ„æºæˆæƒï¼ˆapproveï¼‰ç±»ä¼¼äºï¼š
const resourcePermissions = {
    "nft_001": { allowedUser: "marketplace_contract" },
    "nft_002": { allowedUser: null }
};

// æ£€æŸ¥æ˜¯å¦æœ‰æƒé™æ“ä½œç‰¹å®šNFT
function canOperate(operator, tokenId) {
    return resourcePermissions[tokenId]?.allowedUser === operator;
}

// å…¨éƒ¨æˆæƒï¼ˆsetApprovalForAllï¼‰ç±»ä¼¼äºï¼š
const operatorPermissions = {
    "alice": {
        "marketplace": true,  // Aliceæˆæƒmarketplaceæ“ä½œå¥¹æ‰€æœ‰NFT
        "lending_protocol": false
    }
};

// æ£€æŸ¥æ˜¯å¦æ˜¯æˆæƒçš„æ“ä½œå‘˜
function isApprovedOperator(owner, operator) {
    return operatorPermissions[owner]?.[operator] === true;
}
```

**tokenURI ç±»ä¼¼äº å¤–é”®å…³è”ï¼š**

```javascript
// tokenURIå°±åƒæ•°æ®åº“çš„å¤–é”®ï¼ŒæŒ‡å‘è¯¦ç»†ä¿¡æ¯è¡¨
// NFTè¡¨åªå­˜tokenIdå’Œownerï¼Œè¯¦ç»†ä¿¡æ¯å­˜åœ¨å¦ä¸€ä¸ªåœ°æ–¹

// ä¸»è¡¨ï¼ˆé“¾ä¸Šï¼‰
const nftTable = {
    1: { owner: "0xAlice", metadataRef: "ipfs://Qm.../1.json" }
};

// è¯¦æƒ…è¡¨ï¼ˆé“¾ä¸‹ï¼Œé€šè¿‡metadataRefå…³è”ï¼‰
// ipfs://Qm.../1.json çš„å†…å®¹ï¼š
const metadataTable = {
    "ipfs://Qm.../1.json": {
        name: "Cool NFT #1",
        image: "ipfs://Qm.../1.png",
        attributes: [...]
    }
};

// è·å–å®Œæ•´NFTä¿¡æ¯ï¼ˆJOINæ“ä½œï¼‰
async function getFullNFTInfo(tokenId) {
    const nft = nftTable[tokenId];
    const metadata = await fetch(nft.metadataRef).then(r => r.json());
    return { ...nft, ...metadata };
}
```

---

### ç±»æ¯”2ï¼šsafeTransferFromå®‰å…¨è½¬è´¦ ğŸ›¡ï¸

#### ç”Ÿæ´»åœºæ™¯ç±»æ¯”ï¼šsafeTransferFrom = å¿«é€’ç­¾æ”¶ç¡®è®¤

æƒ³è±¡ä½ å¯„ä¸€ä¸ªé‡è¦åŒ…è£¹ï¼š

**æ™®é€šå¿«é€’ï¼ˆtransferFromï¼‰ï¼š**
- å¿«é€’å‘˜æŠŠåŒ…è£¹æ”¾åœ¨é—¨å£å°±èµ°äº†
- å¦‚æœæ”¶ä»¶äººä¸åœ¨å®¶æˆ–åœ°å€æ˜¯ä¸ªç©ºåœ°ï¼ŒåŒ…è£¹å°±ä¸¢äº†

**å®‰å…¨å¿«é€’ï¼ˆsafeTransferFromï¼‰ï¼š**
- å¿«é€’å‘˜å¿…é¡»ç­‰æ”¶ä»¶äººç­¾æ”¶
- æ”¶ä»¶äººéœ€è¦å‡ºç¤ºèº«ä»½è¯ç¡®è®¤èƒ½æ¥æ”¶
- å¦‚æœæ”¶ä»¶äººæ— æ³•ç­¾æ”¶ï¼ŒåŒ…è£¹é€€å›ç»™å¯„ä»¶äºº

```solidity
// safeTransferFromçš„æ£€æŸ¥è¿‡ç¨‹
// 1. æ£€æŸ¥æ”¶ä»¶äººæ˜¯å¦æ˜¯"åˆçº¦"ï¼ˆç›¸å½“äºæ£€æŸ¥æ˜¯å¦æ˜¯å…¬å¸åœ°å€ï¼‰
// 2. å¦‚æœæ˜¯åˆçº¦ï¼Œè¦æ±‚å¯¹æ–¹å®ç°"ç­¾æ”¶å‡½æ•°"ï¼ˆonERC721Receivedï¼‰
// 3. å¯¹æ–¹è¿”å›æ­£ç¡®çš„"ç­¾æ”¶ç¡®è®¤ç "ï¼Œè½¬è´¦æ‰æˆåŠŸ
```

---

#### å‰ç«¯é¢†åŸŸç±»æ¯”ï¼šsafeTransferFrom = APIè¯·æ±‚çš„ç±»å‹æ£€æŸ¥

```javascript
// transferFrom åƒæ˜¯ä¸æ£€æŸ¥å“åº”çš„fetch
async function unsafeSend(data) {
    await fetch('/api/receive', { method: 'POST', body: data });
    // ä¸ç®¡å¯¹æ–¹èƒ½ä¸èƒ½å¤„ç†ï¼Œå‘äº†å°±å®Œäº‹
}

// safeTransferFrom åƒæ˜¯æœ‰ç±»å‹æ£€æŸ¥çš„fetch
async function safeSend(data) {
    const response = await fetch('/api/receive', { method: 'POST', body: data });
    const result = await response.json();

    // æ£€æŸ¥å¯¹æ–¹æ˜¯å¦æ­£ç¡®å¤„ç†äº†æ•°æ®
    if (result.status !== 'RECEIVED_OK') {
        throw new Error('Receiver cannot handle this data');
    }
}

// ç±»ä¼¼äºonERC721Receivedæ¥å£
interface NFTReceiver {
    onReceive(data: NFTData): 'RECEIVED_OK' | Error;
}
```

---

### ç±»æ¯”æ€»ç»“è¡¨

| ERC721æ¦‚å¿µ | ç”Ÿæ´»åœºæ™¯ç±»æ¯” | å‰ç«¯é¢†åŸŸç±»æ¯” |
|-----------|-------------|-------------|
| **ERC721æ ‡å‡†** | æˆ¿äº§è¯/è‰ºæœ¯å“è¯ä¹¦ç³»ç»Ÿ | ä¸»é”®å”¯ä¸€çš„æ•°æ®åº“è¡¨ |
| **tokenId** | æˆ¿äº§è¯å·ã€è‰ºæœ¯å“ç¼–å· | æ•°æ®åº“ä¸»é”®ï¼ˆPRIMARY KEYï¼‰ |
| **ownerOf** | æŸ¥è¯¢æˆ¿äº§æ‰€æœ‰è€… | SELECT owner WHERE id = ? |
| **balanceOf** | æŸäººåä¸‹æˆ¿äº§æ•°é‡ | SELECT COUNT(*) WHERE owner = ? |
| **transferFrom** | æˆ¿äº§è¿‡æˆ· | UPDATE SET owner = ? |
| **approve** | æˆæƒä¸­ä»‹ä»£å”®å•å¥—æˆ¿ | å•èµ„æºæƒé™æˆæƒ |
| **setApprovalForAll** | æˆæƒä¸­ä»‹ä»£å”®æ‰€æœ‰æˆ¿äº§ | æ“ä½œå‘˜å…¨å±€æˆæƒï¼ˆRBACï¼‰ |
| **safeTransferFrom** | å¿«é€’ç­¾æ”¶ç¡®è®¤ | å¸¦ç±»å‹æ£€æŸ¥çš„APIè°ƒç”¨ |
| **tokenURI** | æˆ¿äº§æ¡£æ¡ˆçš„å­˜æ”¾ä½ç½® | å¤–é”®å…³è”è¯¦æƒ…è¡¨ |
| **metadata** | æˆ¿äº§è¯¦ç»†ä¿¡æ¯ï¼ˆé¢ç§¯ã€æˆ·å‹ç­‰ï¼‰ | å…³è”è¡¨ä¸­çš„è¯¦ç»†æ•°æ® |
| **Transferäº‹ä»¶** | æˆ¿äº§è¿‡æˆ·ç™»è®°é€šçŸ¥ | æ•°æ®å˜æ›´webhook |

---

## 6. ã€åç›´è§‰ç‚¹ã€‘

### è¯¯åŒº1ï¼šNFTå›¾ç‰‡å­˜åœ¨åŒºå—é“¾ä¸Š âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

å¾ˆå¤šäººä»¥ä¸ºä¹°äº†NFTå°±æ˜¯ä¹°äº†åŒºå—é“¾ä¸Šçš„å›¾ç‰‡ï¼Œå®é™…ä¸Šï¼š

- **é“¾ä¸Šå­˜å‚¨çš„åªæ˜¯tokenIdå’Œæ‰€æœ‰æƒæ˜ å°„**
- **å›¾ç‰‡å’Œå…ƒæ•°æ®å­˜å‚¨åœ¨é“¾ä¸‹**ï¼ˆIPFSã€Arweaveæˆ–ä¸­å¿ƒåŒ–æœåŠ¡å™¨ï¼‰
- `tokenURI`åªæ˜¯ä¸€ä¸ªæŒ‡å‘å…ƒæ•°æ®çš„URL

```solidity
// é“¾ä¸Šåªå­˜è¿™äº›
mapping(uint256 => address) private _owners;        // tokenId â†’ æ‰€æœ‰è€…
mapping(uint256 => string) private _tokenURIs;      // tokenId â†’ å…ƒæ•°æ®URL

// å…ƒæ•°æ®URLæŒ‡å‘çš„å†…å®¹ï¼ˆé“¾ä¸‹ï¼‰
// ipfs://QmXxx.../1.json
{
    "name": "My NFT",
    "image": "ipfs://QmYyy.../image.png"  // å›¾ç‰‡ä¹Ÿåœ¨é“¾ä¸‹
}
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å› ä¸º"æ‹¥æœ‰NFT"ç»™äººçš„æ„Ÿè§‰åƒæ˜¯"æ‹¥æœ‰é‚£å¼ å›¾ç‰‡"ï¼Œä½†å®é™…ä¸Šä½ æ‹¥æœ‰çš„æ˜¯**é“¾ä¸Šçš„æ‰€æœ‰æƒè®°å½•**ï¼Œå›¾ç‰‡å¯èƒ½å­˜åœ¨ä»»ä½•åœ°æ–¹ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// NFTçš„ä»·å€¼ç»„æˆ
const nftValue = {
    onChain: {
        tokenId: 123,           // âœ… é“¾ä¸Šï¼šå”¯ä¸€æ ‡è¯†
        owner: "0xAlice",       // âœ… é“¾ä¸Šï¼šæ‰€æœ‰æƒ
        tokenURI: "ipfs://..."  // âœ… é“¾ä¸Šï¼šå…ƒæ•°æ®æŒ‡é’ˆ
    },
    offChain: {
        image: "ipfs://...",    // âŒ é“¾ä¸‹ï¼šå›¾ç‰‡æ–‡ä»¶
        metadata: { ... }        // âŒ é“¾ä¸‹ï¼šå±æ€§ä¿¡æ¯
    }
};

// é£é™©ï¼šå¦‚æœå…ƒæ•°æ®æœåŠ¡å™¨ä¸‹çº¿æˆ–IPFSå†…å®¹è¢«å–æ¶ˆPin
// ä½ ä»ç„¶"æ‹¥æœ‰"è¿™ä¸ªtokenIdï¼Œä½†å¯èƒ½çœ‹ä¸åˆ°å›¾ç‰‡äº†

// æœ€ä½³å®è·µï¼š
// 1. ä½¿ç”¨IPFSæˆ–Arweaveå­˜å‚¨ï¼ˆå»ä¸­å¿ƒåŒ–ï¼‰
// 2. ç¡®ä¿æœ‰å¤šä¸ªPinæœåŠ¡å¤‡ä»½
// 3. é“¾ä¸ŠSVGï¼ˆå®Œå…¨å»ä¸­å¿ƒåŒ–ï¼Œä½†Gasæˆæœ¬é«˜ï¼‰
```

---

### è¯¯åŒº2ï¼šæ‹¥æœ‰NFTå°±æ‹¥æœ‰ç‰ˆæƒ âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

NFTä»£è¡¨çš„æ˜¯**æ•°å­—èµ„äº§çš„æ‰€æœ‰æƒ**ï¼Œä¸æ˜¯**çŸ¥è¯†äº§æƒ/ç‰ˆæƒ**ï¼š

```javascript
// å¸¸è§è¯¯è§£
"æˆ‘ä¹°äº†è¿™ä¸ªNFTï¼Œæ‰€ä»¥æˆ‘æ‹¥æœ‰è¿™å¹…ç”»çš„ç‰ˆæƒï¼Œå¯ä»¥å•†ç”¨ã€å°Tæ¤å–"

// å®é™…æƒ…å†µ
// NFTæ‰€æœ‰æƒ â‰  ç‰ˆæƒ
// é™¤éåˆ›ä½œè€…æ˜ç¡®åœ¨åˆçº¦æˆ–æ¡æ¬¾ä¸­è½¬è®©ç‰ˆæƒ

// ä¸åŒé¡¹ç›®çš„ç‰ˆæƒç­–ç•¥
const copyrightPolicies = {
    "Bored Ape Yacht Club": "æŒæœ‰è€…æ‹¥æœ‰å•†ä¸šä½¿ç”¨æƒ",
    "CryptoPunks": "Yuga LabsæŒæœ‰ç‰ˆæƒï¼ŒæŒæœ‰è€…æœ‰æœ‰é™ä½¿ç”¨æƒ",
    "å¤§å¤šæ•°NFTé¡¹ç›®": "åˆ›ä½œè€…ä¿ç•™ç‰ˆæƒï¼ŒæŒæœ‰è€…åªæœ‰å±•ç¤ºæƒ"
};
```

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å› ä¸ºåœ¨ç°å®ä¸–ç•Œä¸­ï¼Œä¹°äº†ä¸€å¹…åŸä½œé€šå¸¸æ„å‘³ç€å¯ä»¥è‡ªç”±ä½¿ç”¨å®ƒã€‚ä½†æ•°å­—è‰ºæœ¯çš„"æ‰€æœ‰æƒ"å’Œ"ç‰ˆæƒ"æ˜¯åˆ†å¼€çš„æ¦‚å¿µã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// NFTè´­ä¹°æ—¶è¦ç¡®è®¤çš„æƒåˆ©
const nftRights = {
    // é€šå¸¸ä¼šè·å¾—çš„æƒåˆ©
    display: true,           // å±•ç¤ºæƒï¼ˆå¯ä»¥ç§€ï¼‰
    resale: true,            // è½¬å”®æƒï¼ˆå¯ä»¥å–ï¼‰

    // éœ€è¦æ˜ç¡®æˆæƒçš„æƒåˆ©
    commercialUse: false,    // å•†ä¸šä½¿ç”¨ï¼ˆå°Tæ¤ã€åšå¹¿å‘Šï¼‰
    derivative: false,       // äºŒæ¬¡åˆ›ä½œï¼ˆæ”¹å›¾ã€åšè¡¨æƒ…åŒ…ï¼‰
    reproduction: false      // å¤åˆ¶æƒï¼ˆå¤§é‡å°åˆ·ï¼‰
};

// è´­ä¹°å‰åº”è¯¥ï¼š
// 1. é˜…è¯»é¡¹ç›®çš„Terms of Service
// 2. æŸ¥çœ‹åˆçº¦ä¸­æ˜¯å¦æœ‰ç‰ˆæƒå£°æ˜
// 3. ç¡®è®¤åˆ›ä½œè€…çš„æˆæƒèŒƒå›´
```

---

### è¯¯åŒº3ï¼šERC721çš„approveå’ŒERC20å®Œå…¨ä¸€æ · âŒ

**ä¸ºä»€ä¹ˆé”™ï¼Ÿ**

ERC721æœ‰ä¸¤ç§æˆæƒæ–¹å¼ï¼Œæ¯”ERC20æ›´å¤æ‚ï¼š

```solidity
// ERC20ï¼šåªæœ‰ä¸€ç§æˆæƒæ–¹å¼
function approve(address spender, uint256 amount);
// æˆæƒspenderæœ€å¤šèŠ±è´¹amountæ•°é‡çš„ä»£å¸

// ERC721ï¼šä¸¤ç§æˆæƒæ–¹å¼
function approve(address to, uint256 tokenId);
// æ–¹å¼1ï¼šæˆæƒtoæ“ä½œç‰¹å®šçš„tokenIdï¼ˆåªèƒ½æˆæƒä¸€ä¸ªåœ°å€ï¼‰

function setApprovalForAll(address operator, bool approved);
// æ–¹å¼2ï¼šæˆæƒoperatoræ“ä½œä½ æ‰€æœ‰çš„NFT
```

**å…³é”®åŒºåˆ«ï¼š**

| ç‰¹æ€§ | ERC20 approve | ERC721 approve | ERC721 setApprovalForAll |
|-----|--------------|----------------|--------------------------|
| æˆæƒèŒƒå›´ | æŒ‡å®šæ•°é‡çš„ä»£å¸ | å•ä¸ªtokenId | æ‰€æœ‰NFT |
| æˆæƒå¯¹è±¡ | ä¸€ä¸ªspender | ä¸€ä¸ªåœ°å€ | ä¸€ä¸ªoperator |
| å¯åŒæ—¶æˆæƒå¤šä¸ªåœ°å€ | âœ…ï¼ˆä¸åŒspenderä¸åŒé¢åº¦ï¼‰ | âŒï¼ˆæ¯ä¸ªtokenIdåªèƒ½æˆæƒä¸€ä¸ªï¼‰ | âœ…ï¼ˆå¤šä¸ªoperatorï¼‰ |
| è½¬è´¦åæˆæƒçŠ¶æ€ | ä¿æŒï¼ˆé¢åº¦å‡å°‘ï¼‰ | æ¸…é™¤ | ä¿æŒ |

**ä¸ºä»€ä¹ˆäººä»¬å®¹æ˜“è¿™æ ·é”™ï¼Ÿ**

å› ä¸ºå‡½æ•°åéƒ½å«`approve`ï¼Œå®¹æ˜“æ··æ·†ä¸¤ä¸ªæ ‡å‡†çš„æˆæƒæœºåˆ¶ã€‚

**æ­£ç¡®ç†è§£ï¼š**

```javascript
// ERC721æˆæƒåœºæ™¯

// åœºæ™¯1ï¼šåªå–ä¸€ä¸ªNFT
// ç”¨approveæˆæƒå•ä¸ªtokenIdç»™å¸‚åœº
await nft.approve(marketplaceAddress, tokenId);

// åœºæ™¯2ï¼šåœ¨å¸‚åœºä¸Šæ¶å¤šä¸ªNFT
// ç”¨setApprovalForAllä¸€æ¬¡æˆæƒæ‰€æœ‰
await nft.setApprovalForAll(marketplaceAddress, true);

// æ³¨æ„ï¼šæ¯ä¸ªtokenIdåªèƒ½approveç»™ä¸€ä¸ªåœ°å€ï¼
await nft.approve(alice, 1);  // tokenId 1 æˆæƒç»™ Alice
await nft.approve(bob, 1);    // è¦†ç›–ï¼tokenId 1 ç°åœ¨åªæˆæƒç»™ Bob

// ä½†setApprovalForAllå¯ä»¥åŒæ—¶æˆæƒå¤šä¸ªoperator
await nft.setApprovalForAll(opensea, true);
await nft.setApprovalForAll(blur, true);
// openseaå’Œbluréƒ½å¯ä»¥æ“ä½œä½ çš„æ‰€æœ‰NFT
```

---

## 7. ã€å®æˆ˜ä»£ç ã€‘

### åŸºç¡€å®ç°ï¼šåˆ›å»ºNFTåˆçº¦

**Solidityåˆçº¦ï¼ˆå®Œæ•´ç‰ˆï¼‰ï¼š**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title MyNFTCollection
 * @dev ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„NFTåˆçº¦ç¤ºä¾‹
 */
contract MyNFTCollection is ERC721, ERC721URIStorage, ERC721Enumerable, Ownable {
    using Strings for uint256;

    // ===== çŠ¶æ€å˜é‡ =====
    uint256 private _tokenIdCounter;
    uint256 public maxSupply = 10000;
    uint256 public mintPrice = 0.01 ether;
    string private _baseTokenURI;
    bool public mintingEnabled = false;

    // ===== äº‹ä»¶ =====
    event Minted(address indexed to, uint256 indexed tokenId);
    event BaseURIChanged(string newBaseURI);

    // ===== æ„é€ å‡½æ•° =====
    constructor(
        string memory name,
        string memory symbol,
        string memory baseURI
    ) ERC721(name, symbol) Ownable(msg.sender) {
        _baseTokenURI = baseURI;
    }

    // ===== é“¸é€ å‡½æ•° =====

    /**
     * @dev å…¬å¼€é“¸é€ ï¼ˆä»˜è´¹ï¼‰
     */
    function mint() public payable {
        require(mintingEnabled, "Minting is not enabled");
        require(msg.value >= mintPrice, "Insufficient payment");
        require(_tokenIdCounter < maxSupply, "Max supply reached");

        _tokenIdCounter++;
        uint256 tokenId = _tokenIdCounter;

        _safeMint(msg.sender, tokenId);

        emit Minted(msg.sender, tokenId);
    }

    /**
     * @dev æ‰¹é‡é“¸é€ 
     */
    function batchMint(uint256 quantity) public payable {
        require(mintingEnabled, "Minting is not enabled");
        require(msg.value >= mintPrice * quantity, "Insufficient payment");
        require(_tokenIdCounter + quantity <= maxSupply, "Exceeds max supply");

        for (uint256 i = 0; i < quantity; i++) {
            _tokenIdCounter++;
            _safeMint(msg.sender, _tokenIdCounter);
            emit Minted(msg.sender, _tokenIdCounter);
        }
    }

    /**
     * @dev ç®¡ç†å‘˜é“¸é€ ï¼ˆå…è´¹ï¼Œç”¨äºç©ºæŠ•ç­‰ï¼‰
     */
    function adminMint(address to, uint256 quantity) public onlyOwner {
        require(_tokenIdCounter + quantity <= maxSupply, "Exceeds max supply");

        for (uint256 i = 0; i < quantity; i++) {
            _tokenIdCounter++;
            _safeMint(to, _tokenIdCounter);
            emit Minted(to, _tokenIdCounter);
        }
    }

    // ===== æŸ¥è¯¢å‡½æ•° =====

    /**
     * @dev è¿”å›tokenURI
     */
    function tokenURI(uint256 tokenId)
        public view override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        require(_ownerOf(tokenId) != address(0), "Token does not exist");

        // å¦‚æœæœ‰å•ç‹¬è®¾ç½®çš„URIï¼Œä½¿ç”¨å®ƒ
        string memory _tokenURI = super.tokenURI(tokenId);
        if (bytes(_tokenURI).length > 0) {
            return _tokenURI;
        }

        // å¦åˆ™ä½¿ç”¨baseURI + tokenId
        return string(abi.encodePacked(_baseTokenURI, tokenId.toString(), ".json"));
    }

    /**
     * @dev è·å–ç”¨æˆ·æ‹¥æœ‰çš„æ‰€æœ‰tokenId
     */
    function tokensOfOwner(address owner) public view returns (uint256[] memory) {
        uint256 balance = balanceOf(owner);
        uint256[] memory tokens = new uint256[](balance);

        for (uint256 i = 0; i < balance; i++) {
            tokens[i] = tokenOfOwnerByIndex(owner, i);
        }

        return tokens;
    }

    /**
     * @dev å½“å‰å·²é“¸é€ æ•°é‡
     */
    function totalMinted() public view returns (uint256) {
        return _tokenIdCounter;
    }

    // ===== ç®¡ç†å‡½æ•° =====

    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseTokenURI = baseURI;
        emit BaseURIChanged(baseURI);
    }

    function setMintPrice(uint256 price) public onlyOwner {
        mintPrice = price;
    }

    function setMintingEnabled(bool enabled) public onlyOwner {
        mintingEnabled = enabled;
    }

    function withdraw() public onlyOwner {
        uint256 balance = address(this).balance;
        payable(owner()).transfer(balance);
    }

    // ===== å¿…é¡»çš„é‡å†™å‡½æ•° =====

    function _update(address to, uint256 tokenId, address auth)
        internal override(ERC721, ERC721Enumerable)
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(address account, uint128 value)
        internal override(ERC721, ERC721Enumerable)
    {
        super._increaseBalance(account, value);
    }

    function supportsInterface(bytes4 interfaceId)
        public view override(ERC721, ERC721URIStorage, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

---

### å‰ç«¯é›†æˆï¼šå®Œæ•´çš„NFTäº¤äº’ç¤ºä¾‹

```javascript
// ===== 1. å®‰è£…ä¾èµ– =====
// npm install ethers

const { ethers } = require('ethers');

// ===== 2. ERC721 ABI =====
const ERC721_ABI = [
    // å…ƒæ•°æ®
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function tokenURI(uint256 tokenId) view returns (string)",

    // æŸ¥è¯¢
    "function balanceOf(address owner) view returns (uint256)",
    "function ownerOf(uint256 tokenId) view returns (address)",
    "function totalSupply() view returns (uint256)",
    "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
    "function tokenByIndex(uint256 index) view returns (uint256)",

    // æˆæƒæŸ¥è¯¢
    "function getApproved(uint256 tokenId) view returns (address)",
    "function isApprovedForAll(address owner, address operator) view returns (bool)",

    // å†™å…¥å‡½æ•°
    "function approve(address to, uint256 tokenId)",
    "function setApprovalForAll(address operator, bool approved)",
    "function transferFrom(address from, address to, uint256 tokenId)",
    "function safeTransferFrom(address from, address to, uint256 tokenId)",
    "function safeTransferFrom(address from, address to, uint256 tokenId, bytes data)",

    // é“¸é€ ï¼ˆæ ¹æ®åˆçº¦å®é™…æƒ…å†µï¼‰
    "function mint() payable",
    "function mintPrice() view returns (uint256)",
    "function maxSupply() view returns (uint256)",
    "function totalMinted() view returns (uint256)",
    "function tokensOfOwner(address owner) view returns (uint256[])",

    // äº‹ä»¶
    "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",
    "event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)",
    "event ApprovalForAll(address indexed owner, address indexed operator, bool approved)"
];

// ===== 3. è¿æ¥è®¾ç½® =====
const provider = new ethers.JsonRpcProvider('https://eth-sepolia.g.alchemy.com/v2/YOUR_KEY');
const NFT_ADDRESS = "0x..."; // ä½ çš„NFTåˆçº¦åœ°å€

const nftContract = new ethers.Contract(NFT_ADDRESS, ERC721_ABI, provider);

// ===== 4. åœºæ™¯1ï¼šè¯»å–Collectionä¿¡æ¯ =====
async function getCollectionInfo() {
    console.log("=== åœºæ™¯1ï¼šè¯»å–Collectionä¿¡æ¯ ===\n");

    const name = await nftContract.name();
    const symbol = await nftContract.symbol();
    const totalSupply = await nftContract.totalSupply();
    const maxSupply = await nftContract.maxSupply();
    const mintPrice = await nftContract.mintPrice();

    console.log(`Collection: ${name} (${symbol})`);
    console.log(`å·²é“¸é€ : ${totalSupply} / ${maxSupply}`);
    console.log(`é“¸é€ ä»·æ ¼: ${ethers.formatEther(mintPrice)} ETH`);
}

// ===== 5. åœºæ™¯2ï¼šè·å–ç”¨æˆ·çš„NFTåˆ—è¡¨ =====
async function getUserNFTs(userAddress) {
    console.log("\n=== åœºæ™¯2ï¼šè·å–ç”¨æˆ·NFTåˆ—è¡¨ ===\n");

    const balance = await nftContract.balanceOf(userAddress);
    console.log(`${userAddress} æ‹¥æœ‰ ${balance} ä¸ªNFT`);

    if (balance === 0n) return [];

    // æ–¹å¼1ï¼šå¦‚æœåˆçº¦æœ‰tokensOfOwnerå‡½æ•°ï¼ˆæ¨èï¼‰
    try {
        const tokenIds = await nftContract.tokensOfOwner(userAddress);
        console.log(`Token IDs: ${tokenIds.join(', ')}`);
        return tokenIds;
    } catch {
        // æ–¹å¼2ï¼šä½¿ç”¨ERC721Enumerableçš„tokenOfOwnerByIndex
        const tokenIds = [];
        for (let i = 0; i < balance; i++) {
            const tokenId = await nftContract.tokenOfOwnerByIndex(userAddress, i);
            tokenIds.push(tokenId);
        }
        console.log(`Token IDs: ${tokenIds.join(', ')}`);
        return tokenIds;
    }
}

// ===== 6. åœºæ™¯3ï¼šè·å–NFTå…ƒæ•°æ® =====
async function getNFTMetadata(tokenId) {
    console.log(`\n=== åœºæ™¯3ï¼šè·å–NFT #${tokenId} å…ƒæ•°æ® ===\n`);

    // è·å–æ‰€æœ‰è€…
    const owner = await nftContract.ownerOf(tokenId);
    console.log(`æ‰€æœ‰è€…: ${owner}`);

    // è·å–tokenURI
    const tokenURI = await nftContract.tokenURI(tokenId);
    console.log(`Token URI: ${tokenURI}`);

    // è§£æå…ƒæ•°æ®
    let metadataURL = tokenURI;
    if (tokenURI.startsWith("ipfs://")) {
        metadataURL = tokenURI.replace("ipfs://", "https://ipfs.io/ipfs/");
    }

    try {
        const response = await fetch(metadataURL);
        const metadata = await response.json();

        console.log(`åç§°: ${metadata.name}`);
        console.log(`æè¿°: ${metadata.description}`);
        console.log(`å›¾ç‰‡: ${metadata.image}`);

        if (metadata.attributes) {
            console.log("å±æ€§:");
            metadata.attributes.forEach(attr => {
                console.log(`  ${attr.trait_type}: ${attr.value}`);
            });
        }

        return metadata;
    } catch (error) {
        console.log(`æ— æ³•è·å–å…ƒæ•°æ®: ${error.message}`);
        return null;
    }
}

// ===== 7. åœºæ™¯4ï¼šé“¸é€ NFT =====
async function mintNFT(privateKey) {
    console.log("\n=== åœºæ™¯4ï¼šé“¸é€ NFT ===\n");

    const wallet = new ethers.Wallet(privateKey, provider);
    const contractWithSigner = nftContract.connect(wallet);

    // è·å–é“¸é€ ä»·æ ¼
    const mintPrice = await nftContract.mintPrice();
    console.log(`é“¸é€ ä»·æ ¼: ${ethers.formatEther(mintPrice)} ETH`);

    // æ£€æŸ¥ä½™é¢
    const balance = await provider.getBalance(wallet.address);
    console.log(`é’±åŒ…ä½™é¢: ${ethers.formatEther(balance)} ETH`);

    if (balance < mintPrice) {
        throw new Error("ä½™é¢ä¸è¶³");
    }

    // å‘é€é“¸é€ äº¤æ˜“
    console.log("æ­£åœ¨é“¸é€ ...");
    const tx = await contractWithSigner.mint({ value: mintPrice });
    console.log(`äº¤æ˜“å“ˆå¸Œ: ${tx.hash}`);

    // ç­‰å¾…ç¡®è®¤
    const receipt = await tx.wait();
    console.log(`äº¤æ˜“ç¡®è®¤ï¼åŒºå—: ${receipt.blockNumber}`);

    // ä»äº‹ä»¶ä¸­è·å–tokenId
    const transferEvent = receipt.logs.find(
        log => log.topics[0] === ethers.id("Transfer(address,address,uint256)")
    );

    if (transferEvent) {
        const tokenId = BigInt(transferEvent.topics[3]);
        console.log(`é“¸é€ æˆåŠŸï¼Token ID: ${tokenId}`);
        return tokenId;
    }

    return receipt;
}

// ===== 8. åœºæ™¯5ï¼šè½¬è´¦NFT =====
async function transferNFT(privateKey, to, tokenId) {
    console.log(`\n=== åœºæ™¯5ï¼šè½¬è´¦NFT #${tokenId} ===\n`);

    const wallet = new ethers.Wallet(privateKey, provider);
    const contractWithSigner = nftContract.connect(wallet);
    const from = wallet.address;

    // éªŒè¯æ‰€æœ‰æƒ
    const owner = await nftContract.ownerOf(tokenId);
    if (owner.toLowerCase() !== from.toLowerCase()) {
        throw new Error(`ä½ ä¸æ˜¯NFT #${tokenId}çš„æ‰€æœ‰è€…`);
    }

    console.log(`å‘é€æ–¹: ${from}`);
    console.log(`æ¥æ”¶æ–¹: ${to}`);
    console.log(`Token ID: ${tokenId}`);

    // ä½¿ç”¨safeTransferFromï¼ˆæ¨èï¼‰
    const tx = await contractWithSigner["safeTransferFrom(address,address,uint256)"](
        from, to, tokenId
    );
    console.log(`äº¤æ˜“å“ˆå¸Œ: ${tx.hash}`);

    const receipt = await tx.wait();
    console.log(`è½¬è´¦æˆåŠŸï¼`);

    return receipt;
}

// ===== 9. åœºæ™¯6ï¼šæˆæƒNFT =====
async function approveNFT(privateKey, operator, tokenId) {
    console.log(`\n=== åœºæ™¯6ï¼šæˆæƒNFT ===\n`);

    const wallet = new ethers.Wallet(privateKey, provider);
    const contractWithSigner = nftContract.connect(wallet);

    if (tokenId !== undefined) {
        // æˆæƒå•ä¸ªNFT
        console.log(`æˆæƒ Token #${tokenId} ç»™ ${operator}`);
        const tx = await contractWithSigner.approve(operator, tokenId);
        await tx.wait();
        console.log("å•ä¸ªNFTæˆæƒæˆåŠŸï¼");
    } else {
        // æˆæƒæ‰€æœ‰NFT
        console.log(`æˆæƒæ‰€æœ‰NFTç»™ ${operator}`);
        const tx = await contractWithSigner.setApprovalForAll(operator, true);
        await tx.wait();
        console.log("å…¨éƒ¨NFTæˆæƒæˆåŠŸï¼");
    }
}

// ===== 10. åœºæ™¯7ï¼šæ£€æŸ¥æˆæƒçŠ¶æ€ =====
async function checkApproval(ownerAddress, operatorAddress, tokenId) {
    console.log("\n=== åœºæ™¯7ï¼šæ£€æŸ¥æˆæƒçŠ¶æ€ ===\n");

    // æ£€æŸ¥å•ä¸ªNFTæˆæƒ
    if (tokenId !== undefined) {
        const approved = await nftContract.getApproved(tokenId);
        console.log(`Token #${tokenId} æˆæƒç»™: ${approved || 'æ— '}`);
    }

    // æ£€æŸ¥å…¨éƒ¨æˆæƒ
    const isApproved = await nftContract.isApprovedForAll(ownerAddress, operatorAddress);
    console.log(`${ownerAddress} æ˜¯å¦æˆæƒæ‰€æœ‰NFTç»™ ${operatorAddress}: ${isApproved}`);

    return isApproved;
}

// ===== 11. åœºæ™¯8ï¼šç›‘å¬Transferäº‹ä»¶ =====
async function listenTransfers() {
    console.log("\n=== åœºæ™¯8ï¼šç›‘å¬Transferäº‹ä»¶ ===\n");

    nftContract.on("Transfer", (from, to, tokenId, event) => {
        const action = from === ethers.ZeroAddress ? "é“¸é€ " : "è½¬è´¦";
        console.log(`\nğŸ¨ NFT ${action}äº‹ä»¶:`);
        console.log(`  From: ${from}`);
        console.log(`  To: ${to}`);
        console.log(`  Token ID: ${tokenId}`);
        console.log(`  äº¤æ˜“å“ˆå¸Œ: ${event.log.transactionHash}`);
    });

    console.log("æ­£åœ¨ç›‘å¬NFTè½¬è´¦äº‹ä»¶...");
}

// ===== 12. åœºæ™¯9ï¼šæŸ¥è¯¢å†å²é“¸é€ è®°å½• =====
async function getMintHistory(fromBlock = 0) {
    console.log("\n=== åœºæ™¯9ï¼šæŸ¥è¯¢é“¸é€ å†å² ===\n");

    // é“¸é€ äº‹ä»¶æ˜¯ä»é›¶åœ°å€è½¬å‡ºçš„Transfer
    const filter = nftContract.filters.Transfer(ethers.ZeroAddress);
    const events = await nftContract.queryFilter(filter, fromBlock);

    console.log(`å…± ${events.length} æ¬¡é“¸é€ `);

    // æ˜¾ç¤ºæœ€è¿‘5æ¬¡
    events.slice(-5).forEach(event => {
        console.log(`  Token #${event.args.tokenId} â†’ ${event.args.to.slice(0, 10)}...`);
    });

    return events;
}

// ===== 13. è¿è¡Œç¤ºä¾‹ =====
async function main() {
    try {
        // è¯»å–Collectionä¿¡æ¯
        await getCollectionInfo();

        // æŸ¥è¯¢ç¤ºä¾‹åœ°å€çš„NFTï¼ˆæ›¿æ¢ä¸ºå®é™…åœ°å€ï¼‰
        const userAddress = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045";
        await getUserNFTs(userAddress);

        // è·å–NFT #1 çš„å…ƒæ•°æ®
        await getNFTMetadata(1);

        // æ£€æŸ¥æˆæƒçŠ¶æ€
        const openseaSeaport = "0x1E0049783F008A0085193E00003D00cd54003c71";
        await checkApproval(userAddress, openseaSeaport, 1);

        // æ³¨æ„ï¼šä»¥ä¸‹æ“ä½œéœ€è¦ç§é’¥
        // await mintNFT(PRIVATE_KEY);
        // await transferNFT(PRIVATE_KEY, recipientAddress, tokenId);
        // await approveNFT(PRIVATE_KEY, marketplaceAddress, tokenId);

    } catch (error) {
        console.error("é”™è¯¯:", error.message);
    }
}

main();
```

**è¿è¡Œè¾“å‡ºç¤ºä¾‹ï¼š**

```
=== åœºæ™¯1ï¼šè¯»å–Collectionä¿¡æ¯ ===

Collection: My NFT Collection (MNFT)
å·²é“¸é€ : 1234 / 10000
é“¸é€ ä»·æ ¼: 0.01 ETH

=== åœºæ™¯2ï¼šè·å–ç”¨æˆ·NFTåˆ—è¡¨ ===

0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045 æ‹¥æœ‰ 3 ä¸ªNFT
Token IDs: 42, 156, 789

=== åœºæ™¯3ï¼šè·å–NFT #42 å…ƒæ•°æ® ===

æ‰€æœ‰è€…: 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
Token URI: ipfs://QmXxx.../42.json
åç§°: Cool NFT #42
æè¿°: A unique digital collectible
å›¾ç‰‡: ipfs://QmYyy.../42.png
å±æ€§:
  Background: Blue
  Eyes: Laser
  Fur: Golden

=== åœºæ™¯7ï¼šæ£€æŸ¥æˆæƒçŠ¶æ€ ===

Token #42 æˆæƒç»™: 0x0000000000000000000000000000000000000000
0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045 æ˜¯å¦æˆæƒæ‰€æœ‰NFTç»™ 0x1E00...: false
```

---

## 8. ã€é¢è¯•å¿…é—®ã€‘

### é—®é¢˜1ï¼š"ERC721å’ŒERC20çš„æ ¸å¿ƒåŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆNFTä¸èƒ½ç”¨ERC20å®ç°ï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"ERC20æ˜¯åŒè´¨åŒ–ä»£å¸ï¼ŒERC721æ˜¯éåŒè´¨åŒ–ä»£å¸ã€‚ERC20ä»£å¸éƒ½ä¸€æ ·ï¼ŒERC721æ¯ä¸ªéƒ½ä¸åŒã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **æ ¸å¿ƒåŒºåˆ«åœ¨äºæ•°æ®ç»“æ„å’Œè½¬è´¦é€»è¾‘ï¼š**
>
> **1. æ•°æ®ç»“æ„ä¸åŒï¼š**
> ```solidity
> // ERC20ï¼šåœ°å€ â†’ ä½™é¢ï¼ˆæ•°é‡ï¼‰
> mapping(address => uint256) balances;
> // åªå…³å¿ƒ"æœ‰å¤šå°‘"ï¼Œä¸å…³å¿ƒ"æ˜¯å“ªäº›"
>
> // ERC721ï¼štokenId â†’ æ‰€æœ‰è€…
> mapping(uint256 => address) owners;
> // æ¯ä¸ªtokenIdéƒ½æ˜¯ç‹¬ç«‹è¿½è¸ªçš„
> ```
>
> **2. è½¬è´¦å‚æ•°ä¸åŒï¼š**
> ```solidity
> // ERC20ï¼šè½¬å¤šå°‘
> function transfer(address to, uint256 amount);
>
> // ERC721ï¼šè½¬å“ªä¸€ä¸ª
> function transferFrom(address from, address to, uint256 tokenId);
> ```
>
> **3. æˆæƒæœºåˆ¶ä¸åŒï¼š**
> - ERC20ï¼šæˆæƒé¢åº¦ï¼ˆspenderå¯ä»¥èŠ±æˆ‘å¤šå°‘ä»£å¸ï¼‰
> - ERC721ï¼šæˆæƒç‰¹å®štokenIdæˆ–æˆæƒoperatoræ“ä½œæ‰€æœ‰NFT
>
> **ä¸ºä»€ä¹ˆNFTä¸èƒ½ç”¨ERC20å®ç°ï¼Ÿ**
>
> å‡è®¾ç”¨ERC20è¡¨ç¤ºNFTï¼š
> ```javascript
> // é—®é¢˜1ï¼šæ— æ³•åŒºåˆ†ä¸åŒçš„NFT
> // æˆ‘æœ‰3ä¸ªNFTï¼Œbalanceæ˜¯3ï¼Œä½†æˆ‘ä¸çŸ¥é“æ˜¯å“ª3ä¸ª
>
> // é—®é¢˜2ï¼šæ— æ³•å…³è”å…ƒæ•°æ®
> // tokenURI(tokenId)éœ€è¦çŸ¥é“å…·ä½“æ˜¯å“ªä¸ªNFT
>
> // é—®é¢˜3ï¼šæ— æ³•ç²¾ç¡®æˆæƒ
> // æˆ‘åªæƒ³æˆæƒå–æ‰#123ï¼Œä¸æƒ³å–#456
> ```
>
> **ä½†æœ‰äº›åœºæ™¯å¯ä»¥"æ¨¡æ‹Ÿ"ï¼š**
> - ERC1155å¤šä»£å¸æ ‡å‡†ï¼Œå¯ä»¥åŒæ—¶è¡¨ç¤ºFTå’ŒNFT
> - åˆ†æ•°åŒ–NFTï¼ˆF-NFTï¼‰ï¼šæŠŠä¸€ä¸ªNFTæ‹†æˆERC20ä»½é¢
>
> **å®é™…åº”ç”¨ï¼š**
> - NFTå¸‚åœºï¼ˆOpenSeaï¼‰ä½¿ç”¨ERC721/1155
> - æ¸¸æˆé“å…·å¦‚æœå¯å †å ç”¨ERC1155ï¼Œå¦‚æœç‹¬ç‰¹ç”¨ERC721
> - è‰ºæœ¯å“æ”¶è—å¿…é¡»ç”¨ERC721ç¡®ä¿å”¯ä¸€æ€§

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… ç”¨ä»£ç å±•ç¤ºæ ¸å¿ƒæ•°æ®ç»“æ„å·®å¼‚
2. âœ… è§£é‡Šäº†ä¸ºä»€ä¹ˆERC20æ— æ³•å®ç°NFTåŠŸèƒ½
3. âœ… æåˆ°äº†ERC1155å’ŒF-NFTç­‰æ‰©å±•æ–¹æ¡ˆ
4. âœ… ç»™å‡ºäº†å®é™…åº”ç”¨åœºæ™¯çš„é€‰æ‹©å»ºè®®

---

### é—®é¢˜2ï¼š"è§£é‡Šä¸€ä¸‹ERC721çš„safeTransferFromï¼Œä¸ºä»€ä¹ˆéœ€è¦å®ƒï¼Ÿ"

**æ™®é€šå›ç­”ï¼ˆâŒ ä¸å‡ºå½©ï¼‰ï¼š**

"safeTransferFromæ¯”transferFromæ›´å®‰å…¨ï¼Œä¼šæ£€æŸ¥æ¥æ”¶æ–¹èƒ½ä¸èƒ½æ”¶NFTã€‚"

**å‡ºå½©å›ç­”ï¼ˆâœ… æ¨èï¼‰ï¼š**

> **safeTransferFromè§£å†³äº†NFTæ°¸ä¹…ä¸¢å¤±çš„é—®é¢˜ï¼š**
>
> **é—®é¢˜åœºæ™¯ï¼š**
> ```solidity
> // å¦‚æœæ¥æ”¶åœ°å€æ˜¯åˆçº¦ï¼Œä½†åˆçº¦æ²¡æœ‰å¤„ç†NFTçš„é€»è¾‘
> nft.transferFrom(alice, someContract, tokenId);
> // NFTè¿›å…¥äº†someContractï¼Œä½†someContractæ— æ³•è½¬å‡ºå®ƒ
> // NFTæ°¸ä¹…é”å®šï¼Œç›¸å½“äºé”€æ¯ï¼
> ```
>
> **safeTransferFromçš„å·¥ä½œåŸç†ï¼š**
>
> ```solidity
> function safeTransferFrom(address from, address to, uint256 tokenId) {
>     // 1. æ‰§è¡Œæ™®é€šè½¬è´¦
>     transferFrom(from, to, tokenId);
>
>     // 2. å¦‚æœæ¥æ”¶æ–¹æ˜¯åˆçº¦ï¼ˆæœ‰ä»£ç ï¼‰
>     if (to.code.length > 0) {
>         // 3. è°ƒç”¨æ¥æ”¶æ–¹çš„onERC721Received
>         bytes4 retval = IERC721Receiver(to).onERC721Received(
>             msg.sender, from, tokenId, data
>         );
>         // 4. æ£€æŸ¥è¿”å›å€¼æ˜¯å¦æ­£ç¡®
>         require(retval == 0x150b7a02, "Not ERC721Receiver");
>     }
> }
> ```
>
> **æ¥æ”¶åˆçº¦å¿…é¡»å®ç°çš„æ¥å£ï¼š**
> ```solidity
> interface IERC721Receiver {
>     function onERC721Received(
>         address operator,  // è°ƒç”¨è€…
>         address from,      // åŸæ‰€æœ‰è€…
>         uint256 tokenId,   // NFT ID
>         bytes calldata data // é™„åŠ æ•°æ®
>     ) external returns (bytes4);
> }
>
> // æ­£ç¡®çš„è¿”å›å€¼
> return IERC721Receiver.onERC721Received.selector;
> // å³ bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))
> // = 0x150b7a02
> ```
>
> **å®é™…åº”ç”¨ï¼š**
> - NFTå¸‚åœºåˆçº¦å¿…é¡»å®ç°IERC721Receiveræ‰èƒ½æ¥æ”¶ç”¨æˆ·å­˜å…¥çš„NFT
> - æ¸¸æˆåˆçº¦éœ€è¦å®ç°å®ƒæ¥æ¥æ”¶æ¸¸æˆé“å…·
> - é’±åŒ…åˆçº¦ï¼ˆå¦‚Safeï¼‰ä¹Ÿéœ€è¦å®ç°
>
> **æ³¨æ„ç‚¹ï¼š**
> - å¯¹äºEOAï¼ˆæ™®é€šç”¨æˆ·åœ°å€ï¼‰ï¼Œsafeå’Œæ™®é€šç‰ˆæœ¬æ²¡åŒºåˆ«
> - safeç‰ˆæœ¬Gasæ¶ˆè€—æ›´é«˜ï¼ˆéœ€è¦é¢å¤–æ£€æŸ¥å’Œè°ƒç”¨ï¼‰
> - æŸäº›åœºæ™¯æ•…æ„ç”¨transferFromï¼ˆå¦‚NFTé”€æ¯åˆ°é»‘æ´åœ°å€ï¼‰

**ä¸ºä»€ä¹ˆè¿™ä¸ªå›ç­”å‡ºå½©ï¼Ÿ**
1. âœ… ç”¨å…·ä½“åœºæ™¯è¯´æ˜é—®é¢˜
2. âœ… å±•ç¤ºäº†å®Œæ•´çš„å®ç°é€»è¾‘
3. âœ… ç»™å‡ºäº†æ¥æ”¶åˆçº¦çš„å®ç°ç¤ºä¾‹
4. âœ… åˆ†æäº†Gaså¼€é”€å’Œä½¿ç”¨åœºæ™¯çš„æƒè¡¡

---

## 9. ã€åŒ–éª¨ç»µæŒã€‘

### å¡ç‰‡1ï¼šç›´è§‰ç†è§£ - ERC721æ˜¯ä»€ä¹ˆï¼Ÿ ğŸ¯

**ä¸€å¥è¯ï¼š** ERC721æ˜¯ä»¥å¤ªåŠNFTçš„æ ‡å‡†æ¥å£ï¼Œæ¯ä¸ªä»£å¸éƒ½æœ‰å”¯ä¸€çš„tokenIdï¼Œä»£è¡¨ç‹¬ä¸€æ— äºŒçš„æ•°å­—èµ„äº§ã€‚

**ä¸¾ä¾‹ï¼š**
å°±åƒæ¯å¥—æˆ¿å­éƒ½æœ‰å”¯ä¸€çš„æˆ¿äº§è¯å·ï¼Œæ¯ä¸ªERC721ä»£å¸éƒ½æœ‰å”¯ä¸€çš„tokenIdã€‚ä½ çš„BAYC#1234å’Œåˆ«äººçš„BAYC#5678æ˜¯å®Œå…¨ä¸åŒçš„èµ„äº§ã€‚

**åº”ç”¨ï¼š** æ•°å­—è‰ºæœ¯ã€æ¸¸æˆé“å…·ã€è™šæ‹ŸåœŸåœ°ã€ä¼šå‘˜é€šè¡Œè¯ã€åŸŸåç­‰éƒ½ä½¿ç”¨ERC721æ ‡å‡†ã€‚

---

### å¡ç‰‡2ï¼šå½¢å¼åŒ–å®šä¹‰ - æ ¸å¿ƒæ•°æ®ç»“æ„ ğŸ“

**ä¸€å¥è¯ï¼š** ERC721çš„æ ¸å¿ƒæ˜¯`mapping(uint256 => address)`ï¼Œå³tokenIdåˆ°æ‰€æœ‰è€…çš„æ˜ å°„ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
mapping(uint256 => address) private _owners;
// _owners[1] = 0xAlice  â†’ NFT #1 å±äº Alice
// _owners[2] = 0xBob    â†’ NFT #2 å±äº Bob
// _owners[3] = 0xAlice  â†’ NFT #3 ä¹Ÿå±äº Alice

mapping(address => uint256) private _balances;
// _balances[Alice] = 2  â†’ Aliceæœ‰2ä¸ªNFT
// _balances[Bob] = 1    â†’ Bobæœ‰1ä¸ªNFT
```

**åº”ç”¨ï¼š** æŸ¥è¯¢NFTæ‰€æœ‰è€…ç”¨`ownerOf(tokenId)`ï¼ŒæŸ¥è¯¢æŸäººæœ‰å¤šå°‘NFTç”¨`balanceOf(address)`ã€‚

---

### å¡ç‰‡3ï¼šå…³é”®æ¦‚å¿µ - tokenIdå”¯ä¸€æ ‡è¯† ğŸ”¢

**ä¸€å¥è¯ï¼š** tokenIdæ˜¯uint256ç±»å‹çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œåœ¨åŒä¸€ä¸ªåˆçº¦å†…ä¸ä¼šé‡å¤ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// å¸¸è§çš„tokenIdç”Ÿæˆæ–¹å¼
uint256 private _counter;

function mint(address to) public {
    _counter++;
    _mint(to, _counter);  // tokenId: 1, 2, 3, 4...
}

// æˆ–è€…åŸºäºå†…å®¹å“ˆå¸Œ
uint256 tokenId = uint256(keccak256(abi.encodePacked(contentURI)));
```

**åº”ç”¨ï¼š** tokenIdé€šå¸¸ä»1é€’å¢ï¼Œä¹Ÿå¯ä»¥ç”¨å“ˆå¸Œæˆ–å…¶ä»–æ–¹å¼ç”Ÿæˆï¼Œç¡®ä¿å”¯ä¸€å³å¯ã€‚

---

### å¡ç‰‡4ï¼šå…³é”®æ¦‚å¿µ - ä¸¤ç§æˆæƒæ–¹å¼ ğŸ”

**ä¸€å¥è¯ï¼š** ERC721æœ‰`approve`ï¼ˆæˆæƒå•ä¸ªNFTï¼‰å’Œ`setApprovalForAll`ï¼ˆæˆæƒæ‰€æœ‰NFTï¼‰ä¸¤ç§æ–¹å¼ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// æ–¹å¼1ï¼šæˆæƒå•ä¸ªNFTç»™æŸåœ°å€
nft.approve(marketplace, tokenId);
// åªæœ‰è¿™ä¸ªtokenIdå¯ä»¥è¢«marketplaceæ“ä½œ

// æ–¹å¼2ï¼šæˆæƒæ‰€æœ‰NFTç»™æ“ä½œå‘˜
nft.setApprovalForAll(marketplace, true);
// marketplaceå¯ä»¥æ“ä½œä½ çš„æ‰€æœ‰NFT
```

**åº”ç”¨ï¼š** åœ¨OpenSeaæŒ‚å•éœ€è¦å…ˆæˆæƒï¼Œé€šå¸¸ä½¿ç”¨setApprovalForAllä¸€æ¬¡æˆæƒæ‰€æœ‰ã€‚

---

### å¡ç‰‡5ï¼šç¼–ç¨‹å®ç° - safeTransferFrom ğŸ’»

**ä¸€å¥è¯ï¼š** `safeTransferFrom`åœ¨è½¬è´¦æ—¶æ£€æŸ¥æ¥æ”¶æ–¹æ˜¯å¦å®ç°äº†`IERC721Receiver`æ¥å£ï¼Œé˜²æ­¢NFTä¸¢å¤±ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
// æ¥æ”¶NFTçš„åˆçº¦å¿…é¡»å®ç°
function onERC721Received(
    address operator,
    address from,
    uint256 tokenId,
    bytes calldata data
) external returns (bytes4) {
    // å¤„ç†æ¥æ”¶é€»è¾‘
    return IERC721Receiver.onERC721Received.selector;
}
```

**åº”ç”¨ï¼š** è½¬è´¦ç»™åˆçº¦åœ°å€æ—¶åŠ¡å¿…ä½¿ç”¨safeTransferFromï¼Œå¦åˆ™NFTå¯èƒ½æ°¸ä¹…é”å®šã€‚

---

### å¡ç‰‡6ï¼šå¯¹æ¯”åŒºåˆ† - ERC721 vs ERC20 ğŸ†š

**ä¸€å¥è¯ï¼š** ERC20è¿½è¸ªä½™é¢ï¼ŒERC721è¿½è¸ªæ‰€æœ‰æƒï¼›ERC20å¯äº’æ¢ï¼ŒERC721ä¸å¯äº’æ¢ã€‚

**ä¸¾ä¾‹ï¼š**

| ç‰¹æ€§ | ERC20 | ERC721 |
|-----|-------|--------|
| æ ¸å¿ƒæ˜ å°„ | `address â†’ ä½™é¢` | `tokenId â†’ æ‰€æœ‰è€…` |
| transferå‚æ•° | `amount` | `tokenId` |
| ä»£å¸æ€§è´¨ | åŒè´¨åŒ– | éåŒè´¨åŒ– |
| æˆæƒæ–¹å¼ | æˆæƒé‡‘é¢ | æˆæƒç‰¹å®štokenIdæˆ–å…¨éƒ¨ |

**åº”ç”¨ï¼š** ä»£å¸ç”¨ERC20ï¼Œæ”¶è—å“/è¯ä¹¦ç”¨ERC721ï¼Œå¯å †å é“å…·ç”¨ERC1155ã€‚

---

### å¡ç‰‡7ï¼šè¿›é˜¶ç†è§£ - tokenURIå…ƒæ•°æ® ğŸ“„

**ä¸€å¥è¯ï¼š** `tokenURI`è¿”å›æŒ‡å‘NFTå…ƒæ•°æ®çš„URLï¼Œå…ƒæ•°æ®åŒ…å«åç§°ã€æè¿°ã€å›¾ç‰‡ã€å±æ€§ç­‰ã€‚

**ä¸¾ä¾‹ï¼š**
```json
// tokenURIè¿”å›çš„JSON
{
    "name": "Cool Cat #42",
    "description": "A unique cool cat",
    "image": "ipfs://Qm.../42.png",
    "attributes": [
        { "trait_type": "Background", "value": "Blue" },
        { "trait_type": "Eyes", "value": "Laser" }
    ]
}
```

**åº”ç”¨ï¼š** OpenSeaç­‰å¸‚åœºé€šè¿‡tokenURIè·å–å¹¶å±•ç¤ºNFTçš„å›¾ç‰‡å’Œå±æ€§ã€‚

---

### å¡ç‰‡8ï¼šé«˜çº§åº”ç”¨ - ERC721æ‰©å±• ğŸ›¡ï¸

**ä¸€å¥è¯ï¼š** OpenZeppelinæä¾›å¤šç§ERC721æ‰©å±•ï¼šEnumerableï¼ˆå¯æšä¸¾ï¼‰ã€URIStorageï¼ˆå•ç‹¬å­˜URIï¼‰ã€Burnableï¼ˆå¯é”€æ¯ï¼‰ç­‰ã€‚

**ä¸¾ä¾‹ï¼š**
```solidity
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";

contract MyNFT is ERC721, ERC721Enumerable, ERC721URIStorage, ERC721Burnable {
    // ç»„åˆå¤šä¸ªæ‰©å±•
}
```

**åº”ç”¨ï¼š** éœ€è¦æŸ¥è¯¢ç”¨æˆ·æ‰€æœ‰NFTç”¨Enumerableï¼Œéœ€è¦æ¯ä¸ªNFTå•ç‹¬URIç”¨URIStorageã€‚

---

### å¡ç‰‡9ï¼šåœ¨NFTç”Ÿæ€ä¸­çš„åº”ç”¨ ğŸŒ

**ä¸€å¥è¯ï¼š** ERC721æ˜¯æ•´ä¸ªNFTç”Ÿæ€çš„åŸºç¡€ï¼Œå¸‚åœºã€æ¸¸æˆã€DeFiéƒ½å›´ç»•å®ƒæ„å»ºã€‚

**ä¸¾ä¾‹ï¼š**
- **NFTå¸‚åœº**ï¼ˆOpenSeaã€Blurï¼‰ï¼šæŒ‚å•ã€æ‹å–ã€äº¤æ˜“ERC721
- **NFTå€Ÿè´·**ï¼ˆNFTfiã€BendDAOï¼‰ï¼šæŠµæŠ¼ERC721å€Ÿå‡ºèµ„é‡‘
- **æ¸¸æˆ**ï¼ˆAxieã€BAYCï¼‰ï¼šæ¸¸æˆè§’è‰²/é“å…·æ˜¯ERC721
- **èº«ä»½/é€šè¡Œè¯**ï¼ˆENSã€POAPï¼‰ï¼šé“¾ä¸Šèº«ä»½å’Œæ´»åŠ¨è¯æ˜
- **éŸ³ä¹/ç¥¨åŠ¡**ï¼šç‰ˆç¨åˆ†æˆã€æ´»åŠ¨é—¨ç¥¨

**åº”ç”¨ï¼š** ç†è§£ERC721å°±èƒ½ç†è§£90%çš„NFTåº”ç”¨åœºæ™¯ã€‚

---

### å¡ç‰‡10ï¼šæ€»ç»“ä¸å»¶ä¼¸ ğŸ“

**ä¸€å¥è¯ï¼š** ERC721æ˜¯NFTçš„"æˆ¿äº§è¯æ ‡å‡†"ï¼ŒæŒæ¡tokenIdã€ownerOfã€safeTransferFromã€tokenURIå››ä¸ªæ ¸å¿ƒæ¦‚å¿µå³å¯å¼€å‘NFTåº”ç”¨ã€‚

**æ ¸å¿ƒè¦ç‚¹æ€»ç»“ï¼š**
1. **tokenId** = å”¯ä¸€èº«ä»½è¯å·
2. **ownerOf** = æŸ¥è¯¢æ‰€æœ‰è€…
3. **safeTransferFrom** = å®‰å…¨è½¬è´¦
4. **tokenURI** = å…ƒæ•°æ®é“¾æ¥
5. **ä¸¤ç§æˆæƒ** = approveå•ä¸ª / setApprovalForAllå…¨éƒ¨

**ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®ï¼š**
- **ERC1155**ï¼šå¤šä»£å¸æ ‡å‡†ï¼ŒFTå’ŒNFTæ··åˆ
- **ERC2981**ï¼šNFTç‰ˆç¨æ ‡å‡†
- **IPFS/Arweave**ï¼šå»ä¸­å¿ƒåŒ–å­˜å‚¨
- **å®æˆ˜**ï¼šéƒ¨ç½²NFTå¹¶ä¸Šæ¶OpenSea

---

## 10. ã€ä¸€å¥è¯æ€»ç»“ã€‘

**ERC721æ˜¯ä»¥å¤ªåŠéåŒè´¨åŒ–ä»£å¸ï¼ˆNFTï¼‰çš„æ¥å£æ ‡å‡†ï¼Œé€šè¿‡å”¯ä¸€çš„tokenIdè¿½è¸ªæ•°å­—èµ„äº§æ‰€æœ‰æƒï¼Œé…åˆtokenURIå…³è”å…ƒæ•°æ®ï¼Œæ”¯æŒæˆæƒå’Œå®‰å…¨è½¬è´¦æœºåˆ¶ï¼Œæ˜¯æ•°å­—è‰ºæœ¯ã€æ¸¸æˆé“å…·ã€è™šæ‹Ÿèº«ä»½ç­‰NFTåº”ç”¨çš„æŠ€æœ¯åŸºç¡€ã€‚**

---

## ğŸ“š é™„å½•

### å­¦ä¹ æ£€æŸ¥æ¸…å•

å®Œæˆæœ¬çŸ¥è¯†ç‚¹å­¦ä¹ åï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- [ ] è¯´å‡ºERC721çš„æ ¸å¿ƒæ•°æ®ç»“æ„ï¼ˆtokenId â†’ owneræ˜ å°„ï¼‰
- [ ] è§£é‡ŠERC721å’ŒERC20çš„å…³é”®åŒºåˆ«
- [ ] è¯´æ˜safeTransferFromçš„å·¥ä½œåŸç†å’Œå¿…è¦æ€§
- [ ] å®ç°IERC721Receiveræ¥å£è®©åˆçº¦èƒ½æ¥æ”¶NFT
- [ ] ä½¿ç”¨ethers.jsè¯»å–NFTä¿¡æ¯å’Œå…ƒæ•°æ®
- [ ] ä½¿ç”¨ethers.jsè½¬è´¦å’ŒæˆæƒNFT
- [ ] ä½¿ç”¨OpenZeppelinå¿«é€Ÿéƒ¨ç½²NFTåˆçº¦
- [ ] ç†è§£tokenURIå’Œå…ƒæ•°æ®çš„å…³ç³»
- [ ] åŒºåˆ†approveå’ŒsetApprovalForAllçš„ä½¿ç”¨åœºæ™¯
- [ ] ç›‘å¬Transferäº‹ä»¶è¿½è¸ªNFTè½¬ç§»

### å¿«é€Ÿå‚è€ƒå¡

**ERC721 ABIï¼ˆæœ€å°åŒ–ï¼‰ï¼š**

```javascript
const ERC721_ABI = [
    "function name() view returns (string)",
    "function symbol() view returns (string)",
    "function balanceOf(address) view returns (uint256)",
    "function ownerOf(uint256) view returns (address)",
    "function tokenURI(uint256) view returns (string)",
    "function approve(address, uint256)",
    "function setApprovalForAll(address, bool)",
    "function getApproved(uint256) view returns (address)",
    "function isApprovedForAll(address, address) view returns (bool)",
    "function transferFrom(address, address, uint256)",
    "function safeTransferFrom(address, address, uint256)",
    "event Transfer(address indexed, address indexed, uint256 indexed)",
    "event Approval(address indexed, address indexed, uint256 indexed)",
    "event ApprovalForAll(address indexed, address indexed, bool)"
];
```

**å¸¸ç”¨ä»£ç ç‰‡æ®µï¼š**

```javascript
// åˆ›å»ºåˆçº¦å®ä¾‹
const nft = new ethers.Contract(nftAddress, ERC721_ABI, provider);

// æŸ¥è¯¢æ‰€æœ‰è€…
const owner = await nft.ownerOf(tokenId);

// æŸ¥è¯¢ç”¨æˆ·NFTæ•°é‡
const balance = await nft.balanceOf(userAddress);

// è·å–å…ƒæ•°æ®
const tokenURI = await nft.tokenURI(tokenId);

// è½¬è´¦NFT
await nft.connect(signer)["safeTransferFrom(address,address,uint256)"](from, to, tokenId);

// æˆæƒ
await nft.connect(signer).approve(operator, tokenId);
await nft.connect(signer).setApprovalForAll(operator, true);
```

### ä¸‹ä¸€æ­¥å­¦ä¹ 

æ¨èæŒ‰ä»¥ä¸‹é¡ºåºç»§ç»­å­¦ä¹ ï¼š

1. **ERC1155** - å¤šä»£å¸æ ‡å‡†ï¼ˆFT+NFTï¼‰
2. **OpenZeppelinåˆçº¦åº“** - NFTæ‰©å±•å’Œå®‰å…¨å®è·µ
3. **IPFS/Arweave** - å»ä¸­å¿ƒåŒ–å­˜å‚¨
4. **NFTå¸‚åœºé›†æˆ** - OpenSea Seaportåè®®
5. **ä»£ç†æ¨¡å¼** - å¯å‡çº§çš„NFTåˆçº¦

### å‚è€ƒèµ„æº

**å®˜æ–¹æ–‡æ¡£ï¼š**
- [EIP-721: Non-Fungible Token Standard](https://eips.ethereum.org/EIPS/eip-721)
- [OpenZeppelin ERC721](https://docs.openzeppelin.com/contracts/4.x/erc721)

**å…ƒæ•°æ®æ ‡å‡†ï¼š**
- [OpenSea Metadata Standards](https://docs.opensea.io/docs/metadata-standards)
- [IPFS Documentation](https://docs.ipfs.io/)

**å¼€å‘å·¥å…·ï¼š**
- [Hardhat](https://hardhat.org/) - æ™ºèƒ½åˆçº¦å¼€å‘æ¡†æ¶
- [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) - åˆçº¦ç”Ÿæˆå™¨

---

**ç‰ˆæœ¬ï¼š** v1.0
**åˆ›å»ºæ—¥æœŸï¼š** 2025-01-XX
**ä½œè€…ï¼š** Claude Code
**é€‚ç”¨äººç¾¤ï¼š** å‰ç«¯å·¥ç¨‹å¸ˆè½¬Web3å¼€å‘

---

**è®°ä½ï¼š** ERC721æ˜¯NFTä¸–ç•Œçš„"æˆ¿äº§è¯æ ‡å‡†"ï¼æŒæ¡tokenIdã€ownerOfã€safeTransferFromã€tokenURIè¿™å››ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼Œä½ å°±èƒ½å¼€å‘å’Œé›†æˆä»»ä½•NFTåº”ç”¨ï¼ğŸ¨
